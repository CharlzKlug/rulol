\chapter{Анафорические Макросы}\label{chapter_anaphoric_macros}
\section{Больше Фор?}\label{section_more_phors?}


\emph{Анафорические макросы (Anaphoric macros)} - это одни из наиболее интересных макросов из книги Пола Грэма \emph{On Lisp}. Анафорический макрос - это макрос осуществляющий преднамеренный захват переменной из форм, переданных в макрос. Благодаря наличию \emph{прозрачных спецификаций (transparent specifications)} эти преднамеренно захваченные переменные порождают окна, позволяющие осуществлять контроль над расширением макроса. Через эти окна мы можем манипулировать расширением с помощью \emph{комбинаций (combinations)}.

Классическая анафора, такая как в On Lisp, названа также, как и дословное\footnote{Цитирование U-Языка.} \emph{анафор (anaphor)} и во множественном числе, \emph{анафора (ana\-pho\-ra)}. Анафор обозначает захват \emph{свободного слова U-Языка (free U-Language word)} для использования в последующем U-Языке. В терминах программирования, реализация классической анафоры означает нахождение места в вашем коде - или в коде, который вы хотите написать - где выражения могли бы извлечь выгоду, будучи способными сослаться на результаты предыдущих, связанных выражений. Настоятельно рекомендуется к изучению анафора Грэма и код, связанный с этой анафорой. Особенно обратите внимание на макрос \verb"defanaph" [ON-LISP-P223], позволяющий использовать некоторые интересные разновидности программирования \emph{автоматических анафор (automatic anaphor)}.



По истечении некоторого периода было обнаружено, что \verb"alambda" - это наиболее полезный анафорический макрос в \emph{On Lisp}. К тому же \verb"alambda" - это один из наиболее простых и элегантных примеров, демонстрирующих анафорический макрос и преднамеренный захват переменной.

\begin{figure}Листинг 6.1: ALAMBDA\label{listing_6.1}
\listbegin
\begin{verbatim}
;; alambda Грэма
(defmacro alambda (parms &body body)
`(labels ((self ,parms ,@body))
#'self))
\end{verbatim}
\listend
\end{figure}

С \verb"alambda" мы захватываем имя \verb"self", таким образом, мы можем использовать его для построения очень анонимной функции. Другими словами рекурсия становится такой же простой как и вызов \verb"self". Например, следующая функция возвращает список\footnote{Если условие возвращает ложное значение, то отсутствующий третий элемент \verb"if" формы вернёт \verb"nil", что в свою очередь является списком.} чисел с \verb"n" до \verb"1":


\begin{verbatim}
(alambda (n)
(if (> n 0)
(cons
n
(self (- n 1)))))
\end{verbatim}

\verb"Alambda" делает наш код более интуитивным и простым для чтения, позволяя нам думать об анонимных функциях как о функциях способных вызывать саму себя с той же лёгкостью, как и добавление единственной буквы\footnote{Это другая причина не шарп-закавычивать лямбда формы. Изменение шарп-закавыченных лямбда форм в alambda формы также потребует удаления двух символов.}. Поскольку \verb"alambda" прозрачно специфицирован для \verb"self" привязки - и тот факт что единственная причина использования \verb"alambda" - это применение этой привязки - то нежелательный захват переменной уже не проблема.



Другой удобный анафорический макрос из \emph{On Lisp} - это \verb"aif", макрос, привязывающий результат проверки к \verb"it" при положительном (вторичном) случае для последующего применения\footnote{Упражнение: Почему ложный (третичный или альтернативный) вариант никогда не использует эту анафору?}. \verb"Aif" использует удобную COMMON LISP особенность: \emph{обобщённые булевы значения (generalised booleans)}. В COMMON LISP, все не-\verb"nil" значения являются истинными значениями, поэтому COMMON LISP программисты обычно встраивают интересную информацию в истинные значения. Языки в которых зарезервированы истинные и ложные значения - в частности Scheme - используют \emph{явные булевы значения (explicit booleans)}, которые иногда заставляют вас выводить дополнительную информацию для удовлетворения конструкций с избыточным типом. В Scheme добавлен \emph{костыль (kludge)} для того, чтобы \verb"if", \verb"cond", \verb"and", \verb"or" и \verb"do" работали с не-булевыми\footnote{С помощью Scheme предиката \verb"boolean?".} значениями [R5RS-P25]. Конечно, COMMON LISP спроектирован правильно - всё является булевым значением.



\begin{figure}Листинг 6.2: AIF\label{listing_6.2}
\listbegin
\begin{verbatim}
;; aif Грэма
(defmacro aif (test then &optional else)
`(let ((it ,test))
(if it ,then ,else)))
\end{verbatim}
\listend
\end{figure}

Также следует отметить что \verb"aif" и \verb"alambda", как и все анафорические макросы, нарушают \emph{лексическую прозрачность}. Или иначе, выражаясь модными словами, можно сказать что они не \emph{гигиеничные (unhygienic)} макросы. Они, как и большое количество макросов в этой книге, вводят невидимые лексические привязки и поэтому не могут быть созданы в макро системах со строгим соблюдением гигиены. Даже большое количество Scheme систем, платформа в которой много экспериментировали с гигиеной, предоставляют макросы в негигиеничном defmacro стиле - возможно, по той причине, что даже разработчики Scheme не воспринимали всерьёз гигиену. Подобно обучению катания на велосипеде, гигиенические системы в своём большинстве игрушки, которые забрасывают после овладевания минимальным уровнем мастерства.

Да, существует много интересных вещей, которые мы можем делать с помощью преднамеренного захвата переменной. Существует множество фор (phors). Эта книга и книга Грэма \emph{On Lisp} описывает лишь малую часть возможностей, заложенных в эту технику. Из грамотного применения анафорических макросов можно извлечь много новых потрясающих изобретений.

После краткой беседы об анафорах, продемонстрированной считывающими макросами, остаток этой главы описывает узкое приложение анафор к одной из центральных тем этой книги: лексические замыкания - \emph{let, окружающий lambda}. Большая часть этой главы посвящена интересным анафорическим макросам, предназначенным для изменения, адаптации и расширении замыканий. И хотя данная тема очень удобна в практическом применение для написания кода, мы используем её как платформу для обсуждения возможностей и вариантов анафорических макросов. Применение макросов для расширения концепции замыканий - это, на данный момент, интенсивно исследуемая тема [FIRST-CLASS-EXTENTS] [OPENING-CLOSURES].

\section{Шарп-Обратное Закавычивание}\label{section_sharp-backquote} 

Хотя большинство анафор представлено в виде обычных макросов, у считывающих макросов тоже есть возможность использования кода, создающего для нас невидимые привязки. Такие считывающие макросы называются \emph{считывающими анафорами (read anaphora)}. Этот раздел ознакомит вас с таким макросом, который являясь весьма незатейливым, удивил даже меня и который стал одним из наиболее полезных макросов, используемых в этой книге. Я постарался как можно скорее перейти к этому макросу, поскольку он будет использоваться в оставшемся коде. Более того, несколько рассмотренных нами макросов уже используют его.

\begin{figure}Листинг 6.3: SHARP-BACKQUOTE\label{listing_6.3}
\listbegin
\begin{verbatim}
(defun |#`-reader| (stream sub-char numarg)
(declare (ignore sub-char))
(unless numarg (setq numarg 1))
`(lambda ,(loop for i from 1 to numarg
collect (symb 'a i))
,(funcall
(get-macro-character #\`) stream nil)))

(set-dispatch-macro-character
#\# #\` #'|#`-reader|)
\end{verbatim}
\listend
\end{figure}

Шарп-обратное закавычивание - это считывающий макрос, выполняющий считывание как лямбда форма. По умолчанию, эта лямбда форма получает только один аргумент: \verb"a1". Затем считывающий макрос рекурсивно вызывает функцию \verb"read" для переданного потока. Ниже есть пример с остановленным вычислением (с помощью \verb"quote"), и мы можем рассмотреть прозрачное введение считывающей анафоры\footnote{Конечно, префикс захваченного символа, ``\verb"a"'', расшифровывается анафорой.}:



\begin{verbatim}
* '#`((,a1))

(LAMBDA (A1)
`((,A1)))
\end{verbatim}

Этот считывающий макрос формирует абстракцию общего шаблона макроса. Например, если у нас есть список переменных и мы хотим создать список \verb"let" привязок, где каждая переменная привязана к символу, скажем, \verb"empty", то мы можем использовать \verb"mapcar" следующим способом:

\begin{verbatim}
* (mapcar (lambda (a)
(list a ''empty))
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

Но особенно для сложных списковых структур, такой подход может оказаться довольно грязным, поэтому лисп программисты предпочитают использовать обратное закавычивание для поднятия на один уровень закавычивания:

\begin{verbatim}
* (mapcar (lambda (a)
`(,a 'empty))
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

Наш новый считывающий макрос вводит анафору и скрывает лямбда форму:

\begin{verbatim}
* (mapcar #`(,a1 'empty)
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

\verb"1" в символе \verb"a1" выше говорит о том, что пользователи считывающего макроса могут вводить переменное число анафор, зависящее от числа переданного в параметр \verb"numarg" считывающего макроса:

\begin{verbatim}
* '#2`(,a1 ,a2)

(LAMBDA (A1 A2)
`(,A1 ,A2))
\end{verbatim}

Таким образом мы можем одновременно за\verb"mapcar"-ить шарп-обратно закавыченные выражения с несколькими списками:

\begin{verbatim}
* (let ((vars '(var-a var-b var-c)))
(mapcar #2`(,a1 ',a2)
vars
(loop for v in vars
collect (gensym
(symbol-name v)))))

((VAR-A '#:VAR-A1731)
(VAR-B '#:VAR-B1732)
(VAR-C '#:VAR-C1733))
\end{verbatim}

Ещё один способ думать о шарп-обратном закавычивании: шарп - обратное закавычивание выполняет интерполяцию списка, также, как функция \verb"format" выполняет интерполяцию строки. \verb"Format" позволяет нам использовать шаблоны со слотами, заполняемыми значениями отдельных аргументов, аналогично шарп-обратное закавычивание позволяет нам отделить структуру интерполированного списка от значений, с которыми мы хотим их объединить. Благодаря ранее описанному \emph{дуализму синтаксиса} между лямбда формами в позиции функции в списке и лямбда формами, использующими макрос \verb"lambda" для расширения в функцию, мы также можем использовать шарп-обратное закавычивание в роли первого элемента при вызове функции:

\begin{verbatim}
* (#3`(((,a1)) ,@a2 (,a3))
(gensym)
'(a b c)
'hello)

(((#:G1734)) A B C (HELLO))
\end{verbatim}

В отличие от \verb"format" шарп-обратное закавычивание не использует последовательное позиционирование. Вместо этого используется числа для наших анафорических привязок. Вследствие этого порядок может перемешиваться и мы можем сращивать привязки более одного раза:

\begin{verbatim}
* (#3`(((,@a2)) ,a3 (,a1 ,a1))
(gensym)
'(a b c)
'hello)

(((A B C)) HELLO (#:G1735 #:G1735))
\end{verbatim}

Упражнение: Ссылки на \verb"gensym #:G1735" выглядят так, как будто ссылаются на один и тот-же символ, но, конечно, вы никогда не можете утверждать это глядя на напечатанные имена. Являются ли эти символы \verb"eq"-абельными? Обоснуйте ответ.

\section{Alet и Машины с Конечным Состоянием}\label{section_alet_and_finite_state_machines}


С \emph{lambda} и \emph{if} возможна только одна полезная анафорическая конфигурация. Но большинство интересных типов анафорических макросов используют расширения самыми неожиданными способами. Этот раздел - как и большая часть этой главы - посвящена одному из таких макросов: \verb"alet". Какие дополнительные привязки могут быть полезны для форм внутри тела \verb"let" формы? \verb"Let" используется для того, чтобы создать привязки к переданным переменным. Однако, макро улучшение \verb"let" даст возможность получения доступа ко всем переданным формам, даже если тела этих выражений должны вычисляться с новыми привязками. Так какая же часть тела наиболее полезна? В большинстве случаев это последняя форма тела, поскольку результаты этой формы будут возвращены из самого оператора \verb"let"\footnote{Поскольку \verb"let" предоставляет неявный \verb"progn".}. Мы уже видели что когда мы возвращаем лямбда выражение, ссылающееся на привязки, созданные \verb"let"-ом, то результатом является лексическое замыкание - объект, часто сохраняемый и используемый для последующего доступа к переменным в \verb"let" операторе. Таким образом, расширение нашего аналога объекта-замыкания, макрос \verb"alet%" работает также, как и специальная форма \verb"let", с тем отличием, что захватывает символ \verb"this" из тела и привязывает его к последнему выражению в теле формы - единственное, что будет возвращено как замыкание\footnote{\verb"Setq" применяется потому что форма привязанная к \verb"this" определена в лексической области видимости других аргументов заданных через \verb"letargs".}.


\begin{figure}Листинг 6.4: ALET-1\label{listing_6.4}
\listbegin
\begin{verbatim}
(defmacro alet% (letargs &rest body)
`(let ((this) ,@letargs)
(setq this ,@(last body))
,@(butlast body)
this))
\end{verbatim}
\listend
\end{figure}

\verb"Alet%" может быть полезен в случае когда у нас есть инициализирующий код в лямбда форме, который мы не хотим дублировать. Поскольку \verb"this" привязан к возвращаемой лямбда форме, то у нас есть возможность выполнить его перед выходом из окружающего \verb"let". Следующий пример - это замыкание, конструкция которого показывает простой пример использования \verb"alet%" с целью избежания дублирования инициализирующего и сбрасывающего кода:

\begin{verbatim}
* (alet% ((sum) (mul) (expt))
(funcall this :reset)
(dlambda
(:reset ()
(psetq sum 0
mul 1
expt 2))
(t (n)
(psetq sum (+ sum n)
mul (* mul n)
expt (expt expt n))
(list sum mul expt))))

#<Interpreted Function>
\end{verbatim}

С помощью этого кода мы можем последовательно изменять значения \verb"sum", \verb"mul" и \verb"expt":

\begin{verbatim}
* (loop for i from 1 to 5 collect (funcall * 2))

((2 2 4)
(4 4 16)
(6 8 256)
(8 16 65536)
(10 32 4294967296))
\end{verbatim}

Мы можем сбросить замыкание вызвав метод \verb":reset". Заметьте, что благодаря \verb"alet%", для сброса в базовые состояния (0 для \verb"sum", 1 для \verb"mul" и 2 для \verb"expt") достаточно использовать \verb":reset" в одном месте:

\begin{verbatim}
* (funcall ** :reset)

NIL
\end{verbatim}

Теперь, когда переменные замыкания были сброшены, мы можем увидеть новую последовательность:

\begin{verbatim}
* (loop for i from 1 to 5 collect (funcall *** 0.5))

((0.5 0.5 1.4142135)
(1.0 0.25 1.1892071)
(1.5 0.125 1.0905077)
(2.0 0.0625 1.0442737)
(2.5 0.03125 1.0218971))
\end{verbatim}

Учтите, что \verb"alet%" меняет порядок вычисления форм в теле \verb"let". Если вы посмотрите на расширение, вы увидите, что последняя форма тела вычислена первой, её результат привязан лексической привязке \verb"this", а после этого вычисляются предыдущие формы. И пока последний аргумент является константой, изменение порядка вычислений не играет никакой роли. Помните что лямбда выражение\footnote{\verb"Dlambda" расширяется в лямбда формы.} является константой и, таким образом, идеально подходит для использования в \verb"alet%".



\begin{figure}Листинг 6.5: ALET\label{listing_6.5}
\listbegin
\begin{verbatim}
(defmacro alet (letargs &rest body)
`(let ((this) ,@letargs)
(setq this ,@(last body))
,@(butlast body)
(lambda (&rest params)
(apply this params))))
\end{verbatim}
\listend
\end{figure}

Нам доступны множество уровней свободы, поэтому улучшение этого макроса, как и многие другие улучшения макросов, кажутся нелогичными. И хотя существуют множество возможностей, этот раздел посвящён рассмотрению одного такого специфического улучшения. \verb"Alet%" можно модифицировать таким образом, чтобы он не возвращал последнюю форму своего тела - про которое мы уже заранее знаем что оно будет лямбда формой - взамен функции, находящей другую функцию внутри лексической области видимости \verb"let" формы, и вызывающей эту функцию. Иногда это называется \emph{косвенностью (indirection)}, поскольку вместо возвращения функции, выполняющей что либо, мы возвращаем функцию, которая ищет функцию с помощью разыменовывания указателя и после этого использует эту функцию. Косвенность - это понятие, применимое ко всем языкам программирования. Оно позволяет нам менять объекты во время выполнения в то время когда без косвенности, эти объекты являются неизменными во время компиляции. Лисп позволяет нам использовать косвенность в более кратком и удобном стиле чем во многих других языках программирования. \verb"Alet" - версия \verb"alet%" с косвенностью, позволяет получить доступ к функции, возвращённой нами как замыкание или заместить эту функцию кодом внутри тела \verb"alet" или, если мы используем \verb"dlambda", как это будет показано позже, даже кодом, находящимся за пределом тела \verb"alet".

Теперь, когда мы можем изменить функцию, которая запускается при вызове замыкания с нашим макросом \verb"alet", у нас есть возможность создания пары взаимно ссылающихся функций с помощью шаблона под названием \emph{alet, окружающий alambda}. Если все состояния возвращаются в исходное состояние - вместо того, чтобы переходить в состояния друг в друга - то, \verb"alet", окружающий \verb"alambda" - это удобный способ определения безымянных машин с состоянием.

Следующее типичное замыкание-счётчик получает аргумент \verb"n" и может менять направление счётчика между инкрементированием и декрементированием на \verb"n" при передаче символа \verb"invert" в качестве аргумента взамен числа \verb"n":

\begin{verbatim}
* (alet ((acc 0))
(alambda (n)
(if (eq n 'invert)
(setq this
(lambda (n)
(if (eq n 'invert)
(setq this #'self)
(decf acc n))))
(incf acc n))))

#<Interpreted Function>
\end{verbatim}

Сохраним это замыкание для того, чтобы мы могли использовать его так часто, насколько это нам будет нужно:

\begin{verbatim}
* (setf (symbol-function 'alet-test) *)

#<Interpreted Function>
\end{verbatim}

При первом запуске счётчик идёт на увеличение:

\begin{verbatim}
* (alet-test 10)

10
\end{verbatim}

Но, мы можем изменять функцию, на вызов внутреннего лямбда выражения в нашем определении через передачу символа \verb"invert" замыканию:

\begin{verbatim}
* (alet-test 'invert)

#<Interpreted Function>
\end{verbatim}

И теперь мы идём вниз:

\begin{verbatim}
* (alet-test 3)

7
\end{verbatim}

И наконец благодаря привязке \verb"self" предоставляемой \verb"alambda" мы можем снова сменить вызываемую функцию передав символ \verb"invert":

\begin{verbatim}
* (alet-test 'invert)

#<Interpreted Function>
\end{verbatim}

Мы вернулись к предыдущему направлению и идём вверх:

\begin{verbatim}
* (alet-test 5)

12
\end{verbatim}

Это замыкание будет привязано к символу \verb"alet-test" относящемуся к пространству функции . Но это замыкание слегка отличается от обычного замыкания. Оба этих замыкания (обычное замыкание и наше замыкание) являются ссылками к одной среде, которое может иметь любое количество указателей, это замыкание использует косвенность для изменения кода, который будет выполнен при вызове. И хотя установленным может быть любой код, получить доступ к лексическим привязкам анафоре \verb"this" в лексической области \verb"alet" может только один код. Но, нам по прежнему ничто не мешает установить новое замыкание, с его собственными лексическими привязками и, возможно, с изменённым поведением в \emph{косвенной среде}, установленной с помощью \verb"alet". Большая часть этой главы посвящена полезным приёмам, которые мы можем выполнять с косвенной средой, созданной с помощью \verb"alet".

Общая техника работы с макросами неформально известна как \emph{выворачивание макроса наизнанку (turning a macro inside out)}. Когда вы выворачиваете макрос наизнанку вы получаете типичную форму, использующую макрос, подобный макросу который вы хотите создать, и расширяете её. Дальше вы используете расширение как шаблон для вашего желаемого макроса. Например, мы хотели бы получить более универсальный метод создания замыканий с множественными состояниями чем способ с вышеприведённым счётчиком, основанном на \verb"alet", окружающем \verb"alambda". Вот расширение изнанки в случае с инвертируемым \verb"alambda" счётчиком:

\begin{verbatim}
* (macroexpand
'(alambda (n)
(if (eq n 'invert)
(setq this
(lambda (n)
(if (eq n 'invert)
(setq this #'self)
(decf acc n))))
(incf acc n))))

(LABELS ((SELF (N)
(IF (EQ N 'INVERT)
(SETQ THIS
(LAMBDA (N)
(IF (EQ N 'INVERT)
(SETQ THIS #'SELF)
(DECF ACC N))))
(INCF ACC N))))
#'SELF)
\end{verbatim}

Если мы выполним маленький рефакторинг вышеприведённого расширения с учётом того, что \verb"labels" позволяет нам создавать множественные привязки функций\footnote{Используется множественность labels.}, то получится следующее:



\begin{verbatim}
(alet ((acc 0))
(labels ((going-up (n)
(if (eq n 'invert)
(setq this #'going-down)
(incf acc n)))
(going-down (n)
(if (eq n 'invert)
(setq this #'going-up)
(incf acc (- n)))))
#'going-up))
\end{verbatim}

\begin{figure}Листинг 6.6: ALET-FSM\label{listing_6.6}
\listbegin
\begin{verbatim}
(defmacro alet-fsm (&rest states)
`(macrolet ((state (s)
`(setq this #',s)))
(labels (,@states) #',(caar states))))
\end{verbatim}
\listend
\end{figure}

Здесь нужно учесть что \verb"alambda" может сделать доступными все тела специальной формы \verb"labels" для всех функций. И что ещё более важно, теперь у нас есть довольно неплохой шаблон для нашего событийного макроса.

\verb"Alet-fsm" даёт нам возможность использовать удобный синтаксис для выражения нескольких возможных \emph{состояний (states)} для нашего замыкания. Это очень тонкий слой сахара из макросов поверх \verb"labels", скомбинированный с \emph{проходом-по-коду} \verb"macrolet" трансформации, позволяющей нам сымитировать функцию \verb"state", изменяющую текущее состояние замыкания через анафору \verb"this" предоставляемую \verb"alet"-ом. В качестве примера приведена более чистая версия счётчика с изменяемым направлением роста:

\begin{verbatim}
(alet ((acc 0))
(alet-fsm
(going-up (n)
(if (eq n 'invert)
(state going-down)
(incf acc n)))
(going-down (n)
(if (eq n 'invert)
(state going-up)
(decf acc n)))))
\end{verbatim}

\verb"Alet-fsm" представляет экземпляр техники, которую мы ещё не видели: \emph{инъекция анафоры (anaphor injection)}. Использование этой анафоры нарушает лексическую прозрачность многими способами, что так или иначе, становится \emph{лексически невидимым (lexically invisible)}. Кроме невидимой привязки \verb"this" \verb"alet"-ом, также невидимым является использование \verb"this" макросом \verb"alet-fsm". \verb"Alet-fsm" инъецирует свободную переменную в наш лексический контекст так, что мы не можем её увидеть.

В данном случае стилистические проблемы не строго очерчены\footnote{Как и все стилистические вопросы. Если вы что-либо поймёте в полном объёме, то вопросы стиля становятся неуместными. Инъекция свободной переменной понята не до конца.}, поскольку программирование макросов это конечно не вопрос стиля. Это вопрос мощи. Иногда инъекция свободной переменной может создавать симбиоз между двумя макросами - вместе они смогут создать расширение с более лучшей программной конструкцией чем два изолированных расширения. Поскольку этот тип макро программирования сложен, то опять можно провести параллели с указателями C. Как изучение указателей C порождает сомнительные стилистические приёмы, также происходит и с инъекцией свободной переменной.



Наиболее правдоподобная гипотеза объясняющая трудность понимания инъекции свободной переменной связана с вопросом \emph{отказобезопасного} поведения\footnote{Здесь под понятием безопасности, в отличие от реального мира, понимается максимально быстрый и громкий отказ.}. С анафорой, в случае когда код переданный пользователем не использует привязку, возможно дальнейшее функционирование кода. Но, есть вероятность, что такой код может отказать без каких-либо предупреждений, а это небезопасно. Однако, когда вы вставите свободную переменную и нет окружения в котором эта переменная может быть захвачена, то всё выражение будет свободным. При возникновении такой ситуации вам нужно решить что делать до того, как вы будете вычислять это выражение. Оно может быть отказобезопасным.



Отставим в сторону стиль. Иногда инъекция свободной переменной - это то, что нам нужно для того, чтобы создать коммуникацию между двумя связанными макросами. Инъекция выполняет то же, что и анафора, но в другом направлении. Поскольку вы открываете новый канал коммуникации между вашими макросами, то проблемы сложности масштабируются очень быстро. Рассмотрим нахождение в доме полном хрупкого стекла. Вы можете безопасно швырять предметы в людей снаружи дома, даже если они не озаботятся их ловлей, но, вам лучше убедиться что вы сможете поймать любой объект брошенный в вас.

\section{Косвенные Цепи}\label{section_indirection_chains}



\begin{figure}Листинг 6.7: ICHAIN-BEFORE\label{listing_6.7}
\listbegin
\begin{verbatim}
(defmacro! ichain-before (&rest body)
`(let ((,g!indir-env this))
(setq this
(lambda (&rest ,g!temp-args)
,@body
(apply ,g!indir-env
,g!temp-args)))))
\end{verbatim}
\listend
\end{figure}

Существуют много способов с помощью которых мы можем извлечь пользу из анафоры \verb"this", предоставляемой макросом \verb"alet". Поскольку доступ к окружению осуществляется через замыкание-пустышку, перенаправляющее все вызовы к настоящему замыканию, на которое указывает \verb"this", то мы можем где угодно передавать ссылку на замыкание-пустышку копируя его так часто, сколько нам это будет нужно. Удобство подобной \emph{косвенности} в том, что мы можем менять происходящие события при вызове замыкания-пустышки без изменения ссылок на само замыкание-пустышку.

\verb"Ichain-before" предназначен для расширения в форме \verb"alet". Этот макрос добавляет исполнение нового кода до вызова главного замыкания. Вернёмся к нашему примеру со счётчиком, \verb"ichain-before" позволяет нам добавить новое замыкание, которое печатает предыдущее значение переменной \verb"acc" до того как это значение будет увеличено:

\begin{verbatim}
* (alet ((acc 0))
(ichain-before
(format t "Changing from ~a~%" acc))
(lambda (n)
(incf acc n)))

#<Interpreted Function>
\end{verbatim}

Результат такой, какой и ожидался:

\begin{verbatim}
* (funcall * 2)
Changing from 0
2
* (funcall ** 2)
Changing from 2
4
\end{verbatim}

Есть причина по которой в названии \verb"ichain-before" содержится упоминание цепи (chain). Мы можем вставить сколько угодно исполняемых замыканий:

\begin{verbatim}
* (alet ((acc 0))
(ichain-before
(format t "A~%"))
(ichain-before
(format t "B~%"))
(ichain-before
(format t "C~%"))
(lambda (n)
(incf acc n)))

#<Interpreted Function>
\end{verbatim}

Каждое новое звено будет добавляться в начало цепи, в результате появление звеньев цепи будет происходить в обратном порядке:

\begin{verbatim}
* (funcall * 2)
C
B
A
2
\end{verbatim}

Иногда статическое добавление косвенных цепей оказывается полезным для того, чтобы избежать реструктуризацию макросов просто добавив вместо этого новый окружающий код. Но наиболее интересные возможности косвенных цепей возникают при их динамическом добавлении. Поскольку мы можем создавать новые функции во время исполнения, а также можем получать доступ ко внутренностям замыкания через анафору, то мы можем переписать работу функций во время исполнения. Ниже представлен простой пример в котором каждый вызов замыкания добавляет код, печатающий "Hello world" при запуске:

\begin{verbatim}
* (alet ((acc 0))
(lambda (n)
(ichain-before
(format t "Hello world~%"))
(incf acc n)))

#<Interpreted Function>
\end{verbatim}

Каждый вызов добавляет новое замыкание к косвенной цепи:

\begin{verbatim}
* (loop for i from 1 to 4
do
(format t "~:r invocation:~%" i)
(funcall * i))
first invocation:
second invocation:
Hello world
third invocation:
Hello world
Hello world
fourth invocation:
Hello world
Hello world
Hello world
\end{verbatim}

Макрос \verb"ichain-after" подобен макросу \verb"ichain-before" за исключением того, что он добавляет замыкания в другой конец исполняемой цепи: после вызова главного замыкания. \verb"Ichain-after" использует \verb"prog1", который последовательно исполняет переданные формы и затем возвращает результат вычисления первой формы.

\verb"Ichain-before" и \verb"ichain-after" могут комбинироваться, пример:

\begin{verbatim}
* (alet ((acc 0))
(ichain-before
(format t "Changing from ~a~%" acc))
(ichain-after
(format t "Changed to ~a~%" acc))
(lambda (n)
(incf acc n)))

#<Interpreted Function>
* (funcall * 7)
Changing from 0
Changed to 7
7
\end{verbatim}

\begin{figure}Листинг 6.8: ICHAIN-AFTER\label{listing_6.8}
\listbegin
\begin{verbatim}
(defmacro! ichain-after (&rest body)
`(let ((,g!indir-env this))
(setq this
(lambda (&rest ,g!temp-args)
(prog1
(apply ,g!indir-env
,g!temp-args)
,@body)))))
\end{verbatim}
\listend
\end{figure}

\verb"Ichain-before" и \verb"ichain-after" - это макросы, которые инъецируют свободные переменные в свои расширения. Они инъецируют символ \verb"this", который предназначен для захвата расширением макроса \verb"alet". Такая разновидность инъекции символов может показаться плохим стилем программирования, который способен порождать ошибки, но на самом деле - это общая техника макросов. На деле почти все макросы инъецируют символы в расширение. К примеру: помимо \verb"this", макрос \verb"ichain-before" также инъецируют такие символы как \verb"let", \verb"setq" и \verb"lambda" предназначенные для сращивания с окружением, в котором расширяется макрос. Разница между такими символами как \verb"this" и такими предварительно определёнными символами как \verb"setq" в том, что \verb"lambda" всегда ссылается к единственному хорошо описанному ANSI макросу, а такие символы как \verb"this" могут ссылаться к различным объектам в зависимости от сред, в которых они были расширены.

\begin{figure}Листинг 6.9: ICHAIN-INTERCEPT-1\label{listing_6.9}
\listbegin
\begin{verbatim}
(defmacro! ichain-intercept% (&rest body)
`(let ((,g!indir-env this))
(setq this
(lambda (&rest ,g!temp-args)
(block intercept
(prog1
(apply ,g!indir-env
,g!temp-args)
,@body))))))
\end{verbatim}
\listend
\end{figure}

\verb"Ichain-before" и \verb"ichain-after" полезны для того, чтобы метить код, выполняемый до или после исполнения исходного перекрытого выражения. Но это ни в коем случае не единственная операция, которую мы можем выполнять с помощью анафоры \verb"this". Другой распространённой операцией является проверка данных замыкания после вызова замыкания.

\verb"Ichain-intercept%" - это другой макрос, предназначенный для использования внутри формы \verb"alet". Идея заключается в том, что мы хотим перехватывать вызовы замыкания и проверять результаты действия замыкания с целью предотвращения некорректных состояний в замыкании.

Так мы можем добавить перехват в наше обычное замыкание - счётчик:

\begin{verbatim}
* (alet ((acc 0))
(ichain-intercept%
(when (< acc 0)
(format t "Acc went negative~%")
(setq acc 0)
(return-from intercept acc)))
(lambda (n)
(incf acc n)))

#<Interpreted Function>
\end{verbatim}

Код, установленный при помощи \verb"ichain-intercept%", предупредит нас о падении значения счётчика ниже 0:

\begin{verbatim}
* (funcall * -8)
Acc went negative
0
\end{verbatim}

\begin{figure}Листинг 6.10: ICHAIN-INTERCEPT\label{listing_6.10}
\listbegin
\begin{verbatim}
(defmacro! ichain-intercept (&rest body)
`(let ((,g!indir-env this))
(setq this
(lambda (&rest ,g!temp-args)
(block ,g!intercept
(macrolet ((intercept (v)
`(return-from
,',g!intercept
,v)))
(prog1
(apply ,g!indir-env
,g!temp-args)
,@body)))))))
\end{verbatim}
\listend
\end{figure}

Счётчик будет сброшен в 0:

\begin{verbatim}
* (funcall ** 3)

3
\end{verbatim}

Наиболее интересным моментом в \verb"ichain-intercept%" является введение \emph{блокирующей анафоры (block anaphor)} под названием \verb"intercept". Для использования этой анафоры мы применяем \verb"return-from". Блок будет возвращать это значение из вызова замыкания перехватывая исходное значение.

Вместо захвата блокирующей анафоры \verb"intercept", \verb"ichain-intercept" создаёт локальный макрос, позволяющий коду внутри \verb"ichain-intercept" использовать \verb"intercept" для расширения в \verb"return-from" где блок определён как \verb"gensym".

\begin{verbatim}
* (alet ((acc 0))
(ichain-intercept
(when (< acc 0)
(format t "Acc went negative~%")
(setq acc 0)
(intercept acc)))
(lambda (n)
(incf acc n)))

#<Interpreted Function>
\end{verbatim}

Результат тот же, что и в \verb"ichain-intercept%":

\begin{verbatim}
* (funcall * -8)
Acc went negative
0
* (funcall ** 3)

3
\end{verbatim}

Конечно, прозрачное введение всех этих замыканий в операции может сказаться на производительности во время выполнения. К счастью, современные лисп компиляторы очень хорошо оптимизируют замыкания. Если ваше приложение может разыменовывать несколько указателей - а часто оно это может - косвенные цепи могут быть лучшим способом для их структуризации. Смотрите раздел Область Видимости Указателя, там описаны другой взгляд на косвенные цепи. Кроме того, рассмотрите CLOS-овскую функциональность до, после и вокруг.

\section{Замыкания, Поддерживающие Горячую Замену}\label{section_hotpatching_closures}


В этом разделе было запланировано три цели. Первая, было рассмотрено другое интересное использование анафоры \verb"this" из \verb"alet". Второе, обсудили шаблон \emph{alet, окружающий dlambda}. И наконец, введена полезная макро техника под названием \emph{закрытие анафоры}.

Для того, чтобы ясно проиллюстрировать закрытие анафоры мы не будем работать с макросом \verb"alet" и переключимся на изнанку расширения. \verb"Alet-hotpatch%" - это расширение \verb"alet" со специальной лямбда формой. Эта лямбда форма проверяет первый аргумент\footnote{Со сравнением указателя.} на соответствие с ключевым символом \verb":hotpatch" и при обнаружении этого символа заменяет косвенное замыкание на переданный аргумент.



\begin{figure}Листинг 6.11: ALET-HOTPATCH-1\label{listing_6.11}
\listbegin
\begin{verbatim}
(defmacro alet-hotpatch% (letargs &rest body)
`(let ((this) ,@letargs)
(setq this ,@(last body))
,@(butlast body)
(lambda (&rest args)
(if (eq (car args) ':hotpatch)
(setq this (cadr args))
(apply this args)))))
\end{verbatim}
\listend
\end{figure}

Возможность замены замыкания использованного в другом выполняющемся замыкании во время работы программы называется \emph{горячей заменой (hotpatching)}. Например, мы создали замыкание с поддержкой горячей замены и, для дальнейшего применения, сохранили его в ячейку символа-функции символа \verb"hotpatch-test":

\begin{verbatim}
* (setf (symbol-function 'hotpatch-test)
(alet-hotpatch% ((acc 0))
(lambda (n)
(incf acc n))))

#<Interpreted Function>
\end{verbatim}

Возможное применение:

\begin{verbatim}
* (hotpatch-test 3)

3
* (hotpatch-test 4)

7
\end{verbatim}

Мы можем заменить лямбда форму - вместе со связанной с ней средой - вызвав это замыкание с символом \verb":hotpatch" и заменяющей функцией или замыканием:

\begin{verbatim}
* (hotpatch-test
:hotpatch
(let ((acc 0))
(lambda (n)
(incf acc (* 2 n)))))

#<Interpreted Function>
\end{verbatim}

\begin{figure}Листинг 6.12: ALET-HOTPATCH\label{listing_6.12}
\listbegin
\begin{verbatim}
(defmacro alet-hotpatch (letargs &rest body)
`(let ((this) ,@letargs)
(setq this ,@(last body))
,@(butlast body)
(dlambda
(:hotpatch (closure)
(setq this closure))
(t (&rest args)
(apply this args)))))
\end{verbatim}
\listend
\end{figure}

Теперь замыкание обладает новым, исправленным на лету поведением:

\begin{verbatim}
* (hotpatch-test 2)

4
* (hotpatch-test 5)

14
\end{verbatim}

Заметьте как значение счётчика сбросилось в 0 после горячей замены среды замыкания на новое значение для аккумулятора счётчика \verb"acc".

Кажется мы уже видели такую разновидность \emph{деструктуризации во время исполнения}, основанную на символах ключевых слов? Да, на деле мы написали макрос выполняющий то же самое что и в \emph{разделе Dlambda}. \verb"Alet-hotpatch" - это версия \verb"alet-hotpatch%" основанный на \verb"dlambda". Иногда, даже не осознавая этого, при написании новых макросов мы применяем \emph{комбинирование макросов (macro combination)}. У хорошо спроектированного макроса расширение полностью понятно и хотя возможны разнообразные нарушения лексической прозрачности, проблем с комбинированием не возникает, поскольку все компоненты подходят друг к другу.

\begin{figure}Листинг 6.13: LET-HOTPATCH\label{listing_6.13}
\listbegin
\begin{verbatim}
(defmacro! let-hotpatch (letargs &rest body)
`(let ((,g!this) ,@letargs)
(setq ,g!this ,@(last body))
,@(butlast body)
(dlambda
(:hotpatch (closure)
(setq ,g!this closure))
(t (&rest args)
(apply ,g!this args)))))
\end{verbatim}
\listend
\end{figure}

\verb"Alet-hotpatch" создаёт замыкание с поддержкой горячей замены, но в этом макросе есть один концептуальный недостаток. Поскольку макрос \verb"alet-hotpatch" используется для создания замыканий с горячей заменой, то мы можем забыть что этот макрос вводит анафору \verb"this" в область видимости переданных форм. Если мы забудем о созданной анафоре, то мы рискуем столкнуться с проблемой нежелательного захвата переменной. Для того, чтобы избежать подобных проблем, мы должны применить технику известную как \emph{закрытие анафоры (anaphor closing)}. При закрытии анафоры мы не меняем способ функционирования анафорического макроса, а просто запрещаем некоторые способы комбинирования этого макроса.

Поскольку мы вывернули расширение \verb"alet" наизнанку, то мы можем лексически увидеть создание анафоры \verb"this" в определении макроса \verb"alet-hotpatch". И поскольку \verb"alet-hotpatch" также содержит код, использующий анафору \verb"this" для реализации горячей замены, то мы можем закрыть анафору так, что символ \verb"this" больше не будет захватываться макросом. Каким стандартным способом мы избегаем введения нежелательных привязок? Конечно мы именуем привязки с помощью \verb"gensym"-ов.

\verb"Let-hotpatch" - это пример закрытия анафоры \verb"this" в более замкнутую версию - более безопасная версия после реализации всех необходимых нам горячих замен. ``\verb"A"'', удалённое из названия макроса, обозначает что этот новый макрос больше не вносит анафору в переданный код. Конечно если нам необходимо по некоторым причинам, отличающимся от простой горячей замены, сослаться на \verb"this", то мы должны оставить анафору открытой.

Техника открытия и закрытия анафоры становится второй натурой программиста после того, как он напишет достаточное количество подобных макросов. Также, как мы можем писать макросы, инъецирующие свободные переменные в расширение не задумываясь о том как мы будем их захватывать пока мы пишем лексический контекст в котором они будут расширяться, мы иногда оставляем открытым анафору при разработке макроса для экспериментирования с комбинациями анафорических макросов и инъекции свободных переменных. После того, как будут найдены наиболее полезные комбинации, мы можем произвести слияние макросов и заменить все использованные во время разработки анафоры на \verb"gensym"-ы. Также, как это делает \verb"let-hotpatch", эта техника может использовать \verb"defmacro!" для перемещения области видимости анафоры с макро расширения в макро определение. Вместо лексического введения анафоры мы ввели другой тип анафоры - такой, который не может работать в целой лексической области видимости расширения, но работает только в другой, более ограниченной области видимости. Эта область видимости будет описываться в следующем разделе.

\section{Суб-Лексическая Область Видимости}\label{section_sub-lexical_scope}


Наш макро-определяющий макрос \verb"defmacro!" определённый в \emph{разделе Нежелательный Захват} ищет присутствие автоматических \verb"gensym"-ов в переданном коде с помощью утилиты Грэма \verb"flatten". А теперь пришло время признаться в маленькой лжи. До сих пор, пока мы не рассмотрели инъекцию свободной переменной и анафору, мы считали что символьные G-bang имена в \verb"defmacro!" определениях применимы в лексической области видимости макро определения. На самом деле это не правда - \verb"defmacro!" предоставляет эти привязки под несколько отличающимся типом области видимости которая называется \emph{суб-лексической областью видимости (sub-lexical scope)}.

Помните, что область видимости обозначает корректность ссылок на переменную, а лексическая область видимости означает что имя применимо к коду в текстовом теле таких создающих привязки конструкций, как \verb"let". Важное различие между лексической областью видимости и суб-лексической областью видимости в том, что лексическая область видимости включает в себя все макрорасширения кода в теле \verb"let". Таким образом, высказывание о том, что лексическая область видимости - это создание переменных, доступных только из кода в текстовом теле создающих привязки конструкций является ложным - макросы могут \emph{инъецировать} ссылки на переменные. Такие переменные инъецируются извне текстового тела конструкций, создающих привязки.

Реализация уникальной текстовой области видимости с ограничением на возможные способы доступа к лексическим переменным равняется суб-лексической области видимости. Ссылки на переменные в суб-лексической области видимости действительны только если представляющие их символы присутствуют в сырых списках, переданных лиспу до макро-расширения.

Поскольку \verb"defmacro!" производит предварительную обработку полученного кода и создаёт списки всех G-bang символов до расширения кода, то отсюда следует что G-bang символы суб-лексически привязаны. Мы не можем написать макросы, инъецирующие G-bang символы в \verb"defmacro!" поскольку лексические привязки для G-bang символов никогда не создавались. Вот типичное применение суб-лексического G-bang символа:

\begin{verbatim}
* (defmacro! junk ()
`(let ((,g!var))
,g!var))

JUNK
\end{verbatim}

Оба G-bang символа были созданы в суб-лексической области видимости \verb"defmacro!" таким образом, расширение будет таким, каким мы его ожидали увидеть:

\begin{verbatim}
* (macroexpand '(junk))

(LET ()
(LET ((#:VAR1663))
#:VAR1663))
T
\end{verbatim}

Однако, для того, чтобы изучить концепцию суб-лексической области видимости мы определим макрос, инъецирующий G-bang символ:

\begin{verbatim}
* (defmacro injector-for-g!var ()
''g!var)

INJECTOR-FOR-G!VAR
\end{verbatim}

Теперь мы можем написать \verb"junk2". \verb"Junk2" идентичен \verb"junk" с тем исключением, что мы заменили наши G-bang символы макросом, который расширяется в G-bang символ:

\begin{verbatim}
* (defmacro! junk2 ()
`(let ((,(injector-for-g!var)))
,(injector-for-g!var)))

JUNK2
\end{verbatim}

Но поскольку G-band символы привязаны суб-лексически - и поэтому не ищутся в макро расширениях форм - то \verb"defmacro!" не конвертирует символы в автоматические \verb"gensym"-ы:

\begin{verbatim}
* (macroexpand '(junk2))

(LET ()
(LET ((G!VAR))
G!VAR))
T
\end{verbatim}

И хотя вышеприведённый код по-прежнему функционален, указатели на переменные, находящиеся в суб-лексической области видимости могут вывести из строя выражения, в которых некоторые указатели ссылаются на переменные существующие в суб-лексической области видимости а другие - нет:

\begin{verbatim}
* (defmacro! junk3 ()
`(let ((,g!var))
,(injector-for-g!var)))

JUNK3
* (macroexpand '(junk3))

(LET ()
(LET ((#:VAR1672))
G!VAR))
T
\end{verbatim}

Суб-лексическая область видимости удивительно часто появляется в сложных макросах. Кроме \verb"defmacro!" можно привести по крайней мере один пример: макрос \verb"with-all-cxrs" из \emph{раздела Рекурсивные Решения} суб-лексически привязывает функции получения элементов списка. В результате работы суб-лексических привязок оказывается что к подобным привязкам невозможно сослаться из макро расширения. Иногда подобное ограничение полезно, иногда нет. В случае с \verb"with-all-cxrs" суб-лексичность может рассматриваться как нежелательный эффект. Когда наш метдод получения доступа к элементу списка находится в суб-лексической области видимости \verb"with-all-cxrs" то проблем не возникает:

\begin{verbatim}
* (with-all-cxrs
(cadadadr nil))

NIL
\end{verbatim}

Кроме этого мы можем даже написать макросы, расширяющиеся в эти методы получения доступа, поскольку макро определения находятся в суб-лексической области видимости \verb"with-all-cxrs":

\begin{verbatim}
* (with-all-cxrs
(macrolet ((accessor (l)
`(cadadadr ,l)))
(accessor nil)))

NIL
\end{verbatim}

Но, помните, что что \verb"with-all-cxrs" привязывает функции получения доступа суб-лексически, поэтому мы не можем инъецировать макрос, в функцию получения доступа:

\begin{verbatim}
* (macrolet ((accessor (l)
`(cadadadr ,l)))
(with-all-cxrs
(accessor nil)))

This function is undefined: CADADADR
\end{verbatim}

Теперь, когда мы знакомы с понятием \emph{анафор} и увидели большое количество примеров сложных макросов - включая и те, которые используют суб-лексическую область видимости - мы можем обсудить интересный теоретический макрос: \verb"sublet". Этот макрос создаёт суб-лексические привязки кода, используя синтаксис, подобный синтаксису обычной \verb"let" формы. Обсуждение \verb"sublet" мы начнём также, как и обсуждения многих лисп макросов - с утилиты.

\begin{figure}Листинг 6.14: LET-BINDING-TRANSFORM\label{listing_6.14}
\listbegin
\begin{verbatim}
(defun let-binding-transform (bs)
(if bs
(cons
(cond ((symbolp (car bs))
(list (car bs)))
((consp (car bs))
(car bs))
(t
(error "Bad let bindings")))
(let-binding-transform (cdr bs)))))
\end{verbatim}
\listend
\end{figure}

\verb"Let-binding-transform" - это простая утилита, обрабатывающая случай когда \verb"let" форма привязывает единственный символ. В следующем примере \verb"a" нормализуется до \verb"(a)":

\begin{verbatim}
* (let-binding-transform
'(a (b) (c nil)))

((A) (B) (C NIL))
\end{verbatim}

Кроме того, \verb"sublet" использует утилиту \verb"tree-leaves" определённую нами в \emph{разделе Неявные Контексты}. Напомним, что макрос \verb"tree-leaves" получает три аргумента: произвольную списковую структуру, выражение, которое может использовать переменную \verb"x" для определения изменяемого листа и другое выражение, которое может использовать другую \verb"x" и определяющее на что должны быть изменены нужные листья.

Выбрав неявственность привязок \verb"x" с одним и тем же именем мы получили преимущества \emph{дуализма синтаксиса}. Если у нас не получается обычными способами выделить общий код в выражении, то иногда мы можем добиться сокращения кода воспользовавшись синтаксическим дуализмом. Определение \verb"sublet" использует считывающий макрос ссылающийся сам на себя, эти макросы описаны в \emph{разделе Циклические Выражения}. Особенно для таких концепций как функции получения доступа к элементам списка, которые могут меняться много раз в процессе написания кода, считывающие макросы позволяют нам работать только с одним-единственным отображением оператора получения доступа к элементу списка. Благодаря использованию \emph{неявственности (implicitisation)} с макросом \verb"tree-leaves", легко найти и понять дублирование кода.

\begin{figure}Листинг 6.15: SUBLET\label{listing_6.15}
\listbegin
\begin{verbatim}
(defmacro sublet (bindings% &rest body)
(let ((bindings (let-binding-transform
bindings%)))
(setq bindings
(mapcar
(lambda (x)
(cons (gensym (symbol-name (car x))) x))
bindings))
`(let (,@(mapcar #'list
(mapcar #'car bindings)
(mapcar #'caddr bindings)))
,@(tree-leaves
body
#1=(member x bindings :key #'cadr)
(caar #1#)))))
\end{verbatim}
\listend
\end{figure}

\verb"Sublet" получает форму, представляющую \verb"let" привязки и применяет нашу утилиту \verb"let-binding-transform", генерирующую в процессе новую списковую структуру. Далее происходит присоединение\footnote{Присоединяются, а не добавляются, поскольку в этом случае мы можем продолжать поддерживать привязки без значений по умолчанию, например \verb"(a)".} \verb"gensym"-а к каждой привязке с печатью соответствующего имени для имени привязки. \verb"Sublet" расширяется в \verb"let" форму, привязывающую \verb"gensym" символы к значениям, переданным в привязываемой форме, затем применяется \verb"tree-leaves" для замещения всех вхождений имён символов привязок в переданном коде на их соответствующие \verb"gensym"-ы. \verb"Sublet" не раскрывает никаких макросов и не разбирает никаких специальных форм в теле на предмет поиска вхождений этих имён символов привязок поскольку \verb"sublet" создаёт суб-лексические привязки. Например, если все ссылки на \verb"a" являются суб-лексическими, то они будут замещены на \verb"gensym"-ы:



\begin{verbatim}
* (macroexpand
'(sublet ((a 0))
(list a)))

(LET ((#:A1657 0))
(LIST #:A1657))
T
\end{verbatim}

Однако, поскольку суб-лексическая область видимости не предполагает расширения макросов, и само собой разумеется отсутствие интерпретации таких специальных форм как \verb"quote", то экземпляры символа \verb"a" не являющиеся ссылками на переменную также будут меняться:

\begin{verbatim}
* (macroexpand
'(sublet ((a 0))
(list 'a)))

(LET ((#:A1658 0))
(LIST '#:A1658))
T
\end{verbatim}

Суб-лексическая область видимости вступает в силу до того как списковая структура будет интерпретирована как лисп код вашим системным проходчиком-по-коду. Это важное наблюдение - поскольку не все последствия этого наблюдения исследованы до конца. Интерпретация кода \verb"sublet"-ом отличается от интерпретации проходчика-по-коду, осуществляемого COMMON LISP-ом.

Теперь мы стоим на одной из многих граней понимания макросов. Сколько разновидностей интересных типов областей видимости лежит между нераскрытой суб-лексической областью видимости и полностью раскрытой лексической областью видимости? Поскольку более лучшего названия я не подобрал, то мы будем называть эту бесконечно большую категорию областей видимости \emph{супер суб-лексическими областями видимости (super sub-lexical scopes)}\footnote{Я дал это глупое название по тому что ожидаю что по мере изучения этой концепции появятся более лучшие имена, глубже отображающие суть явления.}.



Весьма очевидно, что супер суб-лексическая область видимости использует \verb"sublet*". Этот макрос основан на \verb"sublet" но изменяет каждую форму в теле осуществляя макрорасширение этих форм с помощью функции \verb"macroexpand-1". Теперь вместо появления в сырой списковой структуре ссылки на символы должны появляться после первого шага макро расширения. Этот тип супер суб-лексической области видимости позволяет макросам инъецировать или удалять ссылки из области видимости внутри тела \verb"let" формы. Если макросы не выполняют эти операции - или если формы вовсе не являются макросами - то этот тип супер суб-лексической области видимости работает также, как и суб-лексическая область видимости:

\begin{figure}Листинг 6.16: SUBLET*\label{listing_6.16}
\listbegin
\begin{verbatim}
(defmacro sublet* (bindings &rest body)
`(sublet ,bindings
,@(mapcar #'macroexpand-1 body)))

* (macroexpand
'(sublet* ((a 0))
(list a)))

(LET ((#:A1659 0))
(LIST #:A1659))
T
\end{verbatim}
\listend
\end{figure}

Но мы можем определить другой макрос - инъектор для проверки этой супер суб-лексической области видимости:

\begin{verbatim}* (defmacro injector-for-a ()
'a)

INJECTOR-FOR-A
\end{verbatim}

\verb"Sublet*" раскроет этот макрос - инъектор:

\begin{verbatim}
* (macroexpand-1
'(sublet* ((a 0))
(injector-for-a)))

(SUBLET ((A 0))
A)
T
\end{verbatim}

Что в свою очередь будет суб-лексически интерпретироваться \verb"sublet"-ом, обозначая присутствие инъецированной переменной внутри супер суб-лексической области видимости предоставляемой \verb"sublet*"-ом:

\begin{verbatim}
* (macroexpand-1 *)

(LET ((#:A1663 0))
#:A1663)
\end{verbatim}

Но вложенные макросы в выражении не раскрываются через \textbf{mac\-ro\-ex\-pand-1} поэтому \verb"sublet*" не вставляет их в суб-лексическую область видимости \verb"sublet":

\begin{verbatim}
* (macroexpand-1
'(sublet* ((a 0))
(list (injector-for-a))))

(SUBLET ((A 0))
(LIST (INJECTOR-FOR-A)))
T
\end{verbatim}

Поэтому \verb"a" не захватывается суб-лексически\footnote{\verb"Walker:macroexpand-all" - это компонент CMUCL и представляет собой завершённый проходчик-по-коду.}:



\begin{verbatim}
* (walker:macroexpand-all *)

(LET ((#:A1666 0))
(LIST A))
\end{verbatim}

С помощью \verb"sublet" и \verb"sublet*" мы можем, используя суб-лексические или супер суб-лексические области видимости, произвольно контролировать на каком уровне макро расширения переменная \verb"a" будет рассматриваться как корректная. Как замечено выше супер суб-лексическая область видимости это почти полностью не исследованный бесконечный класс областей видимости. Способов прохода по коду - большое множество, существует такое же количество множеств супер суб-лексических областей видимости. Этот класс областей видимости подводит нас к другой категории почти неисследованных макросов: макросы, изменяющие работу лисп макросов. Эти макросы способны определять когда следует раскрывать макрос, где ссылки на переменные являются корректными, как интерпретировать специальные формы и т.д. То есть, мы получаем макро-программируемый раскрыватель макросов.
