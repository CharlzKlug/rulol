\chapter{Анафорические Макросы}\label{chapter_anaphoric_macros}
\section{Больше Фор?}\label{section_more_phors?}


\emph{Анафорические макросы (Anaphoric macros)} - это одни из наиболее интересных макросов из книги Пола Грэма \emph{On Lisp}. Анафорический макрос - это макрос осуществляющий преднамеренный захват переменной из форм, переданных в макрос. Благодаря наличию \emph{прозрачных спецификаций (transparent specifications)} эти преднамеренно захваченные переменные порождают окна, позволяющие осуществлять контроль над расширением макроса. Через эти окна мы можем манипулировать расширением с помощью \emph{комбинаций (combinations)}.

Классическая анафора, такая как в On Lisp, названа также, как и дословное\footnote{Цитирование U-Языка.} \emph{анафор (anaphor)} и во множественном числе, \emph{анафора (ana\-pho\-ra)}. Анафор обозначает захват \emph{свободного слова U-Языка (free U-Language word)} для использования в последующем U-Языке. В терминах программирования, реализация классической анафоры означает нахождение места в вашем коде - или в коде, который вы хотите написать - где выражения могли бы извлечь выгоду, будучи способными сослаться на результаты предыдущих, связанных выражений. Настоятельно рекомендуется к изучению анафора Грэма и код, связанный с этой анафорой. Особенно обратите внимание на макрос \verb"defanaph" [ON-LISP-P223], позволяющий использовать некоторые интересные разновидности программирования \emph{автоматических анафор (automatic anaphor)}.



По истечении некоторого периода было обнаружено, что \verb"alambda" - это наиболее полезный анафорический макрос в \emph{On Lisp}. К тому же \verb"alambda" - это один из наиболее простых и элегантных примеров, демонстрирующих анафорический макрос и преднамеренный захват переменной.

\begin{figure}Листинг 6.1: ALAMBDA\label{listing_6.1}
\listbegin
\begin{verbatim}
;; alambda Грэма
(defmacro alambda (parms &body body)
`(labels ((self ,parms ,@body))
#'self))
\end{verbatim}
\listend
\end{figure}

С \verb"alambda" мы захватываем имя \verb"self", таким образом, мы можем использовать его для построения очень анонимной функции. Другими словами рекурсия становится такой же простой как и вызов \verb"self". Например, следующая функция возвращает список\footnote{Если условие возвращает ложное значение, то отсутствующий третий элемент \verb"if" формы вернёт \verb"nil", что в свою очередь является списком.} чисел с \verb"n" до \verb"1":


\begin{verbatim}
(alambda (n)
(if (> n 0)
(cons
n
(self (- n 1)))))
\end{verbatim}

\verb"Alambda" делает наш код более интуитивным и простым для чтения, позволяя нам думать об анонимных функциях как о функциях способных вызывать саму себя с той же лёгкостью, как и добавление единственной буквы\footnote{Это другая причина не шарп-закавычивать лямбда формы. Изменение шарп-закавыченных лямбда форм в alambda формы также потребует удаления двух символов.}. Поскольку \verb"alambda" прозрачно специфицирован для \verb"self" привязки - и тот факт что единственная причина использования \verb"alambda" - это применение этой привязки - то нежелательный захват переменной уже не проблема.



Другой удобный анафорический макрос из \emph{On Lisp} - это \verb"aif", макрос, привязывающий результат проверки к \verb"it" при положительном (вторичном) случае для последующего применения\footnote{Упражнение: Почему ложный (третичный или альтернативный) вариант никогда не использует эту анафору?}. \verb"Aif" использует удобную COMMON LISP особенность: \emph{обобщённые булевы значения (generalised booleans)}. В COMMON LISP, все не-\verb"nil" значения являются истинными значениями, поэтому COMMON LISP программисты обычно встраивают интересную информацию в истинные значения. Языки в которых зарезервированы истинные и ложные значения - в частности Scheme - используют \emph{явные булевы значения (explicit booleans)}, которые иногда заставляют вас выводить дополнительную информацию для удовлетворения конструкций с избыточным типом. В Scheme добавлен \emph{костыль (kludge)} для того, чтобы \verb"if", \verb"cond", \verb"and", \verb"or" и \verb"do" работали с не-булевыми\footnote{С помощью Scheme предиката \verb"boolean?".} значениями [R5RS-P25]. Конечно, COMMON LISP спроектирован правильно - всё является булевым значением.



\begin{figure}Листинг 6.2: AIF\label{listing_6.2}
\listbegin
\begin{verbatim}
;; aif Грэма
(defmacro aif (test then &optional else)
`(let ((it ,test))
(if it ,then ,else)))
\end{verbatim}
\listend
\end{figure}

Также следует отметить что \verb"aif" и \verb"alambda", как и все анафорические макросы, нарушают \emph{лексическую прозрачность}. Или иначе, выражаясь модными словами, можно сказать что они не \emph{гигиеничные (unhygienic)} макросы. Они, как и большое количество макросов в этой книге, вводят невидимые лексические привязки и поэтому не могут быть созданы в макро системах со строгим соблюдением гигиены. Даже большое количество Scheme систем, платформа в которой много экспериментировали с гигиеной, предоставляют макросы в негигиеничном defmacro стиле - возможно, по той причине, что даже разработчики Scheme не воспринимали всерьёз гигиену. Подобно обучению катания на велосипеде, гигиенические системы в своём большинстве игрушки, которые забрасывают после овладевания минимальным уровнем мастерства.

Да, существует много интересных вещей, которые мы можем делать с помощью преднамеренного захвата переменной. Существует множество фор (phors). Эта книга и книга Грэма \emph{On Lisp} описывает лишь малую часть возможностей, заложенных в эту технику. Из грамотного применения анафорических макросов можно извлечь много новых потрясающих изобретений.

После краткой беседы об анафорах, продемонстрированной считывающими макросами, остаток этой главы описывает узкое приложение анафор к одной из центральных тем этой книги: лексические замыкания - \emph{let, окружающий lambda}. Большая часть этой главы посвящена интересным анафорическим макросам, предназначенным для изменения, адаптации и расширении замыканий. И хотя данная тема очень удобна в практическом применение для написания кода, мы используем её как платформу для обсуждения возможностей и вариантов анафорических макросов. Применение макросов для расширения концепции замыканий - это, на данный момент, интенсивно исследуемая тема [FIRST-CLASS-EXTENTS] [OPENING-CLOSURES].

\section{Шарп-Обратное Закавычивание}\label{section_sharp-backquote} 

Хотя большинство анафор представлено в виде обычных макросов, у считывающих макросов тоже есть возможность использования кода, создающего для нас невидимые привязки. Такие считывающие макросы называются \emph{считывающими анафорами (read anaphora)}. Этот раздел ознакомит вас с таким макросом, который являясь весьма незатейливым, удивил даже меня и который стал одним из наиболее полезных макросов, используемых в этой книге. Я постарался как можно скорее перейти к этому макросу, поскольку он будет использоваться в оставшемся коде. Более того, несколько рассмотренных нами макросов уже используют его.

\begin{figure}Листинг 6.3: SHARP-BACKQUOTE\label{listing_6.3}
\listbegin
\begin{verbatim}
(defun |#`-reader| (stream sub-char numarg)
(declare (ignore sub-char))
(unless numarg (setq numarg 1))
`(lambda ,(loop for i from 1 to numarg
collect (symb 'a i))
,(funcall
(get-macro-character #\`) stream nil)))

(set-dispatch-macro-character
#\# #\` #'|#`-reader|)
\end{verbatim}
\listend
\end{figure}

Шарп-обратное закавычивание - это считывающий макрос, выполняющий считывание как лямбда форма. По умолчанию, эта лямбда форма получает только один аргумент: \verb"a1". Затем считывающий макрос рекурсивно вызывает функцию \verb"read" для переданного потока. Ниже есть пример с остановленным вычислением (с помощью \verb"quote"), и мы можем рассмотреть прозрачное введение считывающей анафоры\footnote{Конечно, префикс захваченного символа, ``\verb"a"'', расшифровывается анафорой.}:



\begin{verbatim}
* '#`((,a1))

(LAMBDA (A1)
`((,A1)))
\end{verbatim}

Этот считывающий макрос формирует абстракцию общего шаблона макроса. Например, если у нас есть список переменных и мы хотим создать список \verb"let" привязок, где каждая переменная привязана к символу, скажем, \verb"empty", то мы можем использовать \verb"mapcar" следующим способом:

\begin{verbatim}
* (mapcar (lambda (a)
(list a ''empty))
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

Но особенно для сложных списковых структур, такой подход может оказаться довольно грязным, поэтому лисп программисты предпочитают использовать обратное закавычивание для поднятия на один уровень закавычивания:

\begin{verbatim}
* (mapcar (lambda (a)
`(,a 'empty))
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

Наш новый считывающий макрос вводит анафору и скрывает лямбда форму:

\begin{verbatim}
* (mapcar #`(,a1 'empty)
'(var-a var-b var-c))

((VAR-A 'EMPTY)
(VAR-B 'EMPTY)
(VAR-C 'EMPTY))
\end{verbatim}

\verb"1" в символе \verb"a1" выше говорит о том, что пользователи считывающего макроса могут вводить переменное число анафор, зависящее от числа переданного в параметр \verb"numarg" считывающего макроса:

\begin{verbatim}
* '#2`(,a1 ,a2)

(LAMBDA (A1 A2)
`(,A1 ,A2))
\end{verbatim}

Таким образом мы можем одновременно за\verb"mapcar"-ить шарп-обратно закавыченные выражения с несколькими списками:

\begin{verbatim}
* (let ((vars '(var-a var-b var-c)))
(mapcar #2`(,a1 ',a2)
vars
(loop for v in vars
collect (gensym
(symbol-name v)))))

((VAR-A '#:VAR-A1731)
(VAR-B '#:VAR-B1732)
(VAR-C '#:VAR-C1733))
\end{verbatim}

Ещё один способ думать о шарп-обратном закавычивании: шарп - обратное закавычивание выполняет интерполяцию списка, также, как функция \verb"format" выполняет интерполяцию строки. \verb"Format" позволяет нам использовать шаблоны со слотами, заполняемыми значениями отдельных аргументов, аналогично шарп-обратное закавычивание позволяет нам отделить структуру интерполированного списка от значений, с которыми мы хотим их объединить. Благодаря ранее описанному \emph{дуализму синтаксиса} между лямбда формами в позиции функции в списке и лямбда формами, использующими макрос \verb"lambda" для расширения в функцию, мы также можем использовать шарп-обратное закавычивание в роли первого элемента при вызове функции:

\begin{verbatim}
* (#3`(((,a1)) ,@a2 (,a3))
(gensym)
'(a b c)
'hello)

(((#:G1734)) A B C (HELLO))
\end{verbatim}

В отличие от \verb"format" шарп-обратное закавычивание не использует последовательное позиционирование. Вместо этого используется числа для наших анафорических привязок. Вследствие этого порядок может перемешиваться и мы можем сращивать привязки более одного раза:

\begin{verbatim}
* (#3`(((,@a2)) ,a3 (,a1 ,a1))
(gensym)
'(a b c)
'hello)

(((A B C)) HELLO (#:G1735 #:G1735))
\end{verbatim}

Упражнение: Ссылки на \verb"gensym #:G1735" выглядят так, как будто ссылаются на один и тот-же символ, но, конечно, вы никогда не можете утверждать это глядя на напечатанные имена. Являются ли эти символы \verb"eq"-абельными? Обоснуйте ответ.

