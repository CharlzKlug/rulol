\chapter{Анафорические Макросы}\label{chapter_anaphoric_macros}
\section{Больше Фор?}\label{section_more_phors?}


\emph{Анафорические макросы (Anaphoric macros)} - это одни из наиболее интересных макросов из книги Пола Грэма \emph{On Lisp}. Анафорический макрос - это макрос осуществляющий преднамеренный захват переменной из форм, переданных в макрос. Благодаря наличию \emph{прозрачных спецификаций (transparent specifications)} эти преднамеренно захваченные переменные порождают окна, позволяющие осуществлять контроль над расширением макроса. Через эти окна мы можем манипулировать расширением с помощью \emph{комбинаций (combinations)}.

Классическая анафора, такая как в On Lisp, названа также, как и дословное\footnote{Цитирование U-Языка.} \emph{анафор (anaphor)} и во множественном числе, \emph{анафора (ana\-pho\-ra)}. Анафор обозначает захват \emph{свободного слова U-Языка (free U-Language word)} для использования в последующем U-Языке. В терминах программирования, реализация классической анафоры означает нахождение места в вашем коде - или в коде, который вы хотите написать - где выражения могли бы извлечь выгоду, будучи способными сослаться на результаты предыдущих, связанных выражений. Настоятельно рекомендуется к изучению анафора Грэма и код, связанный с этой анафорой. Особенно обратите внимание на макрос \verb"defanaph" [ON-LISP-P223], позволяющий использовать некоторые интересные разновидности программирования \emph{автоматических анафор (automatic anaphor)}.



По истечении некоторого периода было обнаружено, что \verb"alambda" - это наиболее полезный анафорический макрос в \emph{On Lisp}. К тому же \verb"alambda" - это один из наиболее простых и элегантных примеров, демонстрирующих анафорический макрос и преднамеренный захват переменной.

\begin{figure}Листинг 6.1: ALAMBDA\label{listing_6.1}
\listbegin
\begin{verbatim}
;; alambda Грэма
(defmacro alambda (parms &body body)
`(labels ((self ,parms ,@body))
#'self))
\end{verbatim}
\listend
\end{figure}

С \verb"alambda" мы захватываем имя \verb"self", таким образом, мы можем использовать его для построения очень анонимной функции. Другими словами рекурсия становится такой же простой как и вызов \verb"self". Например, следующая функция возвращает список\footnote{Если условие возвращает ложное значение, то отсутствующий третий элемент \verb"if" формы вернёт \verb"nil", что в свою очередь является списком.} чисел с \verb"n" до \verb"1":


\begin{verbatim}
(alambda (n)
(if (> n 0)
(cons
n
(self (- n 1)))))
\end{verbatim}

\verb"Alambda" делает наш код более интуитивным и простым для чтения, позволяя нам думать об анонимных функциях как о функциях способных вызывать саму себя с той же лёгкостью, как и добавление единственной буквы\footnote{Это другая причина не шарп-закавычивать лямбда формы. Изменение шарп-закавыченных лямбда форм в alambda формы также потребует удаления двух символов.}. Поскольку \verb"alambda" прозрачно специфицирован для \verb"self" привязки - и тот факт что единственная причина использования \verb"alambda" - это применение этой привязки - то нежелательный захват переменной уже не проблема.



Другой удобный анафорический макрос из \emph{On Lisp} - это \verb"aif", макрос, привязывающий результат проверки к \verb"it" при положительном (вторичном) случае для последующего применения\footnote{Упражнение: Почему ложный (третичный или альтернативный) вариант никогда не использует эту анафору?}. \verb"Aif" использует удобную COMMON LISP особенность: \emph{обобщённые булевы значения (generalised booleans)}. В COMMON LISP, все не-\verb"nil" значения являются истинными значениями, поэтому COMMON LISP программисты обычно встраивают интересную информацию в истинные значения. Языки в которых зарезервированы истинные и ложные значения - в частности Scheme - используют \emph{явные булевы значения (explicit booleans)}, которые иногда заставляют вас выводить дополнительную информацию для удовлетворения конструкций с избыточным типом. В Scheme добавлен \emph{костыль (kludge)} для того, чтобы \verb"if", \verb"cond", \verb"and", \verb"or" и \verb"do" работали с не-булевыми\footnote{С помощью Scheme предиката \verb"boolean?".} значениями [R5RS-P25]. Конечно, COMMON LISP спроектирован правильно - всё является булевым значением.



\begin{figure}Листинг 6.2: AIF\label{listing_6.2}
\listbegin
\begin{verbatim}
;; aif Грэма
(defmacro aif (test then &optional else)
`(let ((it ,test))
(if it ,then ,else)))
\end{verbatim}
\listend
\end{figure}

Также следует отметить что \verb"aif" и \verb"alambda", как и все анафорические макросы, нарушают \emph{лексическую прозрачность}. Или иначе, выражаясь модными словами, можно сказать что они не \emph{гигиеничные (unhygienic)} макросы. Они, как и большое количество макросов в этой книге, вводят невидимые лексические привязки и поэтому не могут быть созданы в макро системах со строгим соблюдением гигиены. Даже большое количество Scheme систем, платформа в которой много экспериментировали с гигиеной, предоставляют макросы в негигиеничном defmacro стиле - возможно, по той причине, что даже разработчики Scheme не воспринимали всерьёз гигиену. Подобно обучению катания на велосипеде, гигиенические системы в своём большинстве игрушки, которые забрасывают после овладевания минимальным уровнем мастерства.

Да, существует много интересных вещей, которые мы можем делать с помощью преднамеренного захвата переменной. Существует множество фор (phors). Эта книга и книга Грэма \emph{On Lisp} описывает лишь малую часть возможностей, заложенных в эту технику. Из грамотного применения анафорических макросов можно извлечь много новых потрясающих изобретений.

После краткой беседы об анафорах, продемонстрированной считывающими макросами, остаток этой главы описывает узкое приложение анафор к одной из центральных тем этой книги: лексические замыкания - \emph{let, окружающий lambda}. Большая часть этой главы посвящена интересным анафорическим макросам, предназначенным для изменения, адаптации и расширении замыканий. И хотя данная тема очень удобна в практическом применение для написания кода, мы используем её как платформу для обсуждения возможностей и вариантов анафорических макросов. Применение макросов для расширения концепции замыканий - это, на данный момент, интенсивно исследуемая тема [FIRST-CLASS-EXTENTS] [OPENING-CLOSURES].
