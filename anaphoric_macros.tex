\chapter{Анафорические Макросы}\label{chapter_anaphoric_macros}
\section{Больше Фор?}\label{section_more_phors?}

\emph{Анафорические макросы (Anaphoric macros)\index{макрос!анафорический}} --- это одни из наиболее интересных макросов из книги Пола Грэма\index{Грэм, Пол} \emph{On Lisp}. Анафорический макрос --- это макрос осуществляющий преднамеренный захват переменной из форм, переданных в макрос. Благодаря наличию \emph{прозрачных спецификаций (transparent specifications)} эти преднамеренно захваченные переменные порождают окна, позволяющие осуществлять контроль над расширением макроса. Через эти окна мы можем манипулировать расширением с помощью \emph{комбинаций (combinations)\index{макрос!комбинации}}.

Классическая анафора, такая как в \emph{On Lisp}, названа также, как и дословное\footnote{Цитирование U-Языка.} \emph{анафор (anaphor)}\index{анафора} и во множественном числе, \emph{анафора (ana\-pho\-ra)}. Анафор обозначает захват \emph{свободного слова U-Языка (free U-Language word)\index{свободная переменная!U-Язык}} для использования в последующем U-Языке. В терминах программирования, реализация классической анафоры означает нахождение места в вашем коде --- или в коде, который вы хотите написать --- где выражения могли бы извлечь выгоду, будучи способными сослаться на результаты предыдущих, связанных выражений. Настоятельно рекомендуется к изучению анафора Грэма и код, связанный с этой анафорой. Особенно обратите внимание на макрос \verb"defanaph" [ON-LISP-P223], позволяющий использовать некоторые интересные разновидности программирования \emph{автоматических анафор (automatic anaphor)}\index{автоматическая!анафора}.



По истечении некоторого периода было обнаружено, что \verb"alambda" --- это наиболее полезный анафорический макрос в \emph{On Lisp}. К тому же \verb"alambda" --- это один из наиболее простых и элегантных примеров, демонстрирующих анафорический макрос и преднамеренный захват переменной.

\begin{figure}Листинг 6.1: ALAMBDA\label{listing_6.1}
\listbegin
\begin{verbatim}
;; alambda Грэма
(defmacro alambda (parms &body body)
  `(labels ((self ,parms ,@body))
     #'self))
\end{verbatim}
\listend
\end{figure}

С \verb"alambda" мы захватываем имя \verb"self", таким образом, мы можем использовать его для построения очень анонимной функции. Другими словами рекурсия становится такой же простой как и вызов \verb"self". Например, следующая функция возвращает список\footnote{Если условие возвращает ложное значение, то отсутствующий третий элемент \verb"if" формы вернёт \verb"nil", что в свою очередь является списком.} чисел с \verb"n" до \verb"1":


\begin{verbatim}
CL-USER> (alambda (n)
           (if (> n 0)
               (cons
                n
                (self (- n 1)))))
#<FUNCTION (LABELS SELF) {B28725D}>
CL-USER> (funcall 
          (alambda (n)
            (if (> n 0)
                (cons
                 n
                 (self (- n 1))))) 3)
(3 2 1)
\end{verbatim}


\verb"Alambda" делает наш код более интуитивным и простым для чтения, позволяя нам думать об анонимных функциях как о функциях способных вызывать саму себя с той же лёгкостью, как и добавление единственной буквы\footnote{Это другая причина не шарп-закавычивать лямбда формы. Изменение шарп-закавыченных лямбда форм в alambda формы также потребует удаления двух символов.}. Поскольку \verb"alambda" прозрачно специфицирован для \verb"self" привязки --- и тот факт что единственная причина использования \verb"alambda" --- это применение этой привязки --- то нежелательный захват переменной уже не проблема.



Другой удобный анафорический макрос из \emph{On Lisp} --- это \verb"aif", макрос, привязывающий результат проверки к \verb"it" при положительном (вторичном) случае для последующего применения\footnote{Упражнение: Почему ложный (третичный или альтернативный) вариант никогда не использует эту анафору?}. \verb"Aif" использует удобную COMMON LISP особенность: \emph{обобщённые булевы значения (generalised booleans)\index{булевы значения!обобщённые}}. В COMMON LISP, все не-\verb"nil" значения являются истинными значениями, поэтому COMMON LISP программисты обычно встраивают интересную информацию в истинные значения. Языки в которых зарезервированы истинные и ложные значения --- в частности Scheme --- используют \emph{явные булевы значения (explicit booleans)\index{булевы значения!явные}}, которые иногда заставляют вас выводить дополнительную информацию для удовлетворения конструкций с избыточным типом. В Scheme добавлен \emph{костыль (kludge)\index{костыль}} для того, чтобы \verb"if", \verb"cond", \verb"and", \verb"or" и \verb"do" работали с не-булевыми\footnote{С помощью Scheme предиката \verb"boolean?".} значениями [R5RS-P25]. Конечно, COMMON LISP спроектирован правильно --- всё является булевым значением.



\begin{figure}Листинг 6.2: AIF\label{listing_6.2}
\listbegin
\begin{verbatim}
;; aif Грэма
(defmacro aif (test then &optional else)
  `(let ((it ,test))
     (if it ,then ,else)))
\end{verbatim}
\listend
\end{figure}

Также следует отметить что \verb"aif" и \verb"alambda", как и все анафорические макросы, нарушают \emph{лексическую прозрачность\index{лексическая!прозрачность}}. Или иначе, выражаясь модными словами, можно сказать что они \emph{негигиеничные (unhygienic)\index{макрос!негигиеничный}} макросы. Они, как и большое количество макросов в этой книге, вводят невидимые лексические привязки и поэтому не могут быть созданы в макро системах со строгим соблюдением гигиены. Даже большое количество Scheme систем, платформа в которой много экспериментировали с гигиеной, предоставляют макросы в негигиеничном defmacro стиле --- возможно, по той причине, что даже разработчики Scheme не воспринимали всерьёз гигиену. Подобно обучению катания на велосипеде, гигиенические системы в своём большинстве игрушки, которые забрасывают после овладевания минимальным уровнем мастерства.

Да, существует много интересных вещей, которые мы можем делать с помощью преднамеренного захвата переменной. Существует множество фор (phors). Эта книга и книга Грэма \emph{On Lisp} описывает лишь малую часть возможностей, заложенных в эту технику. Из грамотного применения анафорических макросов можно извлечь много новых потрясающих изобретений.

После краткой беседы об анафорах, продемонстрированной считывающими макросами, остаток этой главы описывает узкое приложение анафор к одной из центральных тем этой книги: лексические замыкания --- \emph{let, окружающий lambda\index{let, окружающий lambda}}. Большая часть этой главы посвящена интересным анафорическим макросам, предназначенным для изменения, адаптации и расширении замыканий. И хотя данная тема очень удобна в практическом применении для написания кода, мы используем её как платформу для обсуждения возможностей и вариантов анафорических макросов. Применение макросов для расширения концепции замыканий --- это, на данный момент, интенсивно исследуемая тема [FIRST-CLASS-EXTENTS] [OPENING-CLOSURES].

\section{Шарп-Обратное Закавычивание}\label{section_sharp-backquote} 

Хотя большинство анафор представлено в виде обычных макросов, у считывающих макросов тоже есть возможность использования кода, создающего для нас невидимые привязки. Такие считывающие макросы называются \emph{считывающими анафорами (read anaphora)}\index{анафора!считывающая}. Этот раздел ознакомит вас с таким макросом, который являясь весьма незатейливым, удивил даже меня и который стал одним из наиболее полезных макросов, используемых в этой книге. Я постарался как можно скорее перейти к этому макросу, поскольку он будет использоваться в оставшемся коде. Более того, несколько рассмотренных нами макросов уже используют его.

\begin{figure}Листинг 6.3: SHARP-BACKQUOTE\label{listing_6.3}
\listbegin
\begin{verbatim}
(defun |#`-reader| (stream sub-char numarg)
  (declare (ignore sub-char))
  (unless numarg (setq numarg 1))
  `(lambda ,(loop for i from 1 to numarg
               collect (symb 'a i))
     ,(funcall
       (get-macro-character #\`) stream nil)))

(set-dispatch-macro-character
 #\# #\` #'|#`-reader|)
\end{verbatim}
\listend
\end{figure}

Шарп-обратное закавычивание --- это считывающий макрос, выполняющий считывание как лямбда форма. По умолчанию, эта лямбда форма получает только один аргумент: \verb"a1". Затем считывающий макрос рекурсивно вызывает функцию \verb"read" для переданного потока. Ниже есть пример с остановленным вычислением (с помощью \verb"quote"), и мы можем рассмотреть прозрачное введение считывающей анафоры\footnote{Конечно, префикс захваченного символа, ``\verb"a"'', расшифровывается анафорой.}:



\begin{verbatim}
CL-USER> '#`((,a1))
(LAMBDA (A1) `((,A1)))
\end{verbatim}

Этот считывающий макрос формирует абстракцию общего шаблона макроса. Например, если у нас есть список переменных и мы хотим создать список \verb"let" привязок, где каждая переменная привязана к символу, скажем, \verb"empty", то мы можем использовать \verb"mapcar" следующим способом:

\begin{verbatim}
CL-USER> (mapcar (lambda (a)
                   (list a ''empty))
                 '(var-a var-b var-c))
((VAR-A 'EMPTY) (VAR-B 'EMPTY) (VAR-C 'EMPTY))
\end{verbatim}

Но особенно для сложных списковых структур, такой подход может оказаться довольно грязным, поэтому лисп программисты предпочитают использовать обратное закавычивание для поднятия на один уровень закавычивания:

\begin{verbatim}
CL-USER> (mapcar (lambda (a)
                   `(,a 'empty))
                 '(var-a var-b var-c))
((VAR-A 'EMPTY) (VAR-B 'EMPTY) (VAR-C 'EMPTY))
\end{verbatim}

Наш новый считывающий макрос вводит анафору и скрывает лямбда форму:

\begin{verbatim}
CL-USER> (mapcar #`(,a1 'empty)
                 '(var-a var-b var-c))
((VAR-A 'EMPTY) (VAR-B 'EMPTY) (VAR-C 'EMPTY))
\end{verbatim}

\verb"1" в символе \verb"a1" выше говорит о том, что пользователи считывающего макроса могут вводить переменное число анафор, зависящее от числа переданного в параметр \verb"numarg" считывающего макроса:

\begin{verbatim}
CL-USER> '#2`(,a1 ,a2)
(LAMBDA (A1 A2) `(,A1 ,A2))
\end{verbatim}

Таким образом мы можем одновременно за\verb"mapcar"-ить шарп-обратно закавыченные выражения с несколькими списками:

\begin{verbatim}
CL-USER> (let ((vars '(var-a var-b var-c)))
           (mapcar #2` (,a1 ',a2)
                   vars
                   (loop for v in vars
                        collect (gensym
                                 (symbol-name v)))))
((VAR-A '#:VAR-A1213) 
 (VAR-B '#:VAR-B1214) 
 (VAR-C '#:VAR-C1215))
\end{verbatim}

Ещё один способ думать о шарп-обратном закавычивании: шарп-об\-рат\-ное закавычивание выполняет интерполяцию списка, также, как функция \verb"format" выполняет интерполяцию строки. \verb"Format" позволяет нам использовать шаблоны со слотами, заполняемыми значениями отдельных аргументов, аналогично шарп-обратное закавычивание позволяет нам отделить структуру интерполированного списка от значений, с которыми мы хотим их объединить. Благодаря ранее описанному \emph{дуализму синтаксиса\index{двойственность синтаксиса}} между лямбда формами в позиции функции в списке и лямбда формами, использующими макрос \verb"lambda" для расширения в функцию, мы также можем использовать шарп-обратное закавычивание в роли первого элемента при вызове функции:

\begin{verbatim}
CL-USER> (#3` (((,a1)) ,@a2 (,a3))
              (gensym)
              '(a b c)
              'hello)
(((#:G1216)) A B C (HELLO))
\end{verbatim}

В отличие от \verb"format" шарп-обратное закавычивание не использует последовательное позиционирование. Вместо этого используется числа для наших анафорических привязок. Вследствие этого порядок может перемешиваться и мы можем сращивать привязки более одного раза:

\begin{verbatim}
CL-USER> (#3` (((,@a2)) ,a3 (,a1 ,a1))
              (gensym)
              '(a b c)
              'hello)
(((A B C)) HELLO (#:G1217 #:G1217))
\end{verbatim}

Упражнение: Ссылки на \verb"gensym #:G1217" выглядят так, как будто ссылаются на один и тот-же символ, но, конечно, вы никогда не можете утверждать это глядя на напечатанные имена. Являются ли эти символы \verb"eq"-абельными? Обоснуйте ответ.

\section{Alet и Машины с Конечным Состоянием}\label{section_alet_and_finite_state_machines}


С \emph{lambda\index{лямбда}} и \emph{if\index{if}} возможна только одна полезная анафорическая конфигурация. Но большинство интересных типов анафорических макросов используют расширения самыми неожиданными способами. Этот раздел --- как и большая часть этой главы --- посвящена одному из таких макросов: \verb"alet". Какие дополнительные привязки могут быть полезны для форм внутри тела \verb"let" формы? \verb"Let" используется для того, чтобы создать привязки к переданным переменным. Однако, макро улучшение \verb"let" даст возможность получения доступа ко всем переданным формам, даже если тела этих выражений должны вычисляться с новыми привязками. Так какая же часть тела наиболее полезна? В большинстве случаев это последняя форма тела, поскольку результаты этой формы будут возвращены из самого оператора \verb"let"\footnote{Поскольку \verb"let" предоставляет неявный \verb"progn".}. Мы уже видели что когда мы возвращаем лямбда выражение, ссылающееся на привязки, созданные \verb"let"-ом, то результатом является лексическое замыкание --- объект, часто сохраняемый и используемый для последующего доступа к переменным в \verb"let" операторе. Таким образом, расширение нашего аналога объекта-замыкания, макрос \verb"alet%" работает также, как и специальная форма \verb"let", с тем отличием, что захватывает символ \verb"this" из тела и привязывает его к последнему выражению в теле формы --- единственное, что будет возвращено как замыкание\footnote{\verb"Setq" применяется потому что форма привязанная к \verb"this" определена в лексической области видимости других аргументов заданных через \verb"letargs".}.


\begin{figure}Листинг 6.4: ALET-1\label{listing_6.4}
\listbegin
\begin{verbatim}
(defmacro alet% (letargs &rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     this))
\end{verbatim}
\listend
\end{figure}

\verb"Alet%" может быть полезен в случае когда у нас есть инициализирующий код в лямбда форме, который мы не хотим дублировать. Поскольку \verb"this" привязан к возвращаемой лямбда форме, то у нас есть возможность выполнить его перед выходом из окружающего \verb"let". Следующий пример --- это замыкание, конструкция которого показывает простой пример использования \verb"alet%" с целью избежания дублирования инициализирующего и сбрасывающего кода:

\begin{verbatim}
CL-USER> (alet% ((sum) (mul) (expt))
                (funcall this :reset)
                (dlambda
                 (:reset ()
                         (psetq sum 0
                                mul 1
                                expt 2))
                 (t (n)
                    (psetq sum (+ sum n)
                           mul (* mul n)
                           expt (expt expt n))
                    (list sum mul expt))))
#<CLOSURE (LAMBDA (&REST #:ARGS0)) {AB979AD}>
\end{verbatim}

С помощью этого кода мы можем последовательно изменять значения \verb"sum", \verb"mul" и \verb"expt":

\begin{verbatim}
CL-USER> (loop for i from 1 to 5 collect (funcall * 2))
((2 2 4) (4 4 16) (6 8 256) (8 16 65536) (10 32 4294967296))
\end{verbatim}

Мы можем сбросить замыкание вызвав метод \verb":reset". Заметьте, что благодаря \verb"alet%", для сброса в базовые состояния (0 для \verb"sum", 1 для \verb"mul" и 2 для \verb"expt") достаточно использовать \verb":reset" в одном месте:

\begin{verbatim}
CL-USER> (funcall ** :reset)
NIL
\end{verbatim}

Теперь, когда переменные замыкания были сброшены, мы можем увидеть новую последовательность:

\begin{verbatim}
CL-USER> (loop for i from 1 to 5 collect (funcall *** 0.5))
((0.5 0.5 1.4142135) (1.0 0.25 1.1892071) (1.5 0.125 1.0905077)
 (2.0 0.0625 1.0442737) (2.5 0.03125 1.0218971))
\end{verbatim}

Учтите, что \verb"alet%" меняет порядок вычисления форм в теле \verb"let". Если вы посмотрите на расширение, вы увидите, что последняя форма тела вычислена первой, её результат привязан к лексической привязке \verb"this", а после этого вычисляются предыдущие формы. И пока последний аргумент является константой, изменение порядка вычислений не играет никакой роли. Помните что лямбда выражение\footnote{\verb"Dlambda" расширяется в лямбда формы.} является константой и, таким образом, идеально подходит для использования в \verb"alet%".



\begin{figure}Листинг 6.5: ALET\label{listing_6.5}
\listbegin
\begin{verbatim}
(defmacro alet (letargs &rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (lambda (&rest params)
       (apply this params))))
\end{verbatim}
\listend
\end{figure}

Нам доступны множество уровней свободы, поэтому улучшение этого макроса, как и многие другие улучшения макросов, кажутся нелогичными. И хотя существуют множество возможностей, этот раздел посвящён рассмотрению одного такого специфического улучшения. \verb"Alet%" можно модифицировать таким образом, чтобы он не возвращал последнюю форму своего тела --- про которое мы уже заранее знаем что оно будет лямбда формой --- взамен функции, находящей другую функцию внутри лексической области видимости \verb"let" формы, и вызывающей эту функцию. Иногда это называется \emph{косвенностью (indirection)\index{косвенность}}, поскольку вместо возвращения функции, выполняющей что либо, мы возвращаем функцию, которая ищет функцию с помощью разыменовывания указателя и после этого использует эту функцию. Косвенность --- это понятие, применимое ко всем языкам программирования. Оно позволяет нам менять объекты во время выполнения в то время когда без косвенности, эти объекты являются неизменными во время компиляции. Лисп позволяет нам использовать косвенность в более кратком и удобном стиле чем во многих других языках программирования. \verb"Alet" --- версия \verb"alet%" с косвенностью, позволяет получить доступ к функции, возвращённой нами как замыкание или заместить эту функцию кодом внутри тела \verb"alet" или, если мы используем \verb"dlambda", как это будет показано позже, даже кодом, находящимся за пределом тела \verb"alet".

Теперь, когда мы можем изменить функцию, которая запускается при вызове замыкания с нашим макросом \verb"alet", у нас есть возможность создания пары взаимно ссылающихся функций с помощью шаблона под названием \emph{alet, окружающий alambda}\index{alet, окружающий alambda}. Если все состояния возвращаются в исходное состояние --- вместо того, чтобы переходить в состояния друг в друга --- то, \verb"alet", окружающий \verb"alambda" --- это удобный способ определения безымянных машин с состоянием.

Следующее типичное замыкание-счётчик получает аргумент \verb"n" и может менять направление счётчика между инкрементированием и декрементированием на \verb"n" при передаче символа \verb"invert" в качестве аргумента взамен числа \verb"n":

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (alambda (n)
                 (if (eq n 'invert)
                     (setq this
                           (lambda (n)
                             (if (eq n 'invert)
                                 (setq this #'self)
                                 (decf acc n))))
                     (incf acc n))))
#<CLOSURE (LAMBDA (&REST PARAMS)) {C43A6CD}>
\end{verbatim}

Сохраним это замыкание для того, чтобы мы могли использовать его так часто, насколько это нам будет нужно:

\begin{verbatim}
CL-USER> (setf (symbol-function 'alet-test) *)
#<CLOSURE (LAMBDA (&REST PARAMS)) {C43A6CD}>
\end{verbatim}

При первом запуске счётчик идёт на увеличение:

\begin{verbatim}
CL-USER> (alet-test 10)
10
\end{verbatim}

Но, мы можем изменять функцию, на вызов внутреннего лямбда выражения в нашем определении через передачу символа \verb"invert" замыканию:

\begin{verbatim}
CL-USER> (alet-test 'invert)
#<CLOSURE (LAMBDA (N) :IN SELF) {C7CFA7D}>
\end{verbatim}

И теперь мы идём вниз:

\begin{verbatim}
CL-USER> (alet-test 3)
7
\end{verbatim}

И наконец благодаря привязке \verb"self" предоставляемой \verb"alambda" мы можем снова сменить вызываемую функцию передав символ \verb"invert":

\begin{verbatim}
CL-USER> (alet-test 'invert)
#<CLOSURE (LABELS SELF) {C43A6B5}>
\end{verbatim}

Мы вернулись к предыдущему направлению и идём вверх:

\begin{verbatim}
CL-USER> (alet-test 5)
12
\end{verbatim}

Это замыкание будет привязано к символу \verb"alet-test" относящемуся к пространству функции . Но это замыкание слегка отличается от обычного замыкания. Оба этих замыкания (обычное замыкание и наше замыкание) являются ссылками к одной среде, которое может иметь любое количество указателей, это замыкание использует косвенность для изменения кода, который будет выполнен при вызове. И хотя установленным может быть любой код, получить доступ к лексическим привязкам анафоре \verb"this" в лексической области \verb"alet" может только один код. Но, нам по прежнему ничто не мешает установить новое замыкание, с его собственными лексическими привязками и, возможно, с изменённым поведением в \emph{косвенной среде\index{косвенность}}, установленной с помощью \verb"alet". Большая часть этой главы посвящена полезным приёмам, которые мы можем выполнять с косвенной средой, созданной с помощью \verb"alet".

Общая техника работы с макросами неформально известна как \emph{выворачивание макроса наизнанку (turning a macro inside out)\index{макрос!выворачивание наизнанку}}. Когда вы выворачиваете макрос наизнанку вы получаете типичную форму, использующую макрос, подобный макросу который вы хотите создать, и расширяете её. Дальше вы используете расширение как шаблон для вашего желаемого макроса. Например, мы хотели бы получить более универсальный метод создания замыканий с множественными состояниями чем способ с вышеприведённым счётчиком, основанном на \verb"alet", окружающем \verb"alambda". Вот расширение изнанки в случае с инвертируемым \verb"alambda" счётчиком:

\begin{verbatim}
CL-USER> (macroexpand
          '(alambda (n)
            (if (eq n 'invert)
                (setq this
                      (lambda (n)
                        (if (eq n 'invert)
                            (setq this #'self)
                            (decf acc n))))
                (incf acc n))))
(LABELS ((SELF (N)
           (IF (EQ N 'INVERT)
               (SETQ THIS
                       (LAMBDA (N)
                         (IF (EQ N 'INVERT)
                             (SETQ THIS #'SELF)
                             (DECF ACC N))))
               (INCF ACC N))))
  #'SELF)
T
\end{verbatim}

Если мы выполним маленький рефакторинг вышеприведённого расширения с учётом того, что \verb"labels" позволяет нам создавать множественные привязки функций\footnote{Используется множественность labels.}, то получится следующее:



\begin{verbatim}
CL-USER> (alet ((acc 0))
               (labels ((going-up (n)
                          (if (eq n 'invert)
                              (setq this #'going-down)
                              (incf acc n)))
                        (going-down (n)
                          (if (eq n 'invert)
                              (setq this #'going-up)
                              (incf acc (- n)))))
                 #'going-up))
#<CLOSURE (LAMBDA (&REST PARAMS)) {AC359AD}>
\end{verbatim}

\begin{figure}Листинг 6.6: ALET-FSM\label{listing_6.6}
\listbegin
\begin{verbatim}
(defmacro alet-fsm (&rest states)
  `(macrolet ((state (s)
                `(setq this #',s)))
     (labels (,@states) #',(caar states))))
\end{verbatim}
\listend
\end{figure}

Здесь нужно учесть что \verb"alambda" может сделать доступными все тела специальной формы \verb"labels" для всех функций. И что ещё более важно, теперь у нас есть довольно неплохой шаблон для нашего событийного макроса.

\verb"Alet-fsm" даёт нам возможность использовать удобный синтаксис для выражения нескольких возможных \emph{состояний (states)\index{программный!состояние}} для нашего замыкания. Это очень тонкий слой сахара из макросов поверх \verb"labels", скомбинированный с \emph{проходом-по-коду\index{проход по коду}} \verb"macrolet" трансформации, позволяющей нам сымитировать функцию \verb"state", изменяющую текущее состояние замыкания через анафору \verb"this" предоставляемую \verb"alet"-ом. В качестве примера приведена более чистая версия счётчика с изменяемым направлением роста:

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (alet-fsm
                (going-up (n)
                          (if (eq n 'invert)
                              (state going-down)
                              (incf acc n)))
                (going-down (n)
                            (if (eq n 'invert)
                                (state going-up)
                                (decf acc n)))))
#<CLOSURE (LAMBDA (&REST PARAMS)) {B4BE13D}>
\end{verbatim}

\verb"Alet-fsm" представляет экземпляр техники, которую мы ещё не видели: \emph{инъекция анафоры (anaphor injection)}\index{анафора!инъекция}. Использование этой анафоры нарушает лексическую прозрачность многими способами, что так или иначе, становится \emph{лексически невидимым (lexically invisible)\index{лексическая!невидимость}}. Кроме невидимой привязки \verb"this" \verb"alet"-ом, также невидимым является использование \verb"this" макросом \verb"alet-fsm". \verb"Alet-fsm" инъецирует свободную переменную в наш лексический контекст так, что мы не можем её увидеть.

В данном случае стилистические проблемы не строго очерчены\footnote{Как и все стилистические вопросы. Если вы что-либо поймёте в полном объёме, то вопросы стиля становятся неуместными. Инъекция свободной переменной понята не до конца.}, поскольку программирование макросов это конечно не вопрос стиля. Это вопрос мощи. Иногда инъекция свободной переменной может создавать симбиоз между двумя макросами --- вместе они смогут создать расширение с более лучшей программной конструкцией чем два изолированных расширения. Поскольку этот тип макро программирования сложен, то опять можно провести параллели с указателями C. Как изучение указателей C порождает сомнительные стилистические приёмы, также происходит и с инъекцией свободной переменной.

Наиболее правдоподобная гипотеза объясняющая трудность понимания инъекции свободной переменной связана с вопросом \emph{отказобезопасного\index{отказобезопасный}} поведения\footnote{Здесь под понятием безопасности, в отличие от реального мира, понимается максимально быстрый и громкий отказ.}. С анафорой, в случае когда код переданный пользователем не использует привязку, возможно дальнейшее функционирование кода. Но, есть вероятность, что такой код может отказать без каких-либо предупреждений, а это небезопасно. Однако, когда вы вставите свободную переменную и нет окружения в котором эта переменная может быть захвачена, то всё выражение будет свободным. При возникновении такой ситуации вам нужно решить что делать до того, как вы будете вычислять это выражение. Оно может быть отказобезопасным.

Отставим в сторону стиль. Иногда инъекция свободной переменной --- это то, что нам нужно для того, чтобы создать коммуникацию между двумя связанными макросами. Инъекция выполняет то же, что и анафора, но в другом направлении. Поскольку вы открываете новый канал коммуникации между вашими макросами, то проблемы сложности масштабируются очень быстро. Рассмотрим нахождение в доме полном хрупкого стекла. Вы можете безопасно швырять предметы в людей снаружи дома, даже если они не озаботятся их ловлей, но, вам лучше убедиться в том, что вы сможете поймать любой объект брошенный в вас.

\section{Косвенные Цепи}\label{section_indirection_chains}



\begin{figure}Листинг 6.7: ICHAIN-BEFORE\label{listing_6.7}
\listbegin
\begin{verbatim}
(defmacro! ichain-before (&rest body)
  `(let ((,g!indir-env this))
     (setq this
           (lambda (&rest ,g!temp-args)
             ,@body
             (apply ,g!indir-env
                    ,g!temp-args)))))
\end{verbatim}
\listend
\end{figure}

Существуют много способов с помощью которых мы можем извлечь пользу из анафоры \verb"this", предоставляемой макросом \verb"alet". Поскольку доступ к окружению осуществляется через замыкание-пустышку, перенаправляющее все вызовы к настоящему замыканию, на которое указывает \verb"this", то мы можем где угодно передавать ссылку на замыкание-пустышку копируя его так часто, сколько нам это будет нужно. Удобство подобной \emph{косвенности\index{косвенность}} в том, что мы можем менять происходящие события при вызове замыкания-пустышки без изменения ссылок на само замыкание-пустышку.

\verb"Ichain-before" предназначен для расширения в форме \verb"alet". Этот макрос добавляет исполнение нового кода до вызова главного замыкания. Вернёмся к нашему примеру со счётчиком, \verb"ichain-before" позволяет нам добавить новое замыкание, которое печатает предыдущее значение переменной \verb"acc" до того как это значение будет увеличено:

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (ichain-before
                (format t "Changing from ~a~%" acc))
               (lambda (n)
                 (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {AEC6015}>
\end{verbatim}

Результат такой, какой и ожидался:

\begin{verbatim}
CL-USER> (funcall * 2)
Changing from 0
2
CL-USER> (funcall ** 2)
Changing from 2
4
\end{verbatim}

Есть причина по которой в названии \verb"ichain-before" содержится упоминание цепи (chain). Мы можем вставить сколько угодно исполняемых замыканий:

\begin{verbatim}
CL-USER> (alet ((acc 0))
          (ichain-before
           (format t "A~%"))
          (ichain-before
           (format t "B~%"))
          (ichain-before
           (format t "C~%"))
          (lambda (n)
            (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {B1B330D}>
\end{verbatim}

Каждое новое звено будет добавляться в начало цепи, в результате появление звеньев цепи будет происходить в обратном порядке:

\begin{verbatim}
CL-USER> (funcall * 2)
C
B
A
2
\end{verbatim}

Иногда статическое добавление косвенных цепей оказывается полезным для того, чтобы избежать реструктуризацию макросов просто добавив вместо этого новый окружающий код. Но наиболее интересные возможности косвенных цепей возникают при их динамическом добавлении. Поскольку мы можем создавать новые функции во время исполнения, а также можем получать доступ ко внутренностям замыкания через анафору, то мы можем переписать работу функций во время исполнения. Ниже представлен простой пример в котором каждый вызов замыкания добавляет код, печатающий ``Hello world'' при запуске:

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (lambda (n)
                 (ichain-before
                  (format t "Hello world~%"))
                 (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {C3EFE15}>
\end{verbatim}

Каждый вызов добавляет новое замыкание к косвенной цепи:

\begin{verbatim}
CL-USER> (loop for i from 1 to 4
              do
              (format t "~:r invocation:~%" i)
              (funcall * i))
first invocation:
second invocation:
Hello world
third invocation:
Hello world
Hello world
fourth invocation:
Hello world
Hello world
Hello world
NIL
\end{verbatim}

Макрос \verb"ichain-after" подобен макросу \verb"ichain-before" за исключением того, что он добавляет замыкания в другой конец исполняемой цепи: после вызова главного замыкания. \verb"Ichain-after" использует \verb"prog1", который последовательно исполняет переданные формы и затем возвращает результат вычисления первой формы.

\verb"Ichain-before" и \verb"ichain-after" могут комбинироваться, пример:

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (ichain-before
                (format t "Changing from ~a~%" acc))
               (ichain-after
                (format t "Changed to ~a~%" acc))
               (lambda (n)
                 (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {D26585D}>
CL-USER> (funcall * 7)
Changing from 0
Changed to 7
7
\end{verbatim}

\begin{figure}Листинг 6.8: ICHAIN-AFTER\label{listing_6.8}
\listbegin
\begin{verbatim}
(defmacro! ichain-after (&rest body)
  `(let ((,g!indir-env this))
     (setq this
           (lambda (&rest ,g!temp-args)
             (prog1
                 (apply ,g!indir-env
                        ,g!temp-args)
               ,@body)))))
\end{verbatim}
\listend
\end{figure}

\verb"Ichain-before" и \verb"ichain-after" --- это макросы, которые инъецируют свободные переменные\index{свободная переменная!инъекция} в свои расширения. Они инъецируют символ \verb"this", который предназначен для захвата расширением макроса \verb"alet". Такая разновидность инъекции символов может показаться плохим стилем программирования, который способен порождать ошибки, но на самом деле --- это общая техника макросов. На деле почти все макросы инъецируют символы в расширение. К примеру: помимо \verb"this", макрос \verb"ichain-before" также инъецируют такие символы как \verb"let", \verb"setq" и \verb"lambda" предназначенные для сращивания с окружением, в котором расширяется макрос. Разница между такими символами как \verb"this" и такими предварительно определёнными символами как \verb"setq" в том, что \verb"lambda" всегда ссылается к единственному хорошо описанному ANSI макросу, а такие символы как \verb"this" могут ссылаться к различным объектам в зависимости от сред, в которых они были расширены.

\begin{figure}Листинг 6.9: ICHAIN-INTERCEPT-1\label{listing_6.9}
\listbegin
\begin{verbatim}
(defmacro! ichain-intercept% (&rest body)
  `(let ((,g!indir-env this))
     (setq this
           (lambda (&rest ,g!temp-args)
             (block intercept
               (prog1
                   (apply ,g!indir-env
                          ,g!temp-args)
                 ,@body))))))
\end{verbatim}
\listend
\end{figure}

\verb"Ichain-before" и \verb"ichain-after" полезны для того, чтобы метить код, выполняемый до или после исполнения исходного перекрытого выражения. Но это ни в коем случае не единственная операция, которую мы можем выполнять с помощью анафоры \verb"this". Другой распространённой операцией является проверка данных замыкания после вызова замыкания.

\verb"Ichain-intercept%" --- это другой макрос, предназначенный для использования внутри формы \verb"alet". Идея заключается в том, что мы хотим перехватывать вызовы замыкания и проверять результаты действия замыкания с целью предотвращения некорректных состояний в замыкании.

Так мы можем добавить перехват в наше обычное замыкание-счётчик:

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (ichain-intercept%
                (when (< acc 0)
                  (format t "Acc went negative~%")
                  (setq acc 0)
                  (return-from intercept acc)))
               (lambda (n)
                 (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {B0903CD}>
\end{verbatim}

Код, установленный при помощи \verb"ichain-intercept%", предупредит нас о падении значения счётчика ниже 0:

\begin{verbatim}
CL-USER> (funcall * -8)
Acc went negative
0
\end{verbatim}

\begin{figure}Листинг 6.10: ICHAIN-INTERCEPT\label{listing_6.10}
\listbegin
\begin{verbatim}
(defmacro! ichain-intercept (&rest body)
  `(let ((,g!indir-env this))
     (setq this
           (lambda (&rest ,g!temp-args)
             (block ,g!intercept
               (macrolet ((intercept (v)
                            `(return-from
                              ,',g!intercept
                               ,v)))
                 (prog1
                     (apply ,g!indir-env
                            ,g!temp-args)
                   ,@body)))))))
\end{verbatim}
\listend
\end{figure}

Счётчик будет сброшен в 0:

\begin{verbatim}
CL-USER> (funcall ** 3)
3
\end{verbatim}

Наиболее интересным моментом в \verb"ichain-intercept%" является введение \emph{блокирующей анафоры (block anaphor)}\index{анафора!блок} под названием \verb"intercept". Для использования этой анафоры мы применяем \verb"return-from". Блок будет возвращать это значение из вызова замыкания перехватывая исходное значение.

Вместо захвата блокирующей анафоры \verb"intercept", \verb"ichain-intercept" создаёт локальный макрос, позволяющий коду внутри \verb"ichain-intercept" использовать \verb"intercept" для расширения в \verb"return-from" где блок определён как \verb"gensym".

\begin{verbatim}
CL-USER> (alet ((acc 0))
               (ichain-intercept
                (when (< acc 0)
                  (format t "Acc went negative~%")
                  (setq acc 0)
                  (intercept acc)))
               (lambda (n)
                 (incf acc n)))
#<CLOSURE (LAMBDA (&REST PARAMS)) {CC4F815}>
\end{verbatim}

Результат тот же, что и в \verb"ichain-intercept%":

\begin{verbatim}
CL-USER> (funcall * -8)
Acc went negative
0
CL-USER> (funcall ** 3)
3
\end{verbatim}

Конечно, прозрачное введение всех этих замыканий в операции может сказаться на производительности во время выполнения. К счастью, современные лисп компиляторы очень хорошо оптимизируют замыкания. Если ваше приложение может разыменовывать несколько указателей --- а часто оно это может --- косвенные цепи могут быть лучшим способом для их структуризации. Смотрите раздел Область Видимости Указателя, там описан другой взгляд на косвенные цепи. Кроме того, рассмотрите CLOS-овскую\index{CLOS} функциональность до, после и вокруг.

\section{Замыкания, Поддерживающие Горячую Замену}\label{section_hotpatching_closures}


В этом разделе было запланировано три цели. Первая, было рассмотрено другое интересное использование анафоры \verb"this" из \verb"alet". Второе, обсудили шаблон \emph{alet, окружающий dlambda}\index{alet, окружающий dlambda}. И наконец, введена полезная макро техника под названием \emph{закрытие анафоры}\index{анафора!закрытие}.

Для того, чтобы ясно проиллюстрировать закрытие анафоры мы не будем работать с макросом \verb"alet" и переключимся на изнанку\index{макрос!выворачивание наизнанку} расширения. \verb"Alet-hotpatch%" --- это расширение \verb"alet" со специальной лямбда формой. Эта лямбда форма проверяет первый аргумент\footnote{Со сравнением указателя.} на соответствие с ключевым символом \verb":hotpatch" и при обнаружении этого символа заменяет косвенное замыкание на переданный аргумент.



\begin{figure}Листинг 6.11: ALET-HOTPATCH-1\label{listing_6.11}
\listbegin
\begin{verbatim}
(defmacro alet-hotpatch% (letargs &rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (lambda (&rest args)
       (if (eq (car args) ':hotpatch)
           (setq this (cadr args))
           (apply this args)))))
\end{verbatim}
\listend
\end{figure}

Возможность замены замыкания использованного в другом выполняющемся замыкании во время работы программы называется \emph{горячей заменой (hotpatching)\index{горячая замена}}. Например, мы создали замыкание с поддержкой горячей замены и, для дальнейшего применения, сохранили его в ячейку символа-функции символа \verb"hotpatch-test":

\begin{verbatim}
CL-USER> (setf (symbol-function 'hotpatch-test)
               (alet-hotpatch% ((acc 0))
                               (lambda (n)
                                 (incf acc n))))
#<CLOSURE (LAMBDA (&REST ARGS)) {AE37ED5}>
\end{verbatim}

Возможное применение:

\begin{verbatim}
CL-USER> (hotpatch-test 3)
3
CL-USER> (hotpatch-test 4)
7
\end{verbatim}

Мы можем заменить лямбда форму --- вместе со связанной с ней средой --- вызвав это замыкание с символом \verb":hotpatch" и заменяющей функцией или замыканием:

\begin{verbatim}
CL-USER> (hotpatch-test
          :hotpatch
          (let ((acc 0))
            (lambda (n)
              (incf acc (* 2 n)))))
#<CLOSURE (LAMBDA (N)) {B0FF48D}>
\end{verbatim}

\begin{figure}Листинг 6.12: ALET-HOTPATCH\label{listing_6.12}
\listbegin
\begin{verbatim}
(defmacro alet-hotpatch (letargs &rest body)
  `(let ((this) ,@letargs)
     (setq this ,@(last body))
     ,@(butlast body)
     (dlambda
      (:hotpatch (closure)
                 (setq this closure))
      (t (&rest args)
         (apply this args)))))
\end{verbatim}
\listend
\end{figure}

Теперь замыкание обладает новым, исправленным на лету поведением:

\begin{verbatim}
CL-USER> (hotpatch-test 2)
4
CL-USER> (hotpatch-test 5)
14
\end{verbatim}

Заметьте как значение счётчика сбросилось в 0 после горячей замены среды замыкания на новое значение для аккумулятора счётчика \verb"acc".

Кажется мы уже видели такую разновидность \emph{деструктуризации во время исполнения\index{деструктуризация!во время выполнения}}, основанную на символах ключевых слов? Да, на деле мы написали макрос выполняющий то же самое что и в \emph{разделе Dlambda}. \verb"Alet-hotpatch" --- это версия \verb"alet-hotpatch%" основанная на \verb"dlambda". Иногда, даже не осознавая этого, при написании новых макросов мы применяем \emph{комбинирование макросов (macro combination)\index{макрос!комбинации}}. У хорошо спроектированного макроса расширение полностью понятно и хотя возможны разнообразные нарушения лексической прозрачности, проблем с комбинированием не возникает, поскольку все компоненты подходят друг к другу.

\begin{figure}Листинг 6.13: LET-HOTPATCH\label{listing_6.13}
\listbegin
\begin{verbatim}
(defmacro! let-hotpatch (letargs &rest body)
  `(let ((,g!this) ,@letargs)
     (setq ,g!this ,@(last body))
     ,@(butlast body)
     (dlambda
      (:hotpatch (closure)
                 (setq ,g!this closure))
      (t (&rest args)
         (apply ,g!this args)))))
\end{verbatim}
\listend
\end{figure}

\verb"Alet-hotpatch" создаёт замыкание с поддержкой горячей замены, но в этом макросе есть один концептуальный недостаток. Поскольку макрос \verb"alet-hotpatch" используется для создания замыканий с горячей заменой, то мы можем забыть что этот макрос вводит анафору \verb"this" в область видимости переданных форм. Если мы забудем о созданной анафоре, то мы рискуем столкнуться с проблемой нежелательного захвата переменной. Для того, чтобы избежать подобных проблем, мы должны применить технику известную как \emph{закрытие анафоры (anaphor closing)}\index{анафора!закрытие}. При закрытии анафоры мы не меняем способ функционирования анафорического макроса, а просто запрещаем некоторые способы комбинирования этого макроса.

Поскольку мы вывернули расширение \verb"alet" наизнанку, то мы можем лексически увидеть создание анафоры \verb"this" в определении макроса \verb"alet-hotpatch". И поскольку \verb"alet-hotpatch" также содержит код, использующий анафору \verb"this" для реализации горячей замены, то мы можем закрыть анафору так, что символ \verb"this" больше не будет захватываться макросом. Каким стандартным способом мы избегаем введения нежелательных привязок? Конечно мы именуем привязки с помощью \verb"gensym"-ов.

\verb"Let-hotpatch" --- это пример закрытия анафоры \verb"this" в более замкнутую версию --- более безопасная версия после реализации всех необходимых нам горячих замен. ``\verb"A"'', удалённое из названия макроса, обозначает что этот новый макрос больше не вносит анафору в переданный код. Конечно если нам необходимо по некоторым причинам, отличающимся от простой горячей замены, сослаться на \verb"this", то мы должны оставить анафору открытой.

Техника открытия и закрытия анафоры становится второй натурой программиста после того, как он напишет достаточное количество подобных макросов. Также, как мы можем писать макросы, инъецирующие свободные переменные в расширение не задумываясь о том как мы будем их захватывать пока мы пишем лексический контекст в котором они будут расширяться, мы иногда оставляем открытым анафору при разработке макроса для экспериментирования с комбинациями анафорических макросов и инъекции свободных переменных. После того, как будут найдены наиболее полезные комбинации, мы можем произвести слияние макросов и заменить все использованные во время разработки анафоры на \verb"gensym"-ы. Также, как это делает \verb"let-hotpatch", эта техника может использовать \verb"defmacro!" для перемещения области видимости анафоры с макро расширения в макро определение. Вместо лексического введения анафоры мы ввели другой тип анафоры --- такой, который не может работать в целой лексической области видимости расширения, но работает только в другой, более ограниченной области видимости. Эта область видимости будет описываться в следующем разделе.

\section{Суб-Лексическая Область Видимости}\label{section_sub-lexical_scope}


Наш макро-определяющий макрос \verb"defmacro!" определённый в \emph{разделе Нежелательный Захват} ищет присутствие автоматических \verb"gensym"-ов в переданном коде с помощью утилиты Грэма \verb"flatten". А теперь пришло время признаться в маленькой лжи. До сих пор, пока мы не рассмотрели инъекцию свободной переменной и анафору, мы считали что символьные G-bang имена в \verb"defmacro!" определениях применимы в лексической области видимости макро определения. На самом деле это не правда --- \verb"defmacro!" предоставляет эти привязки под несколько отличающимся типом области видимости которая называется \emph{суб-лексической областью видимости (sub-lexical scope)}.

Помните, что область видимости обозначает корректность ссылок на переменную, а лексическая область видимости означает что имя применимо к коду в текстовом теле таких создающих привязки конструкций, как \verb"let". Важное различие между лексической областью видимости и суб-лексической областью видимости в том, что лексическая область видимости включает в себя все макрорасширения кода в теле \verb"let". Таким образом, высказывание о том, что лексическая область видимости --- это создание переменных, доступных только из кода в текстовом теле создающих привязки конструкций является ложным --- макросы могут \emph{инъецировать\index{свободная переменная!инъекция}} ссылки на переменные. Такие переменные инъецируются извне текстового тела конструкций, создающих привязки.

Реализация уникальной текстовой области видимости с ограничением на возможные способы доступа к лексическим переменным равняется суб-лексической области видимости. Ссылки на переменные в суб-лексической области видимости действительны только если представляющие их символы присутствуют в сырых списках, переданных лиспу до макро-расширения.

Поскольку \verb"defmacro!" производит предварительную обработку полученного кода и создаёт списки всех G-bang символов до расширения кода, то отсюда следует что G-bang символы суб-лексически привязаны. Мы не можем написать макросы, инъецирующие G-bang символы в \verb"defmacro!" поскольку лексические привязки для G-bang символов никогда не создавались. Вот типичное применение суб-лексического G-bang символа:

\begin{verbatim}
CL-USER> (defmacro! junk ()
           `(let ((,g!var))
              ,g!var))
JUNK
\end{verbatim}

Оба G-bang символа были созданы в суб-лексической области видимости \verb"defmacro!", таким образом, расширение будет таким, каким мы его ожидали увидеть:

\begin{verbatim}
CL-USER> (macroexpand '(junk))
(LET ()
  (LET ((#:VAR1196))
    #:VAR1196))
T
\end{verbatim}

Однако, для того, чтобы изучить концепцию суб-лексической области видимости мы определим макрос, инъецирующий G-bang символ:

\begin{verbatim}
CL-USER> (defmacro injector-for-g!var ()
           ''g!var)
INJECTOR-FOR-G!VAR
\end{verbatim}

Теперь мы можем написать \verb"junk2". \verb"Junk2" идентичен \verb"junk" с тем исключением, что мы заменили наши G-bang символы макросом, который расширяется в G-bang символ:

\begin{verbatim}
CL-USER> (defmacro! junk2 ()
           `(let ((,(injector-for-g!var)))
              ,(injector-for-g!var)))
JUNK2
\end{verbatim}

Но поскольку G-band символы привязаны суб-лексически --- и поэтому не ищутся в макро расширениях форм --- то \verb"defmacro!" не конвертирует символы в автоматические \verb"gensym"-ы:

\begin{verbatim}
CL-USER> (macroexpand '(junk2))
(LET ()
  (LET ((G!VAR))
    G!VAR))
T
\end{verbatim}

И хотя вышеприведённый код по-прежнему функционален, указатели на переменные, находящиеся в суб-лексической области видимости могут вывести из строя выражения, в которых некоторые указатели ссылаются на переменные существующие в суб-лексической области видимости а другие --- нет:

\begin{verbatim}
CL-USER> (defmacro! junk3 ()
           `(let ((,g!var))
              ,(injector-for-g!var)))
JUNK3
CL-USER> (macroexpand '(junk3))
(LET ()
  (LET ((#:VAR1209))
    G!VAR))
T
\end{verbatim}

Суб-лексическая область видимости удивительно часто появляется в сложных макросах. Кроме \verb"defmacro!" можно привести по крайней мере один пример: макрос \verb"with-all-cxrs" из \emph{раздела Рекурсивные Решения} суб-лексически привязывает функции получения элементов списка. В результате работы суб-лексических привязок оказывается что к подобным привязкам невозможно сослаться из макро расширения. Иногда подобное ограничение полезно, иногда нет. В случае с \verb"with-all-cxrs" суб-лексичность может рассматриваться как нежелательный эффект. Когда наш метод получения доступа к элементу списка находится в суб-лексической области видимости \verb"with-all-cxrs" то проблем не возникает:

\begin{verbatim}
CL-USER> (with-all-cxrs
             (cadadadr nil))
NIL
\end{verbatim}

Кроме этого мы можем даже написать макросы, расширяющиеся в эти методы получения доступа, поскольку макро определения находятся в суб-лексической области видимости \verb"with-all-cxrs":

\begin{verbatim}
CL-USER> (with-all-cxrs
             (macrolet ((accessor (l)
                          `(cadadadr ,l)))
               (accessor nil)))
NIL
\end{verbatim}

Но, помните, что \verb"with-all-cxrs" привязывает функции получения доступа суб-лексически, поэтому мы не можем инъецировать макрос, в функцию получения доступа:

\begin{verbatim}
CL-USER> (macrolet ((accessor (l)
                      `(cadadadr ,l)))
           (with-all-cxrs
               (accessor nil)))
The function COMMON-LISP-USER::CADADADR is undefined.
\end{verbatim}

Теперь, когда мы знакомы с понятием \emph{анафор}\index{анафора} и увидели большое количество примеров сложных макросов --- включая и те, которые используют суб-лексическую область видимости --- мы можем обсудить интересный теоретический макрос: \verb"sublet". Этот макрос создаёт суб-лексические привязки кода, используя синтаксис, подобный синтаксису обычной \verb"let" формы. Обсуждение \verb"sublet" мы начнём также, как и обсуждения многих лисп макросов --- с утилиты.

\begin{figure}Листинг 6.14: LET-BINDING-TRANSFORM\label{listing_6.14}
\listbegin
\begin{verbatim}
(defun let-binding-transform (bs)
  (if bs
      (cons
       (cond ((symbolp (car bs))
              (list (car bs)))
             ((consp (car bs))
              (car bs))
             (t
              (error "Bad let bindings")))
       (let-binding-transform (cdr bs)))))
\end{verbatim}
\listend
\end{figure}

\verb"Let-binding-transform" --- это простая утилита, обрабатывающая случай когда \verb"let" форма привязывает единственный символ. В следующем примере \verb"a" нормализуется до \verb"(a)":

\begin{verbatim}
CL-USER> (let-binding-transform
          '(a (b) (c nil)))
((A) (B) (C NIL))
\end{verbatim}

Кроме того, \verb"sublet" использует утилиту \verb"tree-leaves" определённую нами в \emph{разделе Неявные Контексты}. Напомним, что макрос \verb"tree-leaves" получает три аргумента: произвольную списковую структуру, выражение, которое может использовать переменную \verb"x" для определения изменяемого листа и другое выражение, которое может использовать другую \verb"x" и определяющее на что должны быть изменены нужные листья.

Выбрав неявственность привязок \verb"x" с одним и тем же именем мы получили преимущества \emph{дуализма синтаксиса\index{двойственность синтаксиса}}. Если у нас не получается обычными способами выделить общий код в выражении, то иногда мы можем добиться сокращения кода воспользовавшись синтаксическим дуализмом. Определение \verb"sublet" использует считывающий макрос ссылающийся сам на себя, эти макросы описаны в \emph{разделе Циклические Выражения}. Особенно для таких концепций как функции получения доступа к элементам списка, которые могут меняться много раз в процессе написания кода, считывающие макросы позволяют нам работать только с одним-единственным отображением оператора получения доступа к элементу списка. Благодаря использованию \emph{неявственности (implicitisation)\index{неявенность}} с макросом \verb"tree-leaves", легко найти и понять дублирование кода.

\begin{figure}Листинг 6.15: SUBLET\label{listing_6.15}
\listbegin
\begin{verbatim}
(defmacro sublet (bindings% &rest body)
  (let ((bindings (let-binding-transform
                   bindings%)))
    (setq bindings
          (mapcar
           (lambda (x)
             (cons (gensym (symbol-name (car x))) x))
           bindings))
    `(let (,@(mapcar #'list
                     (mapcar #'car bindings)
                     (mapcar #'caddr bindings)))
       ,@(tree-leaves
          body
          #1=(member x bindings :key #'cadr)
          (caar #1#)))))
\end{verbatim}
\listend
\end{figure}

\verb"Sublet" получает форму, представляющую \verb"let" привязки и применяет нашу утилиту \verb"let-binding-transform", генерирующую в процессе новую списковую структуру. Далее происходит присоединение\footnote{Присоединяются, а не добавляются, поскольку в этом случае мы можем продолжать поддерживать привязки без значений по умолчанию, например \verb"(a)".} \verb"gensym"-а к каждой привязке с печатью соответствующего имени для имени привязки. \verb"Sublet" расширяется в \verb"let" форму, привязывающую \verb"gensym" символы к значениям, переданным в привязываемой форме, затем применяется \verb"tree-leaves" для замещения всех вхождений имён символов привязок в переданном коде на их соответствующие \verb"gensym"-ы. \verb"Sublet" не раскрывает никаких макросов и не разбирает никаких специальных форм в теле на предмет поиска вхождений этих имён символов привязок поскольку \verb"sublet" создаёт суб-лексические привязки. Например, если все ссылки на \verb"a" являются суб-лексическими, то они будут замещены на \verb"gensym"-ы:



\begin{verbatim}
CL-USER> (macroexpand
          '(sublet ((a 0))
            (list a)))
(LET ((#:A1214 0))
  (LIST #:A1214))
T
\end{verbatim}

Однако, поскольку суб-лексическая область видимости не предполагает расширения макросов, и само собой разумеется отсутствие интерпретации таких специальных форм как \verb"quote", то экземпляры символа \verb"a" не являющиеся ссылками на переменную также будут меняться:

\begin{verbatim}
CL-USER> (macroexpand
          '(sublet ((a 0))
            (list 'a)))
(LET ((#:A1215 0))
  (LIST '#:A1215))
T
\end{verbatim}

Суб-лексическая область видимости вступает в силу до того как списковая структура будет интерпретирована как лисп код вашим системным проходчиком-по-коду. Это важное наблюдение --- поскольку не все последствия этого явления исследованы до конца. Интерпретация кода \verb"sublet"-ом отличается от интерпретации проходчика-по-коду, осуществляемого COMMON LISP-ом.

Теперь мы стоим на одной из многих граней понимания макросов. Сколько разновидностей интересных типов областей видимости лежит между нераскрытой суб-лексической областью видимости и полностью раскрытой лексической областью видимости? Поскольку более лучшего названия я не подобрал, то мы будем называть эту бесконечно большую категорию областей видимости \emph{супер суб-лексическими областями видимости (super sub-lexical scopes)}\footnote{Я дал это глупое название по тому что ожидаю что по мере изучения этой концепции появятся более лучшие имена, глубже отображающие суть явления.}.



Весьма очевидно, что супер суб-лексическая область видимости использует \verb"sublet*". Этот макрос основан на \verb"sublet" но изменяет каждую форму в теле осуществляя макрорасширение этих форм с помощью функции \verb"macroexpand-1". Теперь вместо появления в сырой списковой структуре ссылки на символы должны появляться после первого шага макро расширения. Этот тип супер суб-лексической области видимости позволяет макросам инъецировать или удалять ссылки из области видимости внутри тела \verb"let" формы. Если макросы не выполняют эти операции --- или если формы вовсе не являются макросами --- то этот тип супер суб-лексической области видимости работает также, как и суб-лексическая область видимости:

\begin{verbatim}
CL-USER> (macroexpand
          '(sublet* ((a 0))
            (list a)))
(LET ((#:A1216 0))
  (LIST #:A1216))
T
\end{verbatim}

\begin{figure}Листинг 6.16: SUBLET*\label{listing_6.16}
\listbegin
\begin{verbatim}
(defmacro sublet* (bindings &rest body)
  `(sublet ,bindings
           ,@(mapcar #'macroexpand-1 body)))
\end{verbatim}
\listend
\end{figure}

Но мы можем определить другой макрос-инъектор для проверки этой супер суб-лексической области видимости:

\begin{verbatim}
CL-USER> (defmacro injector-for-a ()
           'a)
INJECTOR-FOR-A
\end{verbatim}

\verb"Sublet*" раскроет этот макрос-инъектор:

\begin{verbatim}
CL-USER> (macroexpand-1
          '(sublet* ((a 0))
            (injector-for-a)))
(SUBLET ((A 0)) A)
T
\end{verbatim}

Что в свою очередь будет суб-лексически интерпретироваться \verb"sublet"-ом, обозначая присутствие инъецированной переменной внутри супер суб-лексической области видимости предоставляемой \verb"sublet*"-ом:

\begin{verbatim}
CL-USER> (macroexpand-1 *)
(LET ((#:A1221 0))
  #:A1221)
T
\end{verbatim}

Но вложенные макросы в выражении не раскрываются через \textbf{mac\-ro\-ex\-pand-1} поэтому \verb"sublet*" не вставляет их в суб-лексическую область видимости \verb"sublet":

\begin{verbatim}
CL-USER> (macroexpand-1
          '(sublet* ((a 0))
            (list (injector-for-a))))
(SUBLET ((A 0)) (LIST (INJECTOR-FOR-A)))
T
\end{verbatim}

Поэтому \verb"a" не захватывается суб-лексически\footnote{\verb"Walker:macroexpand-all" --- это компонент CMUCL и представляет собой завершённый проходчик-по-коду.}:



\begin{verbatim}
* (walker:macroexpand-all *)
(LET ((#:A1666 0))
     (LIST A))
\end{verbatim}

С помощью \verb"sublet" и \verb"sublet*" мы можем, используя суб-лексические или супер суб-лексические области видимости, произвольно контролировать на каком уровне макро расширения переменная \verb"a" будет рассматриваться как корректная. Как замечено выше супер суб-лексическая область видимости это почти полностью не исследованный бесконечный класс областей видимости. Способов прохода по коду --- большое множество, существует такое же количество множеств супер суб-лексических областей видимости. Этот класс областей видимости подводит нас к другой категории почти неисследованных макросов: макросы, изменяющие работу лисп макросов. Эти макросы способны определять когда следует раскрывать макрос, где ссылки на переменные являются корректными, как интерпретировать специальные формы и т.д. То есть, мы получаем макро-программируемый раскрыватель макросов.

\section{Пандорические Макросы}\label{section_pandoric_macros}



\emph{Ящик Пандоры (Pandora's box)\index{ящик Пандоры}} --- это греческий миф о первой в мире женщине: Пандоре. Пандора, символ U-Языка переводится с греческого как "всем одарённая". Снедаемая любопытством Пандора открыла маленький ящик и тем самым безвозвратно выпустила на весь мир всё человеческое зло и грехи. Макросы, описанные в этом разделе являются очень мощными и они должны научить вас такому способу программирования, который вы никогда не забудете, и будьте уверены, что получившийся результат будет куда более лучшим чем то, что получила бедная Пандора. Откроем ящик.

Для начала мы отойдём от нашего повествования и ознакомимся с другой знаменитой книгой, посвящённой лиспу: \emph{Lisp in Small Pieces\index{Lisp in Small Pieces}} [SMALL-PIECES] за авторством Кристиана Кеннека (\foreignlanguage{english}{Christian Queinnec}). Кеннек --- это широко известный и уважаемый лисп эксперт и он внёс большой вклад в понимание лиспа. Книга Кеннека рассказывает о реализации различной сложности компиляторов и интерпретаторов в и для языка программирования Scheme\footnote{Иногда через него описываются другие лиспы и их особенности.}.

 

В \emph{Lisp in Small Pieces} есть короткая, но очень интересная дискуссия о макросах. Большая часть посвящена описанию различных вариаций макро системы возможной благодаря неоднозначности макро спецификации Scheme\footnote{Спасибо, не надо.}, но, кроме того, есть несколько интересных заметок о причинах использования макросов и способах их использования. Если вы прочитали и поняли \emph{главу Основы Макросов}, то большинство макросов описанных в главе о макросах в \emph{Lisp in Small Pieces}, для вас будут тривиальными, но, существует один интересный макрос, который нам стоит рассмотреть подробнее.



Как и многие книги, посвящённые программированию, \emph{Lisp in Small Pieces} переносит и оставляет нас на реализации системы \emph{объект\-но-ориен\-ти\-ро\-ван\-но\-го\index{объектно-ориентированное}} программирования. Обычно эти реализации служат примером подмножества CLOS\index{CLOS}, Объектной Системы COMMON LISP. Кеннек называет это подмножество \emph{MEROONET\index{MEROONET}}. Кеннек отмечает, что при определении методов для MEROONET класса было бы хорошо иметь возможность прямо ссылаться к полям определяемого объекта вместо использования получателей доступа. Слова Кеннека (переведено) [SMALL-PIECES-P340-341]:

\begin{quote}Возьмём, к примеру, макрос \verb"with-slots" из CLOS; мы адаптируем его к контексту MEROONET. Поля объекта --- пусть это будут поля экземпляра \verb"Point" --- обрабатываются с помощью чтения и записи через такие функции, как \verb"Point-x" или \verb"set-Point-y!". Будет гораздо проще взаимодействовать с ними по имени их полей, \verb"x" или \verb"y", например в контексте определения метода.\end{quote}

Ниже представлен пример желаемого Кеннеком интерфейса (который он назвал \verb"define-handy-method"), определяющий новый метод \foreignlanguage{english}{\textbf{double}}:

\begin{verbatim}
(define-handy-method (double (o Point))
  (set! x (* 2 x))
  (set! y (* 2 y))
  o )
\end{verbatim}

Этот подход более удобен программистам нежели MEROONET синтаксис:

\begin{verbatim}
(define-method (double (o Point))
  (set-Point-x! o (* 2 (Point-x o)))
  (set-Point-y! o (* 2 (Point-y o)))
  o )
\end{verbatim}

Другими словами: было бы неплохо использовать макросы для получения доступа к сторонним привязкам --- в данном случае к слотам объекта --- как если бы они были лексическими привязками. И хотя такой подход чрезвычайно удобен в целях сокращения кода, его главное следствие --- это способность дать нам \emph{дуализм синтаксиса\index{двойственность синтаксиса}} для уже существующих и будущих макросов.

Как замечает Кеннек, COMMON LISP реализует эту функциональность для CLOS с помощью макроса под названием \verb"with-slots". Это COMMON LISP-овский пример выполнения того, что было спроектировано: создание абстракций на базе чистой, стандартизированной макро системы. В то время, когда большинство языков спроектированы для того, чтобы быть элегантными, COMMON LISP спроектирован для того, чтобы быть мощным для программирования. Кеннек пришёл к выводу, что ограничения языка делают невозможным подобные ухищрения в Scheme, особенно там, где необходима переносимость:

\begin{figure}Листинг 6.17: PANDORICLET\label{listing_6.17}
\listbegin
\begin{verbatim}
(defmacro pandoriclet (letargs &rest body)
  (let ((letargs (cons
                  '(this)
                  (let-binding-transform
                   letargs))))
    `(let (,@letargs)
       (setq this ,@(last body))
       ,@(butlast body)
       (dlambda
        (:pandoric-get (sym)
                       ,(pandoriclet-get letargs))
        (:pandoric-set (sym val)
                       ,(pandoriclet-set letargs))
        (t (&rest args)
           (apply this args))))))
\end{verbatim}
\listend
\end{figure}

\begin{quote}Из-за отсутствия информации о языке и его реализациях мы не можем написать переносимый проходчик-по-коду в Scheme, поэтому нам пришлось отказаться от написания \textbf{de\-fine\--\-han\-dy\--\-me\-thod}.\end{quote}

Хотя COMMON LISP предоставляет большое количество корректных способов реализации макро систем, он спроектирован с учётом поддержки универсальных инструментов мета-программирования, которые способны работать как в стандартном, так и в переносимом режимах. Существует две мощных макро особенности COMMON LISP-а, позволяющих реализовывать такую функциональность как CLOS-овское \verb"with-slots", --- это \emph{обобщённые переменные (generalised variables)\index{обобщённый!переменные}} и \emph{символьные макросы (symbol macros)\index{макрос!символьный}}. В этом разделе мы покажем вам слияние возможностей COMMON LISP-а и к какому замечательному результату это приведёт, кроме того, мы объединим воедино всё что мы уже узнали в отношении анафорических макросов и в процессе мы откроем интересный класс макросов под названием \emph{пандорические макросы (pandoric macros)\index{макрос!пандорический}}.

Идея лежащая в основе \verb"pandoriclet" --- это \emph{открытые замыкания\index{открытые замыкания}}, дающие возможность доступа извне к их перекрытым лексическим переменным. Также как и предыдущие макросы, такие как \verb"alet-hotpatch", \verb"pandoriclet" компилируется в косвенную среду, которая по разному реагирует на различные переданные аргументы.

Мы опять начали с \emph{изнанки расширения\index{макрос!выворачивание наизнанку}} \verb"alet", не забывая о присутствии анафоры под названием \verb"this". \verb"Pandoriclet" похож на уже виденные нами остальные макросы. Как и все наши анафорические варианты \verb"let", мы предполагаем что финальной формой тела \verb"pandoriclet" будет лямбда форма. Как и \verb"alet-hotpatch" \verb"pandoriclet" использует макрос \verb"dlambda" для осуществления диспетчеризации между различными возможными участками исполняемого кода при возвращении замыкания из вызова \verb"pandoriclet". \verb"Pandoriclet" использует утилиту \verb"let-binding-transform", представленную в предыдущем разделе для работы с \verb"null" привязками --- такими как \verb"(let (a) ...)". Эта функция утилита необходима для \verb"pandoriclet" по той же причине, по которой она была необходима для \verb"sublet": эти макросы осуществляют проход-по-коду переданных привязок \verb"let", в то время как предыдущие макросы слепо сращивались с привязками в другой \verb"let".

У нас присутствует два вызова списко-создающих функций утилит, которые ещё не были определены: \verb"pandoriclet-get" и \verb"pandoriclet-set", каждая из которых получает список \verb"let" привязок. Мы можем ссылаться на ещё не определённые функции до расширения макроса что, очевидно, не произойдёт до тех пор, пока мы не используем макрос. Использование вспомогательных функций, облегчающих определение макросов --- это хорошая привычка и эту привычку можно взять на вооружение. Она может не только улучшить читабельность ваших определений, но также может помочь при тестировании компонентов макроса и доказать пригодность использования в будущих макросах. Наиболее примечательная черта такой разновидности абстракций в том, что при комбинировании макросов мы продолжаем поддерживать доступность лексического контекста для остальных используемых утилит.

Поэтому мы написали \verb"pandoriclet-get" и \verb"pandoriclet-set" с учётом лексического контекста. \verb"Pandoriclet-get" мы написали с учётом того, что \verb"dlambda" привязывает переменную \verb"sym" к сращиванию нашего списка. Дальше \verb"case" форма производит сравнение \verb"sym" с символами, переданными в \verb"pandoriclet"\footnote{Напомним, что \verb"case" с символами компилируется в сравнение с одним указателем для каждого \verb"case" случая.}. Если мы найдём символ, то будет возвращено значение на которое ссылается привязка. Если нет, то будет сгенерирована ошибка. \verb"Pandoriclet-set" похож на \verb"pandoriclet-get", с той разницой, что \verb"dlambda" привязывает ещё один используемый символ: \verb"val". \verb"Pandoriclet-set" использует \verb"setq" для изменения привязок в зависимости от \verb"sym" на \verb"val".



\begin{figure}Листинг 6.18: PANDORICLET-ACCESSORS\label{listing_6.18}
\listbegin
\begin{verbatim}
(defun pandoriclet-get (letargs)
  `(case sym
     ,@(mapcar #`((,(car a1)) ,(car a1))
               letargs)
     (t (error
         "Unknown pandoric get: ~a"
         sym))))

(defun pandoriclet-set (letargs)
  `(case sym
     ,@(mapcar #`((,(car a1))
                  (setq ,(car a1) val))
               letargs)
     (t (error
         "Unknown pandoric set: ~a"
         sym val))))
\end{verbatim}
\listend
\end{figure}

\verb"Pandoriclet" предоставляет тот-же интерфейс, что и все наши анафорические реализации \verb"let", поэтому мы можем использовать его для создания простого замыкания-счётчика:

\begin{verbatim}
CL-USER> (setf (symbol-function 'pantest)
	       (pandoriclet ((acc 0))
			    (lambda (n) (incf acc n))))
#<CLOSURE (LAMBDA (&REST #:ARGS2)) {C452955}>
\end{verbatim}
\footnote{Примечание переводчика: При вычислении этого выражения выводится такое предупреждение о стиле:

\verb"; "

\verb"; caught STYLE-WARNING:"

\verb";   Too many arguments (2) to ERROR "Unknown pandoric set: ~a": uses at most 1."

\verb";   See also:"

\verb";     The ANSI Standard, Section 22.3.10.2"

\verb"; "

\verb"; compilation unit finished"

\verb";   caught 1 STYLE-WARNING condition"


}

Что работает так, как и задумывалось:

\begin{verbatim}
CL-USER> (pantest 3)
3
CL-USER> (pantest 5)
8
\end{verbatim}

Однако, сейчас у нас есть прямой доступ к привязке под названием \verb"acc", с помощью которого было создано замыкание:

\begin{verbatim}
CL-USER> (pantest :pandoric-get 'acc)
8
\end{verbatim}

И мы можем также просто поменять значение этой привязки:

\begin{verbatim}
CL-USER> (pantest :pandoric-set 'acc 100)
100
CL-USER> (pantest 3)
103
\end{verbatim}

Здесь доступно даже значение анафоры \verb"this", поскольку мы преднамеренно оставили анафору открытой и добавили символ \verb"this" в список привязок \verb"letargs" при раскрытии макроса:

\begin{verbatim}
CL-USER> (pantest :pandoric-get 'this)
#<CLOSURE (LAMBDA (N)) {C452945}>
\end{verbatim}

Поэтому это замыкание, которое мы создали с помощью \verb"pandoriclet", --- больше не является закрытым. Среда используемая этим замыканием --- даже если все лексические символы значений были удалены компилятором --- по прежнему доступны через нашу анонимную функцию, возвращённую от \verb"pandoriclet". Как это работает? В случае с пандорическими макросами дополнительный код компилируется так, чтобы предоставить способ получения доступа к замыканию снаружи. Но мощь пандорических макросов невозможно понять изучая низкоуровневую картину происходящего. То что мы создали называется \emph{протоколом взаимодействия замыканий (inter-closure protocol)\index{протокол взаимодействия замыканий}} или системой передачи сообщений, предназначенной для коммуникации между замыканиями.

Прежде чем мы продолжим изучение пандорических макросов, мы должны уделить внимание одной из наиболее важных примеров \emph{двойственности синтаксиса\index{двойственность синтаксиса}} в COMMON LISP: \emph{обобщённым переменным\index{обобщённый!переменные}}. Детали обобщённых переменных сложны и я бы не хотел описывать их все здесь. Для этого я рекомендую книгу Грэма \emph{On Lisp} --- лучшую книгу, посвящённую разбору этой темы. В конечном счёте всё сводится к простой идее: доступ к обобщённой переменной синтаксически двойственен установлению её значения. У вас есть только одна, устанавливающая значения форма, \verb"setf", которая может устанавливать все типы переменных используя тот же синтаксис, который вы используете для получения доступа к ним.

\begin{figure}Листинг 6.19: GET-PANDORIC\label{listing_6.19}
\listbegin
\begin{verbatim}
(declaim (inline get-pandoric))

(defun get-pandoric (box sym)
  (funcall box :pandoric-get sym))

(defsetf get-pandoric (box sym) (val)
  `(progn
     (funcall ,box :pandoric-set ,sym ,val)
     ,val))
\end{verbatim}
\listend
\end{figure}

Например, при работе с обычной переменной вы традиционно получаете её значение через её символ, к примеру, \verb"x". Для присваивания какого либо значения вы можете использовать \verb"(setf x 5)". Аналогично, для получения доступа к \verb"car" слоту \verb"cons" ячейки с названием, скажем, \verb"x" вы используете \verb"(car x)". Для присвоения значения вы можете использовать форму \verb"(setf (car x) 5)". Такой способ скрывает тот факт, что правильный способ изменить данные \verb"cons" ячейки --- это использование функции \verb"rplaca". Реализовав подобную двойственность синтаксиса мы сократили более чем половину операторов получения доступа/присваивания значений и теперь нет нужды их всех запоминать, и что ещё более важно, у нас появляются новые способы использования макросов.

Функция \verb"get-pandoric" --- это обёртка вокруг получения синтаксиса протокола взаимодействия замыканий. Она объявлена встраиваемой для того, чтобы устранить любые влияния на производительность, которые может оказывать эта обёртка.

\verb"Defsetf" --- это интересный COMMON LISP макрос, в отличие от нашего \verb"defmacro!", который расширяется в \verb"defmacro" и неявно привязывает \verb"gensym"-ы вокруг переданной формы. \verb"Defsetf" прекрасно работает для определения присваивающей стороны обобщённой переменной если присваиватель можно выразить как функцию или макрос, который вычисляет все свои аргументы только один раз. \verb"Get-pandoric" можно было бы определить как макрос, но мы этого не сделали из-за встраивания. Макросы не для встраивания, компиляторы для встраивания.

Вернёмся к нашему пандорическому счётчику, сохранённому в символ-функцию \verb"pantest", мы можем использовать эту новую функ\-цию-по\-лу\-ча\-тель для получения текущего значения \verb"pantest"-овской привязки \verb"acc":

\begin{verbatim}
CL-USER> (get-pandoric #'pantest 'acc)
103
\end{verbatim}

Теперь благодаря обобщённым переменным и \verb"defsetf" мы можем использовать синтаксический дуализм и поменять значение переменной:

\begin{verbatim}
CL-USER> (setf (get-pandoric #'pantest 'acc) -10)
-10
CL-USER> (pantest 3)
-7
\end{verbatim}

Среды над функциями --- вот что подразумевает \verb"let" в \emph{let, окружающий lambda\index{let, окружающий lambda}}, --- начинают выглядеть как просто обобщённые переменные с несложным доступом, такие как \verb"cons" ячейка или элемент хэш таблицы. Замыкания стали ещё более \emph{первоклассными\index{первоклассный}} структурами данных чем в начале. Привязки которые были в начале закрыты для внешнего кода теперь широко доступны для разнообразных операций, даже если эти привязки были скомпилированы для чего-то другого и имеют забытые символы доступа.

Но, любая дискуссия о обобщённой переменной будет неполной без упоминания её ближайшего родственника: \emph{символьного макроса (symbol macros)\index{макрос!символьный}}. \verb"Symbol-macrolet", как следует из названия, позволяет нам расширять символы в общие лисп формы. Поскольку интуитивной и наиболее гибкой в использовании формой, представляющей макро трансформации\footnote{Символьные макросы не получают аргументов, поэтому определение символьного макроса всегда расширяется в самого себя.}, является рассмотрение формы как функции, то \textbf{sym\-bol\--\-mac\-ro\-let} главным образом предназначен для одной цели: символьные макросы дают нам возможность скрывать обобщённые переменные таким образом, что пользователи макроса будут считать что получают доступ к обычным лексическим переменным.

Введение символьных макросов привело к появлению одного из наиболее странных \emph{костылей (kludges)\index{костыль}} в языке COMMON LISP: обычно при присваивании значения переменной через обычный символ, например \verb"(setf x t)", \verb"setf" будет расширяться в форму \verb"setq", поскольку это именно то, для чего и был предназначен \verb"setq": присваивание значений лексическим и динамическим переменным (на которые всегда будут ссылаться по символам). Поскольку специальная форма \verb"setq" не может присваивать значения обобщённым переменным, но, при введении символьных макросов стало возможным выражать с помощью символов не только лексические/динамические привязки, но и любые обобщённые переменные, и тут появилась необходимость в конвертации \verb"setq" форм обратно в \verb"setf" формы. Как это ни странно, но это было \emph{правильным} решением, поскольку такой подход позволяет макросам полностью скрывать присутствие обобщённых переменных от пользователя макроса, даже если он решит использовать \verb"setq". По \emph{настоящему правильным} решением было бы удаление избыточной \verb"setq" из языка в пользу более универсального \verb"setf", но, это не произойдёт во-первых, по очевидным причинам совместимости, а во-вторых, поскольку при создании макроса \verb"setq" можно использовать в целях безопасности --- \verb"setf" плюс проверка на то что символ был сращен и не представляет списковую форму. При использовании \verb"setq" помните что он полезен только для обеспечения безопасности сращивания; как мы уже видели, благодаря \verb"symbol-macrolet" символ может ссылаться на любую обобщённую переменную.

\begin{figure}Листинг 6.20: WITH-PANDORIC\label{listing_6.20}
\listbegin
\begin{verbatim}
(defmacro! with-pandoric (syms o!box &rest body)
  `(symbol-macrolet
       (,@(mapcar #`(,a1 (get-pandoric ,g!box ',a1))
                  syms))
     ,@body))
\end{verbatim}
\listend
\end{figure}

Макрос \verb"with-pandoric" расширяется в \verb"symbol-macrolet", определяющий символьные макросы для каждого символа содержащегося в \verb"syms". Каждый символьный макрос будет расширять ссылки на его символ в лексическую область видимости \verb"symbol-macrolet" в ссылки обобщённой переменной используя \verb"get-pandoric" для получения доступа к результатам вычисления второго аргумента макроса: \verb"o!box" (сохраняется в \verb"g!box").

Таким образом \verb"with-pandoric" позволяет нам заглянуть в привязку переменных, через закрывающее их замыкание:

\begin{verbatim}
CL-USER> (with-pandoric (acc) #'pantest
                        (format t "Value of acc: ~a~%" acc))
Value of acc: -7
NIL
\end{verbatim}

Поскольку в нашей архитектуре используются обобщённые переменные для формирования синтаксической двойственности, дающее нам возможность получения и присваивания значений, то мы можем считать что имеем дело с обычной лексической переменной и присваивать ей значения с помощью \verb"setq":

\begin{verbatim}
CL-USER> (with-pandoric (acc) #'pantest
                        (setq acc 5))
5
CL-USER> (pantest 1)
6
\end{verbatim}

Мы только что познакомились с основными составными частями пандорических макросов. Первое --- макрос, создающий замыкания: \foreignlanguage{english}{\textbf{pandoriclet}}, захватывающий анафору \verb"this", ссылающуюся на функцию, использованную при вызове замыкания. Этот макрос компилируется в некоторый специальный код, который перехватывает определённые вызовы этого замыкания и получает доступ или модифицирует его перекрытые лексические переменные. Второе --- единый синтаксис и для получения доступа и для присваивания нового значения реализованный с помощью \verb"get-pandoric" и \verb"defsetf". И, наконец, макрос \verb"with-pandoric" использующий \verb"symbol-macrolet" для закладки обобщённых переменных выглядящих как новые лексические переменные с теми же именами что и перекрытые переменные. Эти переменные ссылаются на исходную среду, созданную с помощью \verb"pandoriclet", но из отдельных лексических контекстов.

В качестве примера мы используем эту способность открывать замыкания и сравним их с макросами \emph{горячей замены\index{горячая замена}} из \emph{раздела Замыкания, Поддерживающие Горячую Замену}. Напомним, что \verb"alet-hotpatch" и его близкий анафорический двоюродный брат \verb"let-hotpatch" создают замыкания с косвенной средой, таким образом функции, вызываемые при вызове замыкания могут изменяться на лету. Главное ограничение связанное с этими макросами заключается в том, что они принуждают вас выбрасывать все лексические привязки, перекрывающиеся предыдущей анонимной функцией при её горячей замене. Это было неизбежно поскольку во время написания этих макросов замыкания были закрыты для нас.

\begin{figure}Листинг 6.21: PANDORIC-HOTPATCH\label{listing_6.21}
\listbegin
\begin{verbatim}
(defun pandoric-hotpatch (box new)
  (with-pandoric (this) box
                 (setq this new)))
\end{verbatim}
\listend
\end{figure}

При работе с \verb"alet-hotpatch" и \verb"let-hotpatch" мы должны были компилировать код специального назначения для каждого замыкания, которое было способно присвоить анафорической лексической привязке \verb"this" новое значение. Но поскольку мы можем открыть замыкание определённое с \verb"pandoriclet" и запустить внешний присваивающий код, то теперь возможно определить функцию горячей замены \verb"pandoric-hotpatch", которая способная работать с любыми пандорическими замыканиями.

Иногда абстракции лишь кажутся правильными и трудно сказать почему. Возможно, поскольку в большинстве случаев программирование --- это негармоничная комбинация несовместимых частей, и удивительно и приятно обнаружить абстракции, которые --- как бы случайно --- замечательно комбинируются вместе. \verb"Pandoric-hotpatch" работает также, как и читается: открывает пандорический интерфейс, получает переменную \verb"this" из лексической области замыкания \verb"box" и затем использует \verb"setq" для присваивания \verb"this" нового заменяющего замыкания, \verb"new".

Мы можем применить \verb"pandoric-hotpatch" на пандорических замыканиях которые мы создали ещё до того как задумались о горячей замене. Помните замыкание-счётчик с которым мы упражнялись на протяжении этого раздела? Это замыкание должно быть по прежнему привязано к \verb"symbol-function" символа \verb"pantest". Счётчик был установлен в 6:

\begin{verbatim}
CL-USER> (pantest 0)
6
\end{verbatim}

Давайте внедрим новое замыкание --- такое, которое имеет новую привязку к \verb"acc" начинающуюся со 100 и является уменьшающимся:

\begin{verbatim}
CL-USER> (pandoric-hotpatch #'pantest
                            (let ((acc 100))
                              (lambda (n) (decf acc n))))
#<CLOSURE (LAMBDA (N)) {C67F6ED}>
\end{verbatim}

\begin{figure}Листинг 6.22: PANDORIC-RECODE\label{listing_6.22}
\listbegin
\begin{verbatim}
(defmacro pandoric-recode (vars box new)
  `(with-pandoric (this ,@vars) ,box
                  (setq this ,new)))
\end{verbatim}
\listend
\end{figure}

Для того, чтобы убедиться, что горячая замена прошла хорошо:

\begin{verbatim}
CL-USER> (pantest 3)
97
\end{verbatim}

Итак, наше замыкание-счётчик обладает новым значением, привязанным к \verb"this", которое используется для осуществления подсчёта. Однако, изменяет ли данная горячая замена пандорическое значение привязки \verb"acc"?

\begin{verbatim}
CL-USER> (with-pandoric (acc) #'pantest
                        acc)
6
\end{verbatim}

Нет. \verb"Acc" по прежнему равен предыдущему значению, 6, происходит это по той причине, что мы меняем только одну привязку \verb"this" в пандорическом окружении, а \verb"this" меняется только на новое замыкание в его собственной привязке \verb"acc".

Макрос \verb"pandoric-recode" применяет несколько другой подход реализации горячей замены. Он сохраняет исходную лексическую среду кода и в то же время продолжает управлять изменением функции, исполняемой при вызове замыкания и компилируется извне. Звучит слишком хорошо, чтобы быть правдой? Вспомните, что текущее значение \verb"acc" равняется 6 в исходной пандорической среде, и мы можем использовать \verb"pandoric-recode" для размещения новой функции, использующей исходное значение и, скажем, уменьшать счётчик на половину от переданного значения \verb"n":

\begin{figure}Листинг 6.23: PLAMBDA\label{listing_6.23}
\listbegin
\begin{verbatim}
(defmacro plambda (largs pargs &rest body)
  (let ((pargs (mapcar #'list pargs)))
    `(let (this self)
       (setq
        this (lambda ,largs ,@body)
        self (dlambda
              (:pandoric-get (sym)
                             ,(pandoriclet-get pargs))
              (:pandoric-set (sym val)
                             ,(pandoriclet-set pargs))
              (t (&rest args)
                 (apply this args)))))))
\end{verbatim}
\listend
\end{figure}

\begin{verbatim}
CL-USER> (pandoric-recode (acc) #'pantest
                          (lambda (n)
                            (decf acc (/ n 2))))
#<CLOSURE (LAMBDA (N)) {B186EB5}>
\end{verbatim}

Убедимся в том, что у нас есть новое поведение, которое уменьшит \verb"acc" на \verb"(* 1/2 2)" с 6 до 5:

\begin{verbatim}
CL-USER> (pantest 2)
5
\end{verbatim}

И связано ли это значение с исходной пандорической привязкой?

\begin{verbatim}
CL-USER> (with-pandoric (acc) #'pantest
                        acc)
5
\end{verbatim}

Да. Как работает \verb"pandoric-recode"? Этот макрос перекрывает переданную лямбда форму пандорически открытыми привязками исходного замыкания.

Макрос, который мы до сих пор использовали для создания пандорических замыканий называется \verb"pandoriclet". \verb"Plambda" --- это переписанная изнанка \verb"pandoriclet" добавляющая несколько важных особенностей. Первое и самое главное --- \verb"plambda" не создаёт \verb"let" среды используемые в наших пандорических методах доступа. Вместо этого \verb"plambda" получает список символов ссылающихся на переменные, наличие которых подразумевается в лексической среде вызывателя макроса. \verb"Plambda" может \emph{экспортировать\index{экспортирование закрытых привязок}} любые переменные в вашу лексическую среду, делая их прозрачно доступными для других лексических областей видимости --- даже если они были написаны и скомпилированы до или после формы \verb"plambda".

Это следующее улучшение нашей системы замыканий \emph{let, окружающий lambda\index{let, окружающий lambda}\index{замыкание|see{let, окружающий lambda}}}, спроектированное с упором на максимальное усиление синтаксической двойственности. Благодаря пандорическим макросам, наиболее важными из которых являются \verb"plambda" и \verb"with-pandoric", мы можем при желании легко и просто выйти за границы лексической области видимости. Замыкания больше не закрыты; мы можем открыть замыкания также легко, как и переписать наши лямбда формы в \verb"plambda" формы. Мы используем \verb"plambda" для экспорта лексических переменных и \verb"with-pandoric" для их импорта, в результате чего они становятся полностью эквивалентными лексическим переменным. На самом деле эти новые переменные настолько эквиваленты, что их уже нельзя рассматривать как новые переменные. Лучший способ думать о пандорических переменных --- это просто считать их расширением исходной лексической области видимости. Простой пример использования \verb"plambda" --- это пандорический счётчик, экспортирующий переменные из двух потенциально различных лексических сред:

\begin{verbatim}
CL-USER> (setf (symbol-function 'pantest)
               (let ((a 0))
                 (let ((b 1))
                   (plambda (n) (a b)
                            (incf a n)
                            (setq b (* b n))))))
#<CLOSURE (LAMBDA (&REST #:ARGS2)) {B529715}>
\end{verbatim}

Заметьте, насколько легко было экспортировать эти лексические указатели. Создание пандорического замыкания также легко как и добавление символа \verb"p" перед \verb"lambda" и добавление списка экспортируемых переменных после лямбда аргументов. Мы можем открыть это замыкание --- и любое пандорическое замыкание, которое экспортирует символы \verb"a" и \verb"b" --- используя \verb"with-pandoric":

\begin{figure}Листинг 6.24: MAKE-STATS-COUNTER\label{listing_6.24}
\listbegin
\begin{verbatim}
(defun make-stats-counter
    (&key (count 0)
     (sum 0)
     (sum-of-squares 0))
  (plambda (n) (sum count sum-of-squares)
           (incf sum-of-squares (expt n 2))
           (incf sum n)
           (incf count)))
\end{verbatim}
\listend
\end{figure}

\begin{verbatim}
CL-USER> (defun pantest-peek ()
           (with-pandoric (a b) #'pantest
                          (format t "a=~a, b=~a~%" a b)))
PANTEST-PEEK
CL-USER> (pantest-peek)
a=0, b=1
NIL
\end{verbatim}

\verb"Plambda" является примером того, насколько полезным может быть исключение общих компонентов макро расширений. Помните, когда мы писали \verb"pandoriclet" мы решили переместить создание \verb"case" условий для кода выполняющего получение доступа на функцию \verb"pandoriclet-get", а код, отвечающий за присваивание на \verb"pandoriclet-set"? \verb"Plambda" использует эти же функции. Даже если эти макросы сращивают результаты этих функций в абсолютно других лексических контекстах, но поскольку макросы написаны с соблюдением того же соглашения именования и протокола взаимодействия замыканий, то этот код пригоден к комбинированию с другим кодом.

Итак, пандорические макросы разрушают лексические границы. Они позволяют вам открывать замыкания по первому желанию и представляют прекрасное слияние различных особенностей языка COMMON LISP: анафорические макросы, обобщённые переменные и символьные макросы. Но какую пользу можно извлечь из них?

Пандорические макросы важны по той причине, что они дают нам все основные преимущества таких объектных систем как CLOS не требуя от нас отказа от более естественного стиля программирования, основанного на комбинациях \verb"let-lambda". В частности мы можем добавлять функциональность или \emph{методы\index{методы}} для замыканий без необходимости создавать экземпляры экземпляров уже созданных объектов.

\begin{figure}Листинг 6.25: DEFPAN\label{listing_6.25}
\listbegin
\begin{verbatim}
(defmacro defpan (name args &rest body)
  `(defun ,name (self)
     ,(if args
          `(with-pandoric ,args self
                          ,@body)
          `(progn ,@body))))
\end{verbatim}
\listend
\end{figure}

\verb"Make-stats-counter" --- это \emph{lambda, окружающая let, окружающий {p\-lamb\-da}}, предназначенная для создания счётчиков, содержащих три единицы информации. В дополнение к сумме (\verb"sum"), есть сумма квадратов (\verb"sum-of-squares") и число обработанных шагов (\verb"count"). Если бы мы использовали \verb"lambda" вместо \verb"plambda" в определении \verb"make-stats-counter", то большинство этой информации не было бы нам доступно. Мы находились бы снаружи и эти переменные были бы закрыты для нас.

Как мы напишем пандорические методы? Мы можем просто получить доступ к переменным используя \verb"with-pandoric" так, как это было показано выше, или, поскольку это лисп, спроектировать более узкоспециализированный интерфейс.

\verb"Defpan" --- это \emph{комбинация\index{макрос!комбинации}} \verb"defun" и макроса \verb"with-pandoric". Главная цель \verb"defpan" --- это реализация \emph{двойственности синтаксиса\index{двойственность синтаксиса}} между функцией, написанной с помощью \verb"defun" и доступом к сторонней лексической области видимости с помощью \verb"with-pandoric". И хотя мы передаём аргументы \verb"defpan" в том же синтаксисе что и в лямбда формах --- список символов --- аргументы \verb"defpan" обозначают нечто другое. Вместо создания новой лексической среды эти \emph{пандорические функции} расширяют лексическую среду пандорических замыканий к которым они применяются. В случае с \verb"defun" и обычными лямбда формами имя (символ) которое вы даёте переменной не играет важной роли. В случае с пандорическими функциями имя --- это всё. Кроме того, в случае с пандорическими функциями порядок аргументов не имеет значения и количество используемых экспортируемых лексических переменных зависит от вашего желания.

Кроме того \verb"defpan" предоставляет анафору под названием \verb"self", которая позволяет нам применять технику под названием \emph{анафорическая очередизация}\index{анафора!очередизация}. Невидимо передавая значение \verb"self" между пандорическими функциями мы можем управлять значением этой анафоры с помощью очередей из вызовов функций. Как и со всеми конструкциями очередей, убедитесь что очередь не заканчивается бесконечным циклом.

\begin{figure}Листинг 6.26: STATS-COUNTER-METHODS\label{listing_6.26}
\listbegin
\begin{verbatim}
(defpan stats-counter-mean (sum count)
  (/ sum count))

(defpan stats-counter-variance
    (sum-of-squares sum count)
  (if (< count 2)
      0
      (/ (- sum-of-squares
            (* sum
               (stats-counter-mean self)))
         (- count 1))))

(defpan stats-counter-stddev ()
  (sqrt (stats-counter-variance self)))
\end{verbatim}
\listend
\end{figure}

Мы написали три метода, которые могут быть использованы в наших замыканиях, созданных с помощью \verb"make-stats-counter" или любом другом пандорическом замыкании, экспортирующем необходимые имена переменных. \verb"Stats-counter-mean" просто возвращает среднее значение всех значений, переданных замыканию. \verb"Stats-counter-variance" вычисляет дисперсию этих значений следуя ссылкам в очереди, а \foreignlanguage{english}{\textbf{stats-counter-stddev}} применяется для того, чтобы вычислить стандартное отклонение. Обратите внимание что каждая ссылка в очереди нужна для того, чтобы передать анафору \verb"self" для того, чтобы сослаться на полный лексический контекст замыкания. Мы видим, что отдельной пандорической функции нужно только сослаться на используемые переменные и на эти переменные можно ссылаться в том порядке, в каком нам заблагорассудится.

Итак, \verb"plambda" создаёт другую анафору --- \verb"self". В то время когда анафора \verb"this" ссылается на замыкание, которое будет вызвано, \verb"self" ссылается на косвенную среду, вызвавшую это замыкание. И хотя это прозвучит несколько странно, код внутри нашей \verb"plambda" может использовать \verb"self" для пандорического доступа к своей собственной лексической среде, вместо использования прямого доступа к ней. Пока что может показаться что такой трюк полезен для \verb"defpan" методов, написанных для работы внутри нашей лексической области видимости.

\begin{figure}Листинг 6.27: MAKE-NOISY-STATS-COUNTER\label{listing_6.27}
\listbegin
\begin{verbatim}
(defun make-noisy-stats-counter
    (&key (count 0)
     (sum 0)
     (sum-of-squares 0))
  (plambda (n) (sum count sum-of-squares)
           (incf sum-of-squares (expt n 2))
           (incf sum n)
           (incf count)
           
           (format t
                   "~&MEAN=~a~%VAR=~a~%STDDEV=~a~%"
                   (stats-counter-mean self)
                   (stats-counter-variance self)
                   (stats-counter-stddev self))))
\end{verbatim}
\listend
\end{figure}

\verb"Make-noisy-stats-counter" идентичен \verb"make-stats-counter" с тем исключением, что использует анафору \verb"self" для вызова наших \verb"defpan" функций \verb"stats-counter-mean", \verb"stats-counter-variance" и \foreignlanguage{english}{\textbf{stats\--\-coun\-ter\--\-std\-dev}}.

\verb"Plambda" и \verb"with-pandoric" могут перезаписать лексическую область видимости так, как мы этого захотим. Мы завершим эту главу таким примером. К одним из ограничений лексической области видимости иногда относят тот факт, что функция COMMON LISP \verb"eval" отбрасывает нашу текущую лексическую среду при вычислении переданной ей формы. Другими словами, \verb"eval" вычисляет форму в \emph{нулевой лексической среде\index{нулевая лексическая среда}}. В COMMON LISP иначе и не может быть: \verb"eval" --- это функция. Вот такая проблема:

\begin{verbatim}
CL-USER> (let ((x 1))
           (eval
            '(+ x 1)))
The variable X is unbound.
\end{verbatim}

Иногда бывает желательно расширить вашу лексическую среду на \verb"eval". Но будьте осторожны. Весьма часто использование \verb"eval" говорит о том, что вы, возможно, делаете что-то не так. Злоупотребление функцией \verb"eval" может привести к замедлению программ поскольку \verb"eval" может быть очень ресурсоёмкой операцией --- в основном, это происходит из необходимости расширять макросы присутствующие в переданной форме. Если вы вдруг обнаружили необходимость в \verb"eval" при программировании, спросите себя почему вы не сделали то, что вам нужно сделать гораздо раньше. Если ответом будет: ``Раньше я не мог сделать это'', скажем, поскольку вы только что считали форму, то, примите поздравления, вы обнаружили один из редких правомерных причин использования \verb"eval". Все другие ответы ведут к тому способу, который вы должны были применить в первую очередь: к макросу.

\begin{figure}Листинг 6.28: PANDORIC-EVAL\label{listing_6.28}
\listbegin
\begin{verbatim}
(defvar pandoric-eval-tunnel)

(defmacro pandoric-eval (vars expr)
  `(let ((pandoric-eval-tunnel
          (plambda () ,vars t)))
     (eval `(with-pandoric
                ,',vars pandoric-eval-tunnel
                ,,expr))))
\end{verbatim}
\listend
\end{figure}

Но, предположим, вам действительно нужно использовать \verb"eval", если бы только можно было взять с собой этот надоедливый лексический контекст. Макрос \verb"pandoric-eval" --- это пример интересного применения \verb"plambda" и \verb"with-pandoric". \verb"Pandoric-eval" использует специальную переменную под названием \verb"pandoric-eval-tunnel" для того, чтобы сделать пандорическое замыкание доступным для функции \verb"eval" через динамическую среду. Выбор лексических переменных предназначенных для \emph{туннелирования} через динамическую среду осуществляется через передачу списка с их символами в качестве первого аргумента \verb"pandoric-eval". Вот вышеприведённый пример, но уже с использованием \verb"pandoric-eval":

\begin{verbatim}
CL-USER> (let ((x 1))
           (pandoric-eval (x)
                          '(+ 1 x)))
2
\end{verbatim}

И выражение вычисленное с помощью \verb"pandoric-eval" может модифицировать исходную лексическую среду; \verb"pandoric-eval" --- это двухсторонний туннель:

\begin{verbatim}
CL-USER> (let ((x 1))
           (pandoric-eval (x)
                          '(incf x))
           x)
2
\end{verbatim}

В этом разделе, хотя он был очень длинный, мы всего лишь вскользь прошлись о возможностях пандорических макросов и различных их вариациях. И я ожидаю большого количества различных интересных разработок, которые разовьются из них.

Упражнение: Может ли \verb"pandoric-eval" вызываться вложенным? То есть, можно ли \verb"pandoric-eval" применять для вычисления форм, вычисляющих \verb"pandoric-eval"? Объясните ответ.

Упражнение: Хотя реализация пандорических макросов в этом разделе весьма эффективна, она может быть улучшена. Попробуйте заменить \verb"pandoriclet-get" и \verb"pandoriclet-set" на генерацию кода, использующего хэш-таблицу вместо \verb"case" и замерьте производительность этих двух реализаций на малых и больших числах пандорических переменных. Рассмотрите вашу любимую реализацию CLOS, сымитируйте диспетчеризацию CLOS и замерьте производительность.
