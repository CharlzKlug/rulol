\chapter{Замыкания}\label{chapter_closures}
\section{Замыкание - Ориентированное Программирование}\label{section_closure-oriented_programming}
\begin{quote}
Один из выводов к которому мы пришли был следующим: "объект" не должен быть примитивным понятием в языке программирования; объекты и их поведение должны строиться из значений ячеек и старых добрых лямбда выражений.

- Гай Стил во время разработки Scheme
\end{quote}

Иногда это называется \emph{замыканием (closure)}, в других случаях - сохранённым лексическим окружением. Или, как любят говорить некоторые из нас - \emph{let, окружающий lambda (let over lambda)}. Вне зависимости от используемой терминологии, усвоение концепции замыканий - это первый шаг в становлении профессионального Лисп программиста. По факту, это умение является жизненно необходимым для правильного использования многих современных языков программирования, кроме этого, сюда можно включить языки явно не поддерживающие let или lambda, например Perl или Javascript.

Замыкания входят в то небольшое число любопытных концепций, парадоксальная сложность которых связана с их чрезвычайной простотой. Когда программист начинает использовать сложные решения проблем, то простые решения начинают казаться ему незавершёнными и неудобными. Далее мы увидим что замыкания могут быть более простым решением нежели решение проблемы в лоб, например организация данных и кода через замыкания может оказаться более простой чем использование объектов. Но, в замыканиях есть ещё более важное свойство чем простота: абстракции, используемые для конструирования макросов - центральная тема этой книги.

Тот факт, что мы можем строить объекты и классы с помощью примитивов замыканий не означает что объектные системы бесполезны для Лисп программистов. Это далеко не так. На самом деле COMMON LISP включает в себя одну из наиболее мощных объектных систем: \emph{CLOS}, COMMON LISP Object System (Объектная Система COMMON LISP). Несмотря на то, что я очень восхищён гибкостью и функциональностью CLOS, его расширенные особенности мне редко бывают нужны\footnote{В COMMON LISP практически невозможно программировать без CLOS, поскольку CLOS занимает центральное место в COMMON LISP.}, благодаря ячейкам с присваиваемыми значениями и старым добрым лямбда выражениям.

В целом эта книга предназначена для программистов со средним уровнем знания Лиспа, но в этой главе мы попытаемся обучить вас с самых основ теории и использованию замыканий, для того, чтобы ознакомить вас с общей терминологией замыканий, используемой на протяжении всей книги. В этой главе рассматривается эффективность замыканий и как современные компиляторы оптимизируют замыкания.

\section{Среды и Просранство}\label{section_environments_and_extent}

Под ячейками с присваиваемым значением Стил определяет среду для сохранения ссылок к данным, где среда - это субъект чего-либо, называемый \emph{неопределённым пространством (indefinite extent)}. Это причудливый способ определения возможности ссылаться на такую среду в любой момент времени. Будучи единожды определённой эта среда и её ссылки будут существовать столько, сколько нам нужно. Рассмотрим следующую C функцию:

\begin{verbatim}
#include <stdlib.h>
int *environment_with_indefinite_extent(int input) {
  int *a = malloc(sizeof(int));
  *a = input;
  return a;
}
\end{verbatim}

После вызова этой функции и получения возвращённого указателя, мы, в течении неопределённого срока, по прежнему можем ссылаться на выделенную память. В C новые среды создаются при вызове функции, но C программисты указывают в \textbf{malloc()} требуемую память при возвращении её для использования за пределами функции.

Для контраста: ниже приведён бесполезный пример. C программисты рассматривают \textbf{a} как автоматически собираемую переменную, происходящее при возвращении функции поскольку среда выделяется в \emph{стеке}. С точки зрения Лисп программистов \textbf{a} создаётся во \emph{вр\'{е}менном пространстве}.

\begin{verbatim}
int *environment_with_temporary_extent(int input) {
  int a = input;
  return &a;
}
\end{verbatim}

Разница между средами C и Лисп в следующем: если вы явно не укажете что вам нужно, то Лисп будет предполагать что вы хотите использовать неопределённое пространство. Другими словами: Лисп всегда предполагает, что вы хотите вызвать \textbf{malloc()}, как в первом примере. Можно сказать, что это по своей природе менее эффективно, чем использование временного пространства, но преимущества почти всегда превышают незначительные издержки производительности. Более того, Лисп сам часто определяет, когда данные могут быть безопасно размещены в стеке и будет делать это автоматически. Вы даже можете использовать \emph{декларации} для того, чтобы Лисп сам явно выполнял эту операцию. Более подробно мы будем обсуждать декларации в \emph{главе 7, Тема Макро Эффективности}.

Но из-за динамичного характера, Лисп не имеет явных значений указателя или типов, как в С. Это может ввести вас в заблуждение, если вы, как программист C, используете вызов указателей и значения для определения типов. Lisp думает обо всем этом немного по-другому. В Лиспе удобно применять следующую мантру:

\begin{quote}
Переменные не имеют типов. Только значения имеют типы.
\end{quote}

Тем не менее, мы должны возвращать что-то для хранения указателей. В Лиспе существуют множество структур данных, которые могут хранить указатели. Одна из самых любимых Лисп программистами простейшей структурой является \emph{ячейка cons (cons cell)}. Каждая cons ячейка содержит ровно два указателя, ласково называемые как \emph{car} и \emph{cdr}. При вызове \textbf{environment-with-indefinite-extent} ячейка \emph{cons} будет вызвана с \emph{car}, указывающим на переданный аргумент \textbf{input}, и \emph{cdr}, указывающий на \textbf{nil}. И что наиболее важно, эта \emph{cons} ячейка (и ссылка на введённый аргумент \textbf{input}) обладает неопределённым пространством, таким образом, мы можем ссылаться на эту ячейку столько, сколько нам нужно:

\begin{verbatim}
(defun environment-with-indefinite-extent (input)
  (cons input nil))
\end{verbatim}

Эффективность недостатков неопределённого пространства достигает неуместности как состояние искусства улучшения технологии Лисп компилирования. Среды и пространства очень тесно связаны с замыканиями. Мы ещё не раз коснёмся темы сред и состояния в этой главе.

\section[Области Видимости]{Лексическая и Динамическая\\ Области Видимости}\label{section_lexical_and_dynamic_scope}

Технический термин, обозначающий доступность ссылки к переменной называется \emph{областью видимости (scope)}. Наиболее общий тип области видимости в современных языках программирования называется \emph{лексической (lexical)} областью. Когда фрагмент кода окружён лексической привязкой к переменной, то говорят что переменная расположена в лексической области привязки. С помощью формы \textbf{let}, наиболее универсальная форма для создания привязок, можно создавать переменные в лексической области:

\begin{verbatim}
* (let ((x 2))
    x)

2
\end{verbatim}

Доступ к \textbf{x} внутри тела формы \textbf{let} осуществляется через лексическую область. Аналогичным образом аргументы в функциях, определённых с помощью \textbf{lambda} или \textbf{defun} являются лексически связанными переменными в тексте определения функции. Лексические переменные - это переменные, доступ к которым возможен только из внутреннего кода контекста, для примера выше, это форма \textbf{let}. Поскольку лексическая область - это чрезвычайно интуитивный способ ограничения доступа к переменной, то может показаться, что это единственный способ разграничения. Есть ли другие другие способы создания областей видимости?

Комбинация неопределённого пространства и лексической области довольно долгое время не использовались в широко распространённых языках программирования. Первая реализация была разработана Стивом Расселом (Steve Russell) для Lisp 1.5 [HISTORY-OF-LISP] и впоследствии спроектирована для таких языков, как Algol-60, Scheme, и COMMON LISP. В Блабах некоторые полезные элементы лексической области видимости стали медленно реализовываться только спустя некоторое время и это несмотря на долгую и познавательную историю лексической области видимости.

Хотя способы реализации областей видимости в C-подобных языках ограничены, C программистам тоже приходится программировать в различных средах. Для этого они используют неявно определённую область видимости, также известную как \emph{область указателя (pointer scope)}. Область указателя известна трудностью в отладке, многочисленными рисками безопасности и, несколько искусственной эффективностью. Идея, лежащая за областью указателей - это создание проблемно-ориентированного языка для контроля регистров и памяти машины фон Неймана, похожей на большинство современных процессоров [PAIP-PIX], с последующим использованием этого языка для доступа и манипулирования структурами данных с непосредственными командами процессора. Область указателей была необходима по причинам производительности во времена, когда Лисп компиляторы ещё не были изобретены, но, теперь, в современных языках программирования область указателей скорее рассматривается как проблема, а не как особенность.

И хотя Лисп программисты редко думают в терминах указателей, понимание областей указателей бывает весьма полезным при создании эффективного Лисп кода. В \emph{разделе Область Указателя} мы будем исследовать реализацию области видимости указателя для тех редких случаев, когда нам нужно уведомить компилятор о создании специфичного кода. Но, в данный момент нам нужно только обсудить механику области указателей. В C нам иногда нужно получать доступ к переменной, определённой за пределом создаваемой функции:

\begin{verbatim}
#include <stdio.h>

void pointer_scope_test() {
  int a;
  scanf("%d", &a);
}
\end{verbatim}

В вышеприведённой функции мы использовали оператор \textbf{\&} в языке C для того, чтобы передать адрес занимаемый в памяти переменной \textbf{a} в функцию \textbf{scanf}, после этого функция \textbf{scanf} знает куда записывать отсканированные данные. Лексическая область видимости в Лиспе запрещает нам напрямую реализовать это действие. В Лиспе нам придётся передать подобную анонимную функцию в гипотетическую Лисп функцию \textbf{scanf}, что позволит ей изменить нашу лексическую переменную \textbf{a}, несмотря на то, что \textbf{scanf} определена за пределами нашей лексической области:

\begin{verbatim}
(let (a)
  (scanf "%d" (lambda (v) (setf a v))))
\end{verbatim}

Лексическая область видимости - это благоприятная среда для замыканий. По факту, замыкания настолько связаны с концепцией лексической области, что часто их более точно называют как \emph{лексические замыкания (lexical closures)}, для того, чтобы отделить их от других видов замыканий. Если не указано что-то другое, то по-умолчанию все замыкания в этой книге являются лексическими.

В дополнение к лексической области в Common Lisp есть ещё и \emph{динамическая область (dynamic scope)}. Это \emph{сленг (slang)} Лиспа обозначающий комбинацию временного пространства и глобальную область. Динамическая область видимости - это одна из разновидности областей видимости. Динамическая область видимости уникальна для Лиспа тем, что предполагает отличающееся поведение с аналогичным синтаксисом лексической области. В Common Lisp переменные, доступные через динамическую область видимости, называются \emph{специальными переменными}. Сделано это для того, чтобы привлечь внимание к таким переменным. Специальные переменные могут быть объявлены с помощью \textbf{defvar}. Некоторые программисты придерживаются соглашения, по которому имена специальных переменных следует начинать и заканчивать символом астериска, например, \textbf{*temp-special*}. Это соглашение называется \emph{"наушник" (earmuff)}. По причинам описанным в \emph{разделе Дуализм Синтаксиса}, эта книга не использует наушники, поэтому наше объявление специальных переменных выглядит так:

\begin{verbatim}
(defvar temp-special)
\end{verbatim}

При таком определении \textbf{temp-special} будет помечен как специальный\footnote{Также мы можем указать с помощью определений локальную особенность.}, но не будет инициализирован каким-либо значением. В этом состоянии специальная переменная называется \emph{несвязанной (unbound)}. Только специальные переменные могут быть несвязанными - лексические переменные всегда связаны и поэтому всегда имеют значения. На это можно взглянуть с другой точки зрения: по-умолчанию все символы представляют из себя лексически не связанные переменные. Также как и с лексическими переменными мы можем присвоить значение специальным переменным с помощью \textbf{setq} или \textbf{setf}. Некоторые Лиспы, такие как Scheme, не имеют динамической области видимости. Другие Лиспы, такие как EuLisp [SMALL-PIECES-P46], используют один синтаксис для доступа к лексическим переменным и другой синтаксис для доступа к специальным переменным. Но в Common Lisp синтаксис общий. Многие лисперы считают это особенностью языка. Так мы присваиваем значение к нашей специальной переменной \textbf{temp-special}:

\begin{verbatim}
(setq temp-special 1)
\end{verbatim}

До сих пор мы не увидели ничего такого, что выделяло бы особенность специальной переменной. Она выглядит как обычная переменная, некоторым образом привязанная к глобальному пространству имени. Всё это потому, что мы только единожды выполнили привязку - специальная глобальная привязка по умолчанию. Специальные переменные интересны тем, что по отношению к ним возможно выполнение повторной привязки, или \emph{затенения (shadowed)}, с помощью новой среды. Мы определим функцию просто вычисляющую и возвращающую \textbf{temp-special}:

\begin{verbatim}
(defun temp-special-returner ()
  temp-special)
\end{verbatim}

Функция может быть использована для получения значения, в которое Лиспом вычисляется \textbf{temp-special} в момент вызова:

\begin{verbatim}
* (temp-special-returner)

1
\end{verbatim}

Иногда это называют вычислением формы в \emph{нулевую лексическую среду (null lexical environment)}. Очевидно, что нулевая лексическая среда не содержит никаких лексических привязок. В данном примере значение \textbf{temp-special} возвращается из глобального специального значения, 1. Но, если мы вычислим его в не-нулевой лексической среде - в той, которая содержит привязку для нашей специальной переменной - то здесь проявится специальность \textbf{temp-special}\footnote{Поскольку мы создаём динамическую привязку, но не лексическую среду. Они просто похожи друг на друга.}:

\begin{verbatim}
* (let ((temp-special 2))
     (temp-special-returner))

2
\end{verbatim}

Обратите внимание, что в качестве значения была возвращена 2, это означает, что значение для \textbf{temp-special} было получено из нашей среды \textbf{let}, а не из специального глобального окружения. Если вам это всё ещё не кажется интересным, то взгляните как это невозможно выразить в большинстве других традиционных языков программирования. Ниже показан пример из псевдокода на Блабе:

\begin{verbatim}
int global_var = 0;

function whatever() {
  int global_var = 1;
  do_stuff_that_uses_global_var();
}

function do_stuff_that_uses_global_var() {
  // global_var is 0
}
\end{verbatim}

Расположение в памяти или значения регистров для лексических привязок становятся известными при компиляции\footnote{По тем же причинам лексическая область видимости называется как "статическая область видимости".}, а привязки для специальных переменных определяются при работе программы. Вам может показаться что специальные переменные не эффективны, но это не так. Специальная переменная всегда ссылается на одно и тоже место в памяти. При использовании \textbf{let}, для привязки специальной переменной, вы на самом деле компилируете код, который сохраняет копию переменной, перезаписывает участок памяти новым значением, вычисляет формы в теле \textbf{let} и, наконец, восстанавливает оригинальное значение из копии.

Специальные переменные постоянно связаны с символом, применяемым для их обозначения. Место в памяти, на которое ссылается специальная переменная называется ячейкой \textbf{символ-значение (symbol-value)} символа. Это прямое противопоставление лексическим переменным. Лексические переменные указываются символами только в момент компилирования. Поскольку доступ к лексическим переменным возможен только изнутри лексической области видимости их привязок, то компилятору нет нужды помнить о символах, применяемых в качестве ссылки на лексические переменные, поэтому компилятор удаляет их из скомпилированного кода. Мы приукрасим истинность этого высказывания в \emph{разделе Пандорические Макросы}.

Хотя Common Lisp и предоставляет нам неоценимые возможности динамической области, но, лексические переменные являются более распространёнными. Раньше динамическая область использовалась для определения особенностей Лиспа, но сейчас, с появлением Common Lisp, почти полностью заменена лексической областью.Поскольку лексическая область позволяет использовать такие приёмы, как лексические замыкания (в дальнейшем мы кратко рассмотрим их), а также более эффективную оптимизацию компилятора, то замена динамической области оказывается хорошей идеей. Однако, архитекторы Common Lisp оставили нам очень прозрачное окно в мир динамической области, которая ныне используется в более узких целях.
