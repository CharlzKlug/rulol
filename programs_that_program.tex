\chapter{Программирующие Программы}\label{chapter_programs_that_program}
\section{Лисп - Не Функциональный Язык}\label{section_lisp_is_not_functional}

Одно из наиболее распространённых заблуждений о лиспе гласит: лисп - это функциональный язык программирования. Лисп - это не функциональный язык программирования. На самом деле можно утверждать, что лисп - это один из наименее функциональных языков программирования. Это ошибочное мнение имеет интересные корни и служит хорошим примером того, как маленькое недоразумение может может иметь долгоиграющие последствия, приводящие к путанице уже после того, как сами причины уже давно перестали соответствовать истине. Что такое функциональный язык программирования? Единственное, имеющее смысл определение следующее:

\begin{quote}
Функциональный язык - это язык программирования, состоящий из функций.
\end{quote}
 
Итак, что же такое функция? Функция - это \emph{математическая} концепция существующая на протяжении веков: 
 
\begin{quote}
Функция - это статичное, точно определённое преобразование исходных значений в результирующие значения. 
\end{quote}
 
Похоже на \verb"defun", который мы используем для определения новых функций в лиспе. Например, следующее выражение выглядит как функция, использующая сложение для преобразования набора всех чисел в новый набор, один из которых также включает все числа: 
 
\begin{verbatim}
(defun adder (x)
(+ x 1)) 
\end{verbatim}
 
Очевидно мы можем применить этот объект к любому числу и получить результат, но является ли \verb"adder" настоящей функцией? Лисп утверждает что \verb"adder" - это функция\footnote{Если вы до сих пор не знакомы с функцией COMMON LISP \textbf{describe} то вам нужно немедленно с ней ознакомиться. Примените \textbf{describe} к функции, специальной форме, макросу, переменной, символу и замыканию.}: 

\begin{verbatim} 
* (describe #’adder)
#<Interpreted Function> is a function. 
\end{verbatim}
 
Но, именование этих объектов функциями является некорректным использованием термина с глубокими корнями в истории лиспа. \verb"Defun" и лямбда формы на самом деле создают \emph{процедуры}, или если говорить более точно, \emph{экземпляры, вызываемые как функции (funcallable instances)} [AMOP]. В чём различие? Процедуры не обязательно должны содержать в себе работу с преобразованием значений, но процедуры являются участками кода, возможно содержащим сохраняемую среду, которую можно выполнить (funcall). Когда лисп программисты пишут программы в определённом стиле, называемом \emph{функциональным стилем}, то получающиеся процедуры можно рассматривать и комбинировать в математическом стиле функциональных преобразований. 
 
Причина, по которой лисп так часто описывают функциональным языком связана с историей. Хотите верьте, хотите нет, но было время когда большинство языков не поддерживало концепцию процедур, которую современные программисты считают само собой разумеющимся в любом языке. На заре зарождения языки не предоставляли удобных абстракций для локального именования аргументов в участках повторно используемого кода и программисты были вынуждены вручную управлять регистрами и манипулировать стеком для достижения подобного поведения. Лисп - это язык, который уже тогда поддерживал процедуры, был более функциональным чем остальные языки. 
 
После того как процедурным абстракциям было уделено должное внимание и они были включены во все языки программирования, люди медленно начали работать над преодолением барьеров ограниченной природы реализованных процедур. Программисты стали понимать что было бы неплохо иметь возможность возвращать процедуры из других процедур, встраивать их в новые среды, объединять их в структуры данных и, в целом, рассматривать их как самые простые значения. Лозунг, побудивший программистов перейти к подобной абстракции был следующим: общество без классов, \emph{первоклассные процедуры}. В сравнении с языками, которые относили процедуры к предыдущему второму классу, лисп - язык, который уже обладал первоклассными процедурами, выглядел более функциональным. 
 
И наконец, обычно многие языки делают бессмысленное различие между выражением и оператором, для того, чтобы поддерживать ужасный Блаб синтаксис, например: инфиксный. В лиспе всё возвращает что-либо\footnote{Исключением является ничего не возвращающий \textbf{(values)}. Но, это сводится к \textbf{nil} и по этой причине может использоваться в выражениях. } и нет (синтаксических) ограничений для вложения или комбинации. Это простой вопрос с очевидным ответом: что более важно в языке, синтаксис, дружественный к новичкам, или настоящая гибкость? Все языки, которые используют инфиксный синтаксис уменьшают возможности абстракции многими способами. К счастью большинство современных языков доверяют своим пользователям пользователям и дают им возможность комбинировать выражения так, как они считают нужным. В сравнении с языками, которые принимают подобные мозгоубивающие синтаксические решения, лисп выглядит более функциональным. 

После того, как программисты привыкли к этой вездесущей и достаточно ошибочной терминологии, пришло понимание что понятие функции, использованной в больших дебатах посвящённым функциональным и не функциональным языкам не только запутывает, но и является фундаментальным шагом назад. Чтобы исправить это программисты и учёные вернулись к меловой доске и математическому определению функции: преобразование входных значений в выходные значения. Если лисп является функциональным языком, то он настолько же функционален, насколько функциональны такие современные языки программирования как Perl и JavaScript. 

Очевидно что лисп процедуры не являются функциями. Лисп процедуры могут возвращать не-статичные значения, эти процедуры вы можете вызывать несколько раз с одними и теми же аргументами и каждый раз можете получать разные значения. В наших примерах из предыдущих глав, лисп процедуры могут хранить состояния. Процедуры подобные \verb"rplaca" могут изменять значения не только в памяти, но и в других местах (таких как регистры). Такие лисп процедуры как \verb"terpri" и \verb"format" создают вывод (новые строки в случае \verb"terpri") направляемые в терминал или файлы\footnote{\textbf{Terpri} и \textbf{rplaca} - они были названы не просто так.}. Лисп процедуры подобные \verb"yes-or-no-p" могут читать ввод из терминала и возвращать значения в зависимости от ввода пользователя. Являются ли эти процедуры статичными, точно определёнными преобразованиями? 

Поскольку лисп процедуры - это не математические функции, то лисп - это не функциональный язык. На деле сильная аргументация может привести к тому, что лисп может стать менее функциональным чем остальные языки. В большинстве языков выражения, выглядящие как вызовы процедур являются вызовами процедур и изменить это мешает синтаксис языка. В лиспе мы работаем с макросами. Как мы уже увидели ранее, макросы могут невидимо изменить значение некоторых форм от вызова функции и до независимых лисп выражений - техника, которая способна нарушить ссылочную прозрачность многими способами, что попросту невозможно в других языках.

Выяснилось что большинство языков на самом деле не являются функциональными, после этого некоторые разработчики языков решили узнать как будет выглядеть программирование на настоящих функциональных языках. Как вы можете ожидать программирование на функциональных языках в основном раздражает и бывает непрактичным. Почти нет проблем относящихся к реальному миру и которые можно было бы выразить через статичные, чётко определённые преобразования из исходных значений в результирующие значения. Но это не значит что функциональное программирование не имеет плюсов и многие языки были спроектированы так, чтобы получить преимущества от функционального стиля программирования. Это означает нахождение удобного способа изоляции функциональных частей программ от (на самом деле интересных) не-функциональных частей. Такие языки как Haskell и OCaml используют эту изоляцию как средство создания агрессивных оптимизационных допущений. 

Но это лисп. Мы очень не-функциональны и очень гордимся этим. По мере того, как увеличивается польза от изоляции побочных эффектов, лисп программисты могут и должны реализовывать это с помощью макросов. Настоящее назначение функционального программирования в том, чтобы разделить функциональное описание того что происходит от механизма происходящих событий. Определённо, лисп не функционален, но, поскольку у нас есть макросы. И нет лучшей платформы или материала чем макросы для реализации более функционального языка чем лисп.

\section{Программирование Сверху-Вниз}\label{section_top-down_programming}

\begin{quote}
Вы не можете обучать новичков программированию сверху вниз, поскольку они не знают какой низ является верхом.

- Чарльз Энтони Ричард Хоар
\end{quote}

В \emph{разделе Предметно Ориентированные Языки} при первом знакомстве с предметно-ориентированными языками мы создали простой макрос \verb"unit-of-time". Этот макрос дал нам удобный способ определения периодов времени в различных величинах с помощью основанного на символах, интуитивно-понятного синтаксиса:

\begin{verbatim}
* (unit-of-time 1 d)
86400
\end{verbatim}

\verb"Unit-of-time" - это удобный предметно-ориентированный язык, поскольку программисту не требуется помнить, например, количество секунд, содержащихся в сутках. \verb"Unit-of-time" реализован с помощью простого макроса, использующего оператор case в роли сердцевины для нижележащего расширения.

Важным принципом в проектировании макросов является программирование \emph{сверху-вниз (top-down)}. Проектирование лисп макроса следует начать с создания абстракции.Вам нужно писать программы, использующие макросы ещё до того, как вы написали сам макрос. Что парадоксально, вам нужно знать как писать на языке ещё до того, как вы сможете написать краткое определение/реализацию этого языка.

Таким образом первым шагом в конструировании серьёзного макроса является написание \emph{вариантов использования (use cases)} макроса, даже если нет никакого способа с помощью которых вы смогли бы проверить или использовать эти макросы. Если программы, написанные в этом новом языке окажутся достаточно объемлющими, то идея о том, что лучше реализовать: компилятор или интерпретатор последует сама собой.

Рассмотрим наш макрос \verb"unit-of-time", существует ли способ перевести этот макрос на ещё больший уровень спецификации и создать язык, предназначенный для создания макросов, создающих удобные единицы измерения? Что же, \verb"unit-of-time" - это макрос, и чтобы выполнить задуманное, нам нужен макрос, определяющий другой макрос...

\emph{Стоп!} Этот низ является верхом.

Мы начали рассматривать задачу не с реализации языка, а с того, что задали себе вопрос: для чего мы хотим использовать этот язык? Ответ оказался следующим: мы хотим получить простой способ определения вспомогательных программ, преобразующих единицы измерения. В следующем варианте использования мы хотим получить тип единицы измерения, time, базовую единицу выраженную в секундах и представленную здесь через s, набор пар из единиц и коэффициентов преобразования этих единиц в базовую единицу:

\begin{verbatim}
(defunits% time s
m 60
h 3600
d 86400
ms 1/1000
us 1/ 1000000)
\end{verbatim}

\verb"Defunits%" может расшириться в код, определяющий макрос, подобный \verb"unit-of-time", написанный нами в \emph{разделе Предметно - Ориентированные Языки}, что позволяет нам преобразовывать произвольные единицы времени в секунды. Можно ли ещё более улучшить этот код?

На этом месте мозгового штурма прекращается создание инноваций в архитектуре программы, разрабатываемой на большинстве других языков. Мы всего лишь создали способ применения множителей для различных единиц измерения в код, позволяющий нам преобразовать единицы измерения в удобный нам вид. Но, профессиональный лисп программист определит, что это преобразование - программа, следовательно, может быть расширена через те-же приёмы, что применяются для расширения обычных лисп программ.

При вводе многих разнообразных единиц измерений может быть полезно определять единицы в терминах других единиц. Коэффициент, используемый для умножения единиц может также являться списком со значением, относящемуся к другой единице, например:

\begin{verbatim}
(defunits%% time s
m 60
h (60 m)
d (24 h)
ms (1/1000 s)
us (1/1000 ms))
\end{verbatim}

\emph{Связывание (chaining)} единиц измерений выглядит естественной операцией. Минуты определены в терминах наших базовых единиц, секунд, часы - в терминах минут, и дни - в терминах часов. Реализуя наш макрос в итеративном стиле мы, для начала, реализуем несвязываемое поведение с \verb"defunits%", после этого мы реализуем связывание с \verb"defunits%%" ещё до добавления соответствующих проверок на ошибки и переходу к реализации финальной версии, \verb"defunits".

Заметьте, что этот новый язык может больше, чем просто предоставление удобного синтаксиса для добавления новых типов единиц. Этот язык также позволяет нам уменьшить воздействие \emph{округления (rounding)} в наших вычислениях и позволяет лиспу использовать настолько точную арифметику насколько это возможно. Например, фарлонг - это 1/8 мили, и если мы закодируем это значение с использованием очередизации взамен, скажем, метрического приближения, то в конечном итоге мы можем получить более точные результаты или, что ещё более важно, результаты, максимально соответствующие вычислениям, произведёнными с помощью миль. Поскольку нам достаточно всего лишь добавить самый точный коэффициент преобразования не прибегая к каким-либо другим преобразованиям, то этот макрос даёт нам возможность создавать правила на уровне выражений, невозможных в других языках.

Используя поведение автоматических gensym-ов, описанное в \emph{разделе Нежелательный Захват}, написание \verb"defunits%" оказывается чрезвычайно простым делом. Функция Грэма \verb"symb" сгенерирует новое имя для макроса конвертации. Например, если символ \verb"time" - это тип уже существующей единицы, то новый макрос конвертации будет называться \verb"unit-of-time". \verb"Defunits%" был сконструирован исходя из описания \verb"unit-of-time", описанном в \emph{разделе Предметно-Ориентированные Языки}, но, этот код окружён \verb"defmacro!" и обратной кавычкой, и замещены части, нуждающиеся в повторном создании при каждом вызове макроса.

Листинг 5.1: DEFUNITS-1\label{listing_5.1}
\listbegin
\begin{verbatim}
(defmacro! defunits% (quantity base-unit &rest units)
`(defmacro ,(symb 'unit-of- quantity) (,g!val ,g!un)
`(* ,,g!val
,(case ,g!un
((,base-unit) 1)
,@(mapcar (lambda (x)
`((,(car x)) ,(cadr x)))
(group units 2))))))
\end{verbatim}
\listend

\verb"Defunits%" использует \emph{вложенные обратные кавычки} - чрезвычайно сложную для понимания конструкцию. Программирование с обратными кавычками - это тоже самое, что и обладание ещё одним смысловым измерением в коде. В других языках, определённый программный оператор обычно обладает очень простой вычислительной семантикой. Вы знаете когда буден запущен каждый бит кода, поскольку каждый бит кода вынужден выполняться в одно и тоже время: во время выполнения. Но в лиспе с помощью вложенных обратных кавычек мы можем масштабироваться вверх и вниз по \emph{лестнице закавычивания (ladder of quotation)}. Каждая написанная нами обратная кавычка - это один шаг по этой лестнице: наш код - это список, вычисление которого зависит от нашего желания. Но внутри обычного списка каждая встреченная запятая переносит нас на шаг вниз по лестнице закавычивания и исполняет код из соответствующего шага лестницы [CLTL2-P967].

Таким образом это простой алгоритм для определения времени вычисления каждого бита из лисп формы. Просто начните с корня выражения и после встречи с каждой обратной кавычкой пометьте переход на ещё один уровень закавычивания. Для каждой встреченной запятой пометьте переход на уровень ниже. Как заметил Стил [CLTL2-P530], следование этому уровню закавычивания может быть трудной задачей. Эта трудность - потребность отслеживать вашу текущую глубину вложения - это то, что заставляет ощущать использование обратных кавычек другим измерением добавленным в обычное программирование. В других языках вы можете пойти на север, юг, восток и запад, но лисп вдобавок даёт вам возможность перемещаться вверх.

\verb"Defunits%" - это хороший шаг, но в нём по прежнему не реализована очередизация. В данный момент, макро реализация этого языка - это в основном простая замена. Реализация поведения очередизации требует более запутанной программной логики. Простая подстановка уже не будет работать поскольку части макроса зависят от остальных частей макроса, поэтому при постройке нашего расширения нам нужно полностью обрабатывать передаваемые макросу формы, а не просто думать о них в терминах отдельных кусочков, которые мы можем сращивать.

Листинг 5.2: DEFUNITS-CHAINING-1\label{listing_5.2}
\listbegin
\begin{verbatim}
(defun defunits-chaining% (u units)
(let ((spec (find u units :key #'car)))
(if (null spec)
(error "Unknown unit ~a" u)
(let ((chain (cadr spec)))
(if (listp chain)
(* (car chain)
(defunits-chaining%
(cadr chain)
units))
chain)))))
\end{verbatim}
\listend

Следует помнить, что макросы - это на самом деле просто функции, мы создали функцию-утилиту для использования её в определении макроса, \verb"defunits-chaining%". Эта функция-утилита получает единицу, определённую символами, подобными \verb"S", \verb"M" или \verb"H", и список определений единиц. Мы разрешаем работу с определениями единиц до получения числа, которое будет интерпретироваться базовой единицей, например \verb"(M 60)" или списком, содержащим неявную отсылку к другой единице в очереди, например \verb"(H (60 M))".

Это рекурсивная функция - утилита. Для нахождения множителя, применяемого для базовой единицы мы перемножаем каждое звено очереди с другим вызовом функции-утилиты используемой для обработки остальной части очереди. После возврата из стека вызовов мы получим множитель, применяемый для конвертации значения единицы в значение базовой единицы. Например, когда мы конструируем множители для часов, мы находим что в одном часе 60 минут. Мы переходим в рекурсию и находим что в одной минуте 60 секунд. Мы опять переходим в рекурсию и находим что секунда - это конец очереди - минуты были определены непосредственно в терминах базовых единиц. Итак, вернувшись из рекурсии мы вычисляем \verb"(* 60 (* 60 1))", что равняется 3600: то есть, в одном часе 3600 секунд.

Листинг 5.3: DEFUNITS-2\label{listing_5.3}
\listbegin
\begin{verbatim}
(defmacro! defunits%% (quantity base-unit &rest units)
`(defmacro ,(symb 'unit-of- quantity) (,g!val ,g!un)
`(* ,,g!val
,(case ,g!un
((,base-unit) 1)
,@(mapcar (lambda (x)
`((,(car x))
,(defunits-chaining%
(car x)
(cons `(,base-unit 1)
(group units 2)))))
(group units 2))))))
\end{verbatim}
\listend

После определения этой функции-утилиты, для работы с множителем для каждой единицы требуется простая модификация \verb"defunits%", которую мы выполнили в \verb"defunits%%". Вместо объединения в значение прямо из определения единицы мы передаём каждую единицу и целое определение единицы в утилиту \verb"defunits-chaining%". Как было описано выше, эта функция рекурсивно преобразует множитель, требуемый для каждой единицы, в базовую единицу. С этим множителем \verb"defunits%%" может объединять значение в case операторы, также, как это выполняет \verb"defunits%".

Эти макросы всё ещё не завершены. Макрос \verb"defunits%" не поддерживает очередизацию. \verb"Defunits%%" поддерживает очередизацию, но не проверяет на наличие ошибок. Профессиональный писатель макросов всегда заботится об обработке любых возможных ошибочных состояний. Особенно важны возникновения бесконечных циклов или другие трудные для отладки в REPL-е случаи.

Проблема связанная с \verb"defunits%%" является частью создаваемого нами языка: в этом языке возможны программы, содержащие циклы. Например:

\begin{verbatim}
(defunits time s
m (1/60 h)
h (60 m))
\end{verbatim}

Для того, чтобы добавить соответствующий отладочный вывод, мы должны несколько улучшить нашу реализацию. Наша окончательная версия \verb"defunits" поддерживает очередизацию и печатает удобный отладочный вывод указывающий пользователю на наличие подобных циклических зависимостей. Всё это благодаря \verb"defunits-chaining", улучшенной версии \verb"defunits-chaining%" работающей со списком ранее встреченных единиц. Таким образом, если мы повторно столкнёмся с уже существующей в списке единицей, то мы можем выдать ошибку, которая лаконично описывает проблему:

Листинг 5.4: DEFUNITS\label{listing_5.4}
\listbegin
\begin{verbatim}
(defun defunits-chaining (u units prev)
(if (member u prev)
(error "~{ ~a~^ depends on~}"
(cons u prev)))
(let ((spec (find u units :key #'car)))
(if (null spec)
(error "Unknown unit ~a" u)
(let ((chain (cadr spec)))
(if (listp chain)
(* (car chain)
(defunits-chaining
(cadr chain)
units
(cons u prev)))
chain)))))

(defmacro! defunits (quantity base-unit &rest units)
`(defmacro ,(symb 'unit-of- quantity)
(,g!val ,g!un)
`(* ,,g!val
,(case ,g!un
((,base-unit) 1)
,@(mapcar (lambda (x)
`((,(car x))
,(defunits-chaining
(car x)
(cons
`(,base-unit 1)
(group units 2))
nil)))
(group units 2))))))
\end{verbatim}
\listend

\begin{verbatim}
* (defunits time s
m (1/60 h)
h (60 m))
Error in function DEFUNITS-CHAINING:
M depends on H depends on M
\end{verbatim}

Макрос defunits идентичен \verb"defunits%%" за исключением того, что он передаёт дополнительный аргумент \verb"nil" функции \verb"defunits-chaining", являющийся концом списка, отображающего историю уже посещённых единиц. Если при поиске новой единицы мы обнаружим что уже встречали её, то это обозначает обнаружение цикла. Мы можем использовать эту историю посещённых единиц для печати вспомогательных сообщений пользователям макросов, написавших циклы.

Итак, \verb"defunits" - это специфичный язык, предназначенный для введения единиц в процедуру конвертации. На самом деле этот язык предназначен для ещё более тонкой области чем эта; есть множество путей для создания этого языка. Поскольку создавать языки в Блабе трудно, но, легко в Лиспе, лисп программисты обычно не стремятся запихивать всё в один язык. Вместо этого они делают язык всё более и более предметно-ориентированным до тех пор, пока конечная цель не станет тривиальной.

Примером использования \verb"defunits" является \verb"unit-of-distance" (единицы - расстояния). В 1970 году морская сажень сократилась, по крайней мере для британских моряков, на 1/76 часть:

\begin{verbatim}
* (/ (unit-of-distance 1 fathom)
(unit-of-distance 1 old-brit-fathom))
75/76
\end{verbatim}

Листинг 5.5: UNIT-OF-DISTANCE\label{listing_5.5}
\listbegin
\begin{verbatim}
(defunits distance m
km 1000
cm 1/100
mm (1/10 cm)
nm (1/1000 mm)

yard 9144/10000 ; Принято в 1956
foot (1/3 yard)
inch (1/12 foot)
mile (1760 yard)
furlong (1/8 mile)

fathom (2 yard) ; Принято в 1929
nautical-mile 1852
cable (1/10 nautical-mile)

old-brit-nautical-mile ; Отменено в 1970
(6080/3 yard)
old-brit-cable
(1/10 old-brit-nautical-mile)
old-brit-fathom
(1/100 old-brit-cable))
\end{verbatim}
\listend

Что чуть больше 2-х сантиметров:

\begin{verbatim}
* (coerce
(unit-of-distance 1/76 old-brit-fathom)
’float)
0.024384
\end{verbatim}

\section{Неявные Контексты}\label{section_implicit_contexts}

Макросы могут использовать технику под названием \emph{неявный контекст (implicit context)}. Иногда мы решаем неявно добавить лисп код в некоторые выражения, которые мы не хотим часто писать и хотим использовать как абстракцию, нередко это применяется в многократно используемом коде или в коде, который должен быть краток и задействуется в других частях программы. До этого момента мы уже беседовали о неявных контекстах и вам уже должно быть ясно, что неявные контексты даже безотносительно программирования макросов являются фундаментальной частью лисп программирования: формы let и lambda обладают \emph{неявным progn-ом}, поскольку они вычисляют, поочерёдно, формы их тела и возвращают последний результат. \verb"Defun" добавляет \emph{неявную lambda} вокруг форм, и поэтому вам не нужно использовать лямбда формы для именованных функций.

В этом разделе мы изучим макрос \verb"tree-leaves"\footnote{Также стоит посмотреть функцию COMMON LISP \verb"subst".}, его создание и конструкцию. Макрос \verb"tree-leaves", предназначен для \emph{прохода по коду (code-walking)}, который позже будет использоваться в этой книге. Подобно \verb"flatten" этот макрос исследует переданный ему лисп код, рассматривая его как дерево, затем производит некоторые модификации и возвращает новое дерево. Списковая структура исходного выражения не модифицируется: \verb"flatten" и \verb"tree-leaves" оба создают новую структуру. Разница между ними заключается в том, что основная цель \verb"flatten" в удалении вложенных списков и в возвращении плоского списка, уже не являющегося лисп кодом, а \verb"tree-leaves" сохраняет структуру выражения, но изменяет значения отдельных атомов.



Начнём с простого эскиза. \verb"Tree-leaves%" - это функция, рекурсивно проходящая по предоставленному выражению \verb"tree", cons-я новую списковую структуру с той же формой\footnote{Пустой \verb"else" случай в форме \verb"if" возвращает \verb"nil", также являющийся пустым списком.}. Когда она обнаруживает атом, то вместо того, чтобы вернуть этот атом она возвращает значение аргумента \verb"result":

Листинг 5.6: TREE-LEAVES-1\label{listing_5.6}
\listbegin
\begin{verbatim}
(defun tree-leaves% (tree result)
(if tree
(if (listp tree)
(cons
(tree-leaves% (car tree)
result)
(tree-leaves% (cdr tree)
result))
result)))
\end{verbatim}
\listend

\begin{verbatim}
* (tree-leaves%
’(2 (nil t (a . b)))
’leaf)
(LEAF (NIL LEAF (LEAF . LEAF)))
\end{verbatim}

Итак \verb"tree-leaves%" возвращают новое дерево, в котором все атомы преобразуются в предоставленный нами символ, \verb"leaf". Заметьте, что атом \verb"nil" в car позиции cons ячейки не изменился поскольку он не изменится при перемещении его в cdr позицию (и представляет из себя пустой список).

Конечно, изменение каждого элемента это весьма бесполезно. То что нам нужно на самом деле - так это возможность выбора определённых атомов и возможность избирательной трансформации их в новые атомы для последующей вставки в новую списковую структуру, оставляя неинтересные нам атомы без изменений. В лиспе самым лёгким способом является написание изменяемой функции-утилиты, дающей возможность применять \emph{плагины (plug-ins)} где пользователь может использовать произвольный код для контроля поведения утилиты. Примером этому может служить функция sort, включённая в COMMON LISP. В этом примере в функцию \verb"sort" подключена в виде плагина функция меньше чем:

\begin{verbatim}
*(sort ’(512438967) #’<)
(123456789)
\end{verbatim}

Листинг 5.7: PREDICATE-SPLITTER\label{listing_5.7}
\listbegin
\begin{verbatim}
(defun predicate-splitter (orderp splitp)
(lambda (a b)
(let ((s (funcall splitp a)))
(if (eq s (funcall splitp b))
(funcall orderp a b)
s))))
\end{verbatim}
\listend

Эта концепция получения функции, предназначенной для контроля поведения особенно удобна, поскольку мы можем создавать анонимные функции, специально предназначенные для наших задач. Или, с целью получения ещё большей мощи, мы можем создать функции, которые будут порождать эти анонимные функции для нас. Также это известно как \emph{комбинирование функций (function composition)}\footnote{Вот почему комбинирование функций занимает только пару параграфов в то время когда комбинирование макросов занимает большую часть этой книги.}. И хотя комбинирование функций не так интересно как комбинирование макросов, оно по прежнему остаётся чрезвычайно полезной техникой, которой должны овладеть все профессиональные лисп программисты.



\verb"Predicate-splitter" - это простой пример комбинирования функции. Эта функция предназначена для комбинирования двух предикатов в один новый предикат. Первый предикат получает два аргумента предназначенных для упорядочивания элементов. Второй предикат получает один аргумент и определяет относится ли элемент к определённому классу элементов, которых вы хотите разделить с помощью вашего предиката. Например, ниже мы применили \verb"predicate-splitter" для создания нового предиката, работающего также, как и меньше чем, за исключением того, что чётные числа будут меньше чем нечётные числа:

\begin{verbatim}
* (sort ’(5 1 2 4 3 8 9 6 7)
(predicate-splitter #’< #’evenp))
(246813579)
\end{verbatim}

Листинг 5.8: TREE-LEAVES-2\label{listing_5.8}
\listbegin
\begin{verbatim}
(defun tree-leaves%% (tree test result)
(if tree
(if (listp tree)
(cons
(tree-leaves%% (car tree) test result)
(tree-leaves%% (cdr tree) test result))
(if (funcall test tree)
(funcall result tree)
tree))))
\end{verbatim}
\listend

Итак, как использовать функции в роли плагина для управления работой \verb"tree-leaves%"? В обновлённой версии \verb"tree-leaves%", мы добавили две отличающихся функции-плагина, из которых одна предназначена для определения изменяемых листьев, а другая определяет как преобразовывать старый лист в новый лист, соответственно, эти плагины названы как \verb"test" и \verb"result", а новая версия названа как \verb"tree-leaves%%".

Мы можем использовать \verb"tree-leaves%%" передавая ему два лямбда выражения, каждое из которых должно получать единственный аргумент, \verb"x". В данном случае нам нужно получить новое дерево: с той же самой списковой структурой что и наш аргумент \verb"tree", за исключением того, что все чётные числа заменены на символ \verb"even-number":

\begin{verbatim}
* (tree-leaves%%
’(1 2 (3 4 (5 6)))
(lambda (x)
(and (numberp x) (evenp x)))
(lambda (x)
’even-number))
; Note: Variable X defined but never used.
(1 EVEN-NUMBER (3 EVEN-NUMBER (5 EVEN-NUMBER)))
\end{verbatim}

Вроде бы всё работает за исключением того, что лисп корректно вызывает предупреждение по факту не использования переменной \verb"x" во второй функции - плагине. Если мы не используем переменную, то часто это является признаком наличия проблем в коде. Даже если мы умышленно не используем переменную, как в нашем случае, компилятор выдаст информацию о том, какая переменная будет игнорироваться. Обычно мы используем эту переменную, но есть случаи, подобные нашему, когда нам не нужно использование переменной. Очень плохо если мы получаем аргумент для функции - и после всего этого просто игнорируем этот аргумент. Такая ситуация часто возникает при написании гибких макросов. Решением является передача компилятору информации о том, что переменная \verb"x" может быть проигнорирована. Поскольку нет ничего болезненного в объявлении игнорируемой какую-либо переменную и последующем её использовании\footnote{Лисп выяснит что на самом деле не может игнорироваться.}, то мы можем декларировать информацию о том, что обе переменные \verb"x" должны быть игнорируемыми:



\begin{verbatim}
* (tree-leaves%%
’(1 2 (3 4 (5 6)))
(lambda (x)
(declare (ignorable x))
(and (numberp x) (evenp x)))
(lambda (x)
(declare (ignorable x))
’even-number))
(1 EVEN-NUMBER (3 EVEN-NUMBER (5 EVEN-NUMBER)))
\end{verbatim}

Теперь мы подошли к интересному месту этого урока. Похоже что \verb"tree-leaves%%" прекрасно работает и выполняет то, что нам требуется. Мы можем изменить любые листья в дереве передав функции-плагины, которые будут выяснять какой лист нужно изменить и на что изменить. На этом месте улучшение утилиты было бы остановлено в языках программирования отличающихся от лиспа. Но не в лиспе. В лиспе мы можем ещё больше улучшить нашу утилиту.

И хотя \verb"tree-leaves%%" предоставляет нам всю требуемую функциональность, его интерфейс остаётся неудобным и избыточным. Чем проще использование утилиты, тем выше вероятность нахождения интересного применения этой функции. С целью уменьшения беспорядка, окружающего нашу утилиту, мы создадим макрос, предоставляющий неявный контекст его пользователям (ну и конечно, нам самим).

Но вместо применения таких простых приёмов как неявный progn или неявную лямбду, мы используем весь неявный лексический контекст, избавляющий нас от накладных расходов при создании этих функций-плагинов и требующий минимального ввода кода при выполнении таких общих задач, как трансляция деревьев. Этот неявный лексический контекст не похож на простые неявности в том смысле, что в нём мы найдём не только другие способы применения общих неявных шаблонов. Вместо этого мы шаг за шагом разработали не-столь-общий шаблон при работе над нашим интерфейсом прохода по коду \verb"tree-leaves%%".

Листинг 5.9: TREE-LEAVES\label{listing_5.9}
\listbegin
\begin{verbatim}
(defmacro tree-leaves (tree test result)
`(tree-leaves%%
,tree
(lambda (x)
(declare (ignorable x))
,test)
(lambda (x)
(declare (ignorable x))
,result)))
\end{verbatim}
\listend

При конструировании нашего неявного макроса, мы просто скопировали использование \verb"tree-leaves%%" из REPL-а прямо в определение \verb"tree-leaves", а части, которые должны изменяться в различных применениях макроса были параметризованы при помощи обратных кавычек. Теперь, благодаря этому макросу у нас есть менее многословный интерфейс использования утилиты \verb"tree-leaves%%". Конечно, этот интерфейс обособлен, поскольку есть множество путей, с помощью которых мы можем добиться подобного поведения. Однако, созданный нами макрос более интуитивен и более лёгок в применении, по крайней мере, в наших случаях. Макросы позволили нам создать эффективный программный интерфейс простым и лёгким способом, недоступным в других языках. Вот как мы можем применить наш макрос:

\begin{verbatim}
* (tree-leaves
’(1 2 (3 4 (5 . 6)))
(and (numberp x) (evenp x))
’even-number)
(1 EVEN-NUMBER (3 EVEN-NUMBER (5 . EVEN-NUMBER)))
\end{verbatim}

Заметьте, что переменная \verb"x" используется без определения переменной. Причиной этому является \emph{неявная лексическая переменная (implicit lexical variable)}, привязанная к каждому из двух последних переменных. Появление переменной без её объявления называют нарушением \emph{лексической прозрачности (lexical transparency)}. Другими словами можно сказать что \emph{анафора (anaphor)} под названием \verb"x", введена в эти формы для дальнейшего использования из этих форм. В дальнейшем мы очень, очень сильно разовьём эту идею в \emph{главе 6, Анафорические Макросы}.
