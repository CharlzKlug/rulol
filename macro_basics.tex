\chapter{Основы макросов}\label{chapter_macro_basics}
\section{Итеративная Разработка}\label{section_iterative-development}
\begin{quote}
Лисп помог целому ряду одарённых людей размышлять таким образом, какой ранее не был им доступен.

--- Эдсгер Дейкстра\index{Дейкстра, Эдсгер}
\end{quote}

Конструирование макросов --- это итеративный процесс: все сложные макросы начинались из более простых макросов. Отталкиваясь от этой идеи, можно сказать что макросы создаются подобно скульптуре из куска камня. Если реализация макроса оказывается недостаточно гибкой, либо результатом оказывается недостаточно эффективное или опасное расширение, то в этом случае профессиональный программист макросов слегка модифицирует макрос, добавляя функционал или исправляя ошибки до тех пор, пока макрос не будет удовлетворять всем требованиям.

Необходимость итеративного процесса в конструировании макросов возникает отчасти потому, что итеративный процесс программирования --- это наиболее универсальный и эффективный способ программирования, а другая причина заключается в том, что программирование макросов --- это наиболее сложный вид программирования. Поскольку при программировании макросов программисту приходится думать сразу о нескольких уровнях кода, исполняемого в различные моменты времени, то вопросы сложности увеличиваются гораздо быстрее, чем в остальных типах программирования. Итеративный процесс позволяет убедиться в том, что ваша концептуальная модель наиболее полно соответствует тому, что планируется создать. Если бы мы создавали макросы без такой обратной связи, то конструирование макросов стало бы значительно более трудным делом.

В этой главе мы напишем несколько базовых макросов и ознакомимся с двумя основными концепциями макросов: \emph{предметно-ориентированные языки (domain specific languages)\index{предметно-ориентированные языки}} и \emph{структуры управления {\selectlanguage{english}(control structures)}}. После того, как мы изучим эти основные понятия о макросах, мы вернёмся назад и обсудим процесс создания макросов с помощью макросов. На протяжении всей книги мы будем использовать такие техники как захват переменной и введение свободной переменной, кроме этого мы ознакомимся с новым, более удобным синтаксисом определения Лисп макросов.

\section{Предметно-Ориентированные Языки}\label{section_domain_specific_languages}

Common Lisp, наряду с большинством программных сред, предоставляет функцию \textbf{sleep}, которая приостанавливает исполнение процесса на \textbf{n} секунд, где \textbf{n} --- не отрицательный, не комплексный, числовой аргумент. Например, мы можем захотеть уснуть на 3 минуты (180 секунд), в этом случае мы можем вычислить эту форму:

\begin{verbatim}
(sleep 180)
\end{verbatim}

Или, если мы предпочитаем думать о засыпании в терминах минут, то взамен последнего выражения мы можем использовать

\begin{verbatim}
(sleep (* 3 60))
\end{verbatim}

Поскольку компиляторы знают как \emph{сворачивать константы\index{сворачивание константы}}, эти два вызова одинаково эффективны. Для того, чтобы более явно описать наши действия, мы можем определить функцию \textbf{sleep-minutes}:

\begin{verbatim}
(defun sleep-minutes (m)
  (sleep (* m 60)))
\end{verbatim}

Подход с определением новой функции для каждой единицы времени оказывается неуклюжим и неудобным. Что нам нужно --- так это некая абстракция, которая позволяла бы использовать единицу времени вместе со значением. Нам нужен \emph{предметно-ориентированный язык (domain specific language)}.

Решение, которое мы можем использовать в Лиспе может быть таким же, как и в остальных языках программирования: создать функцию, которая будет принимать значение и единицу времени и возвращать значение умноженное на некоторую константу, относящуюся к конкретной единице времени. И тут проявляются удобства, предоставляемые Лиспом при реализации единицы времени. В языках, подобных C принято использовать нижележащие типы данных (например: int) и присваивать произвольные значения, относящиеся к различным единицам времени:

\begin{verbatim}
#define UNIT_SECONDS 1
#define UNIT_MINUTES 2
#define UNIT_HOURS 3

int sleep_units(int value, int unit) {
  switch(value) {
    case UNIT_SECONDS: return value;
    case UNIT_MINUTES: return value*60;
    case UNIT_HOURS: return value*3600;
  }
}
\end{verbatim}

Но в Лиспе самый очевидный путь обозначения желаемой единицы --- это использование символа. Символ в Лиспе --- это нечто, не \textbf{eq}'альное другим символам. \textbf{Eq} --- это самый быстрый оператор сравнения в Лиспе и примерно соответствует сравнению указателей. Поскольку сравнение указателей производится очень быстро, то символы предоставляют нам очень быстрый и удобный способ определения равенства двух и более различных Лисп выражений. В Лиспе мы должны определить функцию \textbf{sleep-units\%}\footnote{Примечание переводчика: При компилировании этого кода происходит вывод предупреждений. Я предлагаю использовать следующий вариант:

\texttt{(defun sleep-units\% (value unit)}

\texttt{\quad(defun unit-to-second (unit)}

\texttt{\qquad(case unit}

\texttt{\qquad\quad((s) 1)}

\texttt{\qquad\quad((m) 60)}

\texttt{\qquad\quad((h) 3600)}

\texttt{\qquad\quad((d) 86400)}

\texttt{\qquad\quad((ms) 1/1000)}

\texttt{\qquad\quad((us) 1/1000000)))}

\texttt{\quad(sleep (* value (unit-to-second unit))))}

}, после этого мы можем использовать единицы времени в наших формах:

\begin{verbatim}
(sleep-units% 2 'm)
(sleep-units% 500 'us)
\end{verbatim}

\begin{figure}Листинг 3.1: SLEEP-UNITS-1\label{listing_3.1}
\listbegin
\begin{verbatim}
(defun sleep-units% (value unit)
  (sleep
   (* value
      (case unit
        ((3) 1)
        ((m) 60)
        ((h) 3600)
        ((d) 86400)
        ((ms) 1/1000)
        ((us) 1/1000000)))))
\end{verbatim}
\listend
\end{figure}


Поскольку сравнение символов требует сравнения только одного указателя, \textbf{sleep-units\%} будет скомпилирован в очень быструю диспетчеризацию во времени выполнения:

\begin{verbatim}
...
524: CMP ESI, [#x586FC4D0] ; ’S
52A: JEQ L11
530: CMP ESI, [#x586FC4D4] ; ’M
536: JEQ L10
538: CMP ESI, [#x586FC4D8] ; ’H
53E: JEQ L9
540: CMP ESI, [#x586FC4DC] ; ’D
546:
...
\end{verbatim}

Заметьте, как должна закавычиваться единица времени, указанная в \textbf{sleep-units\%}. Это происходит потому, что Лисп начинает вычисление функции с вычисления всех аргументов функции и привязывает результаты к переменным, использующимся внутри функции. Числа, строки и некоторые другие примитивы вычисляются в самих себя, поэтому нам не нужно закавычивать числовые значения, переданные в \textbf{sleep-units\%}. Если же вы хотите чтобы и эти значения не вычислялись, то вы можете закавычить и их:

\begin{verbatim}
(sleep-units% '.5 's)
\end{verbatim}

Однако, как правило, символы не вычисляются в самих себя\footnote{Как правило, нет правил без исключения. Некоторые символы вычисляются в самих себя, например: \textbf{t}, \textbf{nil} и ключевые слова.}. Когда Лисп вычисляет символ, то он предполагает, что вы ссылаетесь на переменную и пытается найти значение, ассоциированное с этой переменной в заданном лексическом контексте (если же переменная объявлена как специальная, то в этом случае поиск происходит в динамическом окружении).

Если мы хотим избежать закавычивания единицы времени, то нам нужно использовать макрос. В отличие от функции макрос не вычисляет свои аргументы. Для того, чтобы воспользоваться этим фактом, мы заменим функцию \textbf{sleep-units\%} макросом \textbf{sleep-units}. Теперь нам не нужно закавычивать единицу времени:

\begin{verbatim}
(sleep-units .5 h)
\end{verbatim}

\begin{figure}Листинг 3.2: SLEEP-UNITS\label{listing_3.2}
\listbegin
\begin{verbatim}
(defmacro sleep-units (value unit)
  `(sleep
    (* ,value
     ,(case unit
            ((s) 1)
            ((m) 60)
            ((h) 3600)
            ((d) 86400)
            ((ms) 1/1000)
            ((us) 1/1000000)))))
\end{verbatim}
\listend
\end{figure}

И хотя основным предназначением макроса было избежание закавычивания аргумента \textbf{unit}, этот макрос оказывается даже более эффективным чем функция, поскольку не производится диспетчеризация во время выполнения: единица времени и, следовательно, множитель известны в момент компилирования. Конечно, когда мы сталкиваемся с ситуацией слишком-хорошо-чтобы-быть-правдой, то чаще всего всё действительно оказывается слишком хорошим, чтобы быть правдой. Выигрыш в эффективности не даётся бесплатно. Отказавшись от диспетчеризации во время выполнения мы теряем способность определять единицу времени во время выполнения. Используя наш макрос мы не можем выполнить следующий код:

\begin{verbatim}
(sleep-units 1 (if super-slow-mode 'd 'h))
\end{verbatim}

Это не сработает, поскольку \textbf{sleep-units} ожидает что второй аргумент будет одним из символов, в нашем случае вторым аргументом выступает список в котором первым элементом является \textbf{if}.

Напомним, что большинство макросов писались для того, чтобы создать более удобные и полезные программные абстракции, и не предназначались для улучшения эффективности нижележащего кода. Возможно ли извлечь некоторые идиомы из этого кода, с тем, чтобы сделать его более полезным для остальной части нашей программы (и, возможно, для наших будущих программ)? Уже сейчас можно предсказать, что мы можем захотеть выполнять разные операции с временными значениями, чем простой вызов \textbf{sleep}. Макрос \textbf{unit-of-time} абстрагирует функциональность из макроса \textbf{sleep-units}, возвращая значение вместо вызова \textbf{sleep}. Параметр \textbf{value} может определяться во время выполнения программы, поскольку он является вычисляемым, но \textbf{unit} не является вычисляемым, поскольку нам нужна информация во время компиляции, также, как и при \textbf{sleep-units}. Вот пример:

\begin{verbatim}
 * (unit-of-time 1 d)
 86400
\end{verbatim}

\begin{figure}Листинг 3.3: UNIT-OF-TIME\label{listing_3.3}
\listbegin
\begin{verbatim}
(defmacro unit-of-time (value unit)
  `(* ,value
      ,(case unit
             ((s) 1)
             ((m) 60)
             ((h) 3600)
             ((d) 86400)
             ((ms) 1/1000)
             ((us) 1/1000000))))
\end{verbatim}
\listend
\end{figure}

Такой простой макрос как \textbf{unit-of-time} даёт нам более лучший синтаксис для решения конкретных областей некоторых проблем и может значительно улучшить продуктивность работы и корректность решения задачи. В \emph{разделе Программирование Сверху-Вниз} мы продолжим разработку языка единиц. В отличие от большинства языков программирования, в Лиспе вам доступны те же инструменты, что и у людей создавших вашу программную среду. Для того, чтобы реализовать язык Common Lisp, достаточно использовать макросы, этих же макросов достаточно, чтобы реализовать ваш собственный предметно-ориентированный язык.

\section{Управляющие Структуры}\label{section_control_structures}

Хотя эта книга ориентирована на Common Lisp, идеи, описанные здесь можно применить и для языка программирования Scheme. Scheme --- это замечательный язык, и хотя в Scheme отсутствуют многие особенности воспринимаемые Лисп программистами как должное, в нём есть достаточно гибкое ядро, которое при необходимости могут расширить профессиональные Лисп программисты\footnote{В основном, Scheme и Common Lisp различаются в своих сообществах. Scheme программисты любят говорить о том, как здорово иметь короткую спецификацию языка; Common Lisp программисты любят писать программы.}. Аналогичным образом, Scheme программисты приводят, в качестве преимущества, особенности на которых не делается ставка в Common Lisp. Но, сравнение особенностей всех языков, кроме некоторых особенностей, бессмысленно. Часто мы в состоянии перебросить мост между двумя языками. Само собой разумеется, что в роли моста, с помощью которых мы объединяем два языка выступают макросы.

Scheme'овская форма \textbf{let} является более мощной чем её коллега в Common Lisp. Scheme'овская форма \textbf{let} поддерживает нечто, под названием \emph{именованный let (named let)\index{именованный let}}. В Scheme вы можете вставить символ перед списком привязок \textbf{let} формы и Scheme привяжет функцию под указанным символом вокруг тела \textbf{let}\footnote{В Scheme есть только одно пространство имён, поэтому функция привязывается именно здесь.}. Эта функция принимает новые аргументы для значений, указанных в привязках \textbf{let}, предоставляя очень удобный способ выражения циклов.

\begin{figure}Листинг 3.4: NLET\label{listing_3.4}
\listbegin
\begin{verbatim}
(defmacro nlet (n letargs &rest body)
  `(labels ((,n ,(mapcar #'car letargs)
              ,@body))
     (,n ,@(mapcar #'cadr letargs))))
\end{verbatim}
\listend
\end{figure}

К счастью, мы можем построить мост между Scheme и Common Lisp с помощью макроса \textbf{nlet}. \textbf{Nlet} даёт нам возможность писать код в Scheme стиле эмулируя Scheme'овские именованные \textbf{let}'ы. В \textbf{nlet-fact}, \textbf{nlet} используется для определения функции факториала с помощью именованного \textbf{let}:

\begin{verbatim}
(defun nlet-fact (n)
  (nlet fact ((n n))
        (if (zerop n)
            1
            (* n (fact (- n 1))))))
\end{verbatim}

Поскольку \textbf{nlet} --- это наш первый макрос, сделаем паузу и изучим этот макрос глубже. Иногда для того чтобы понять макрос полезно применить \emph{macroexpand} к примеру, показывающему использование этого макроса\footnote{Терминология расширения на самом деле довольно неудачна. Никто не говорит что при \emph{макрорасширении\index{макрорасширение}} чего-либо результатом будет больший, расширенный код. Иногда формы расширяются даже в ничто (т.е. \textbf{nil}).}. Для этого функции \textbf{macroexpand} мы передадим список, представляющий вызов макроса. Учтите, что \textbf{macroexpand} будет расширять макросы, в которых первый символ списка является макрос символом и не расширяет вложенные макро вызовы\footnote{Но, \textbf{macroexpand} будет продолжать расширение макроса до тех пор, пока первый элемент не будет представлять макрос. \textbf{Macroexpand-1} полезен для наблюдения первого шага в этом процессе.}. Теперь мы скопируем вызов \textbf{nlet} прямо из \textbf{nlet-fact}, закавычим его и передадим в \textbf{macroexpand}:

\begin{verbatim}
CL-USER> (macroexpand
          '(nlet fact ((n n))
            (if (zerop n)
                1
                (* n (fact (- n 1))))))
(LABELS ((FACT (N)
           (IF (ZEROP N)
               1
               (* N (FACT (- N 1))))))
  (FACT N))
T
\end{verbatim}

Расширение использует специальную форму \textbf{labels}, предназначенную для привязки функции вокруг указанного тела. Именованная функция соответствует символу, используемому в форме именованного \textbf{let}. Он получает аргументы значений, привязанных с помощью \textbf{nlet}, в данном случае только \textbf{n}. Поскольку эта функция может быть рекурсивной, \textbf{nlet} реализует полезную итерационную конструкцию.

В простых макросах обычно достаточно использовать обратные кавычки, но более сложные макросы должны использовать хотя бы Лисповские функции обработки списков. \textbf{Mapcar}, применяет функцию к каждому элементу списка и возвращает список из получившихся значений, особенно часто появляется в макросах. Что характерно, \textbf{mapcar} довольно часто появляется и в обычных Лисп программах. Лисп можно настроить так, чтобы его можно было по максимуму использовать для обработки списков. Во всех разновидностях Лисп программирования мы занимаемся тем, что объединяем, разделяем, уменьшаем, отображаем и фильтруем списки. Единственная разница в том, что при программировании макросов вывод непосредственно переходит к компилятору или интерпретатору. Программирование макросов в Лиспе --- это, по сути, то же самое что и обычное Лисп программирование.

Но что даёт нам право сказать что \textbf{nlet} --- это новая управляющая структура? Управляющая структура --- это всего лишь забавный способ определения некоторой конструкции, которая не следует поведению функции. Функция вычисляет каждый аргумент слева направо, привязывает результаты в среде и выполняет машинный код, определённый в некоторой \textbf{lambda} форме. Поскольку \textbf{nlet} не вычисляет напрямую свои аргументы, а вместо этого объединяет их в некоторый кусок Лисп кода, мы изменили выполнение вычисления для \textbf{nlet} форм и тем самым создали новую управляющую структуру.

Руководствуясь этим грубым определением, можно сказать что все макросы --- по крайней мере все интересные макросы --- определяют новые управляющие структуры. Когда люди говорят ``используйте макросы только тогда, когда недостаточно функций'', они имеют ввиду определения, где вы не хотите допустить вычисление некоторых аргументов или вы хотите вычислить аргументы в другом порядке или хотите чтобы аргументы вычислялись несколько раз, то в этом случае вам нужно использовать макросы. Функции, вне зависимости от того насколько хорошо они написаны, просто не будут выполнять эти задачи.

Common Lisp очень удобен для создания макросов, макрос \textbf{nlet} показывает одно из этих преимуществ. В таких формах привязки как \textbf{let}, существует общее соглашение, которое гласит: если переменной не привязано какое-либо значение, то эта переменная будет привязана к \textbf{nil}. Другими словами результатом вычисления \verb"(let ((a)) a)" будет \textbf{nil}\footnote{Common Lisp позволяет нам писать даже так: \verb"(let (a) a)" что в итоге даст все тот-же эффект.}. В Scheme, а этот язык менее дружественный к созданию макросов, этот случай должен проверяться как частный случай при итерации с подобными привязками, по причине того, что \verb"(car nil)" и \verb"(cdr nil)" вернут ошибки типа. В Common Lisp \verb"(car nil)", \verb"(cdr nil)" и, следовательно, \verb"(car (cdr nil))" и \verb"(cadr nil)" вернут \textbf{nil}, позволяя второму \textbf{mapcar} в \textbf{nlet} продолжать работу даже если используется соглашение о пустом \textbf{let} значении. Эта особенность Common Lisp взята из Interlisp\index{Interlisp} [INTERLISP].

Наш макрос \textbf{nlet} отличается от именованного \textbf{let} в Scheme очень маленькой деталью. В этом случае интерфейс макроса является приемлемым, но расширения может и не быть. В общем случае, при программировании через несколько уровней, наша ментальная модель кода может немного отличаться от реальности. В Scheme, при выполнении хвостовой рекурсии именованного \textbf{let} гарантируется неупотребление дополнительного стекового пространства, поскольку Scheme гарантирует, согласно стандарту, выполнение специальной оптимизации. Это не тот случай в Common Lisp, поэтому не исключается переполнение стека в Common Lisp'овской версии \textbf{nlet}, чего не произойдёт с именованным \textbf{let} в Scheme. В \emph{разделе Проход по Коду с Macrolet} мы рассмотрим как написать версию \textbf{nlet} с идентичным интерфейсом но, с потенциально более эффективным расширением\footnote{На практике, обычно бывает достаточно и этой версии \textbf{nlet}, поскольку компилятор Common Lisp почти наверняка оптимизирует хвостовые вызовы в скомпилированном коде.}.

\section{Свободные Переменные}\label{section_free_variables}

\emph{Свободная переменная (free variable)\index{свободная переменная}} --- это любая переменная или функция, ссылающаяся на выражение, не имеющее специальной глобальной привязки или ограничивающей лексической привязки. В следующем выражении \textbf{x} является свободной переменной:

\begin{verbatim}
(+ 1 x)
\end{verbatim}

В следующем примере мы создаём привязку вокруг формы, эта привязка \emph{захватывает (captures)\index{захват переменной}} переменную \textbf{x}, лишая её свободы:

\begin{verbatim}
(let ((x 1))
  (+ 1 x))
\end{verbatim}

На первый взгляд терминология свободы и захвата может показаться странной. В конце концов, свобода подразумевает сознательность и возможность принятия решений --- очевидно, что выразить всё простым выражением не получится. Но свобода не относится к тому, что может выполнять выражение, скорее, это относится к тому, что мы, как программист, можем выполнять с этим выражением. Например, мы можем взять выражение \verb'(+ 1 x)' и встроить его куда-либо ещё, позволяя нашему выражению получить доступ к \textbf{x}, привязанному к окружающему коду. Затем мы можем сказать что код \emph{захватил (captured)\index{захват переменной}} нашу свободную переменную. После того, как свободные переменные в выражении были захвачены, как в предыдущей форме \textbf{let}, другой окружающий код не может захватить нашу переменную \textbf{x}. Наша в прошлом свободная переменная уже была захвачена. Теперь вполне однозначно ясно куда ссылается \textbf{x}. По этой причине понятно почему Лиспу не надо хранить значение, на которое ссылается символ \textbf{x} на протяжении всего кода. Как мы описали в деталях в \emph{разделе Лексическая и Динамическая Области Видимости}, Лисп компиляторы забывают символы, которые были использованы для представления лексических переменных.

Возможности макросов означают что свободные переменные в Лиспе гораздо более полезны чем в других языках, хотя в любом, поддерживающим выражения, языке может быть код со свободными переменными. В большинстве языках мы вынуждены подчиняться \emph{ссылочной прозрачности (referential transparency)\index{ссылочная прозрачность}}. Если в Блаб языке не объявлена глобальная или объектная переменная \textbf{x}, то следующий код безусловно неверен:

\begin{verbatim}
some_function_or_method() {
  anything(1 + x);
\end{verbatim}

Нет никакого способа, с помощью которого {\selectlanguage{english}\textbf{so\-me\_func\-tion\_or\_me\-thod}} мог бы создать \emph{неявную привязку\index{неявные!привязки}} к \textbf{x}. В Блабе любое использование переменной должно быть текстово очевидным определением\footnote{Или, иногда, в объектно-ориентированном Блабе, определения класса или объекта.}. Языки с примитивной макро системой (такие как C) могут реализовывать некоторые приёмы, но, реализация этих приёмов весьма ограничена. Создание макросов в C непрактично или невозможно, также, как и частные случаи использования свободных переменных.

В Лиспе мы можем оперировать выражениями со свободными переменными так, как нам заблагорассудится и либо объединить их в новое выражение, захватываемое окружающим кодом, или определить специальные глобальные переменные для последующего захвата. Также мы можем написать макрос, который модифицирует и освобождает переменные в выражении или переписывает выражение с целью уменьшения количества свободных переменных (например, как представлено выше, оборачивая выражение в \textbf{let} форму) или модифицируя выражение с целью добавления новых свободных переменных. Такое добавление свободных переменных является противоположностью захвата переменных и называется \emph{инъекцией свободной переменной (free variable injection)\index{свободная переменная!инъекция}}.

Простейшей инъекцией свободной переменной является макрос, расширяющийся в ссылку на символ:

\begin{verbatim}
(defmacro x-injector ()
  'x)
\end{verbatim}

Поскольку макрос --- это та же функция, то он исполняет своё тело как обычную Лисп форму. Вышеприведённый макрос --- инжектор вычисляет закавыченный символ и, конечно, возвращает символ --- свободную переменную --- которая будет объединена с любым, использующим макрос \textbf{x-injector}, выражением. Обсуждая такие инъекции свободных переменных в \emph{On Lisp}, Пол Грэм\index{Грэм, Пол} написал

\begin{quote}
\emph{Подобная разновидность лексических взаимодействий обычно рассматривается как источник проблем, нежели как источник удовольствия. Обычно написание макросов в таком ключе является плохим стилем. Из всех макросов в этой книге, только [два изолированных случая] используют вызов среды подобным способом.}
\end{quote}

В противоположность \emph{On Lisp} в этой книге получают большое удовольствие от таких разновидностей лексических взаимодействий. Инъекция свободной переменной --- это создание макроса с полным знанием лексической среды, в которую он будет расширен --- это всего лишь другой подход к программированию Лисп макросов, который особенно полезен при наличии нескольких немного отличающихся лексических контекстов, в которых вы можете захотеть написать почти идентичный код. Хотя главным преимуществом вызова функций является вынос за пределы функции вашей лексической среды, иногда, для Лисп программистов, это всего лишь руководство к действию, которое может быть проигнорировано через использование макросов. Фактически, только привыкнув к этому, некоторые Лисп программисты по возможности всегда стараются писать макросы, расширяя лексический контекст настолько, насколько это возможно, и используют функции только когда им нужно вычислить аргументы или просто для того, чтобы поджать хвост при желании нового лексического контекста. В \emph{разделе Once Only} мы рассмотрим способ не допустить вывода наружу вашей лексической среды при вычислении аргументов. Сохранение окружающей лексической среды до тех пор, пока это возможно, позволяет нам выполнять очень интересные \emph{комбинации (combinations)\index{макрос!комбинации}} макросов, где макрос добавляет окружающий лексический контекст для использования несколькими другим макросами. Расширения в коде, которые очень сильно используют макросы будут определены как частный случай комбинации макросов и будут рассмотрены в \emph{разделе Рекурсивные Расширения}.

Кратчайший путь между двумя точками --- это прямая линия. Свободные переменные и, более глобально, расширенные лексические контексты --- это наиболее простейший способ программного построения программ. Здесь применение макросов может показаться хаком и нежелательным со стилистической точки зрения, но даже здесь использование макросов удобно и надёжно. Особенно после того, как мы рассмотрим \textbf{macrolet} в \emph{разделе Проход по Коду с помощью Macrolet}, этот стиль программирования --- комбинирование макросов --- покажется вам более комфортабельным. Только помните, что программирование макросов --- это не вопрос стиля; это вопрос мощи. Макросы дают нам возможность выполнять такие вещи, реализация которых невозможна в других языках. Одна из них --- это инъекция свободной переменной.

\section{Нежелательный Захват}\label{section_unwanted_capture}

Существуют две точки зрения на захват переменной. Захват переменной --- это источник некоторых непредсказуемых багов, но, при правильном использовании может быть весьма желаемой особенностью макросов. Начнём рассмотрение захвата переменной с простого макроса, определённого Грэмом в \emph{On Lisp}: \textbf{nif}. \textbf{Nif} --- это \emph{числовой if\index{if!числовой}}, который имеет четыре обязательных пункта, по сравнению с обычным \textbf{if}, который имеет два обязательных пункта и необязательный третий пункт. \textbf{Nif}, или вернее код, в который расширяется \textbf{nif}, вычисляет первый пункт и предполагает, что результат будет не комплексным числом. Далее число вычисляется в одно из трёх пунктов, которое в зависимости от результата может быть положительным (\textbf{plusp}), нулём (\textbf{zerop}) или отрицательным (3-й пункт). Мы можем использовать его для проверки переменной \textbf{x}, следующим способом:

\begin{verbatim}
(nif x "positive" "zero" "negative")
\end{verbatim}

 \textbf{Nif} --- это идеальная функция для обсуждения захвата переменной и мы будем использовать его в качестве иллюстрации некоторых ключевых пунктов, а также, тестового варианта для новых обозначений при конструировании макросов. Прежде чем перейти к версии \textbf{nif} созданной Грэмом, определим почти правильную, но, немного забагованную версию:

\begin{verbatim}
(defmacro nif-buggy (expr pos zero neg)
  `(let ((obscure-name ,expr))
     (cond ((plusp obscure-name) ,pos)
           ((zerop obscure-name) ,zero)
           (t ,neg))))
\end{verbatim}

 \textbf{Niff-buggy} расширяется в маленький кусок кода, который использует \textbf{let} для привязки результата вычисления предоставленной пользователем формы \textbf{expr}. Мы делаем это потому, что вычисление \textbf{expr} может привести к \emph{побочным эффектам (side-effects)\index{побочные эффекты}}, а полученное значение нужно для двух раздельных операций: передача значения в \textbf{plusp} и передача значения в \textbf{zerop}. Но зачем мы вызываем эту временную привязку? Маленькая ошибка появляется из-за введения постороннего символа, \textbf{obscure-name}. Если никто не будет смотреть на расширение макроса, то никто не заметит это имя, вроде бы это не проблема, не так-ли?

В большинстве случаев \textbf{nif-buggy} будет работать также, как и \textbf{nif}. Если символ \textbf{obscure-name} не будет использоваться в формах, передаваемых в \textbf{nif-buggy}\footnote{Или в макро расширениях переданного кода. Смотрите сублексическую область видимости.}, то не будет и нежелательного захвата переменной. Но что произойдёт если \textbf{obscure-name} появится в переданных формах? В большинстве случаев, баг по прежнему не будет проявляться:

\begin{verbatim}
(nif-buggy
  x
  (let ((obscure-name 'pos))
    obscure-name)
  'zero
  'neg)
\end{verbatim}

Даже если  \textbf{x} будет положительным, и даже если присутствует инъецированный запрещённый символ в макро расширении  \textbf{nif-buggy}, этот код будет работать так, как и было задумано. Если созданы новые привязки, а код внутри привязки всегда ссылается на созданную привязку, то в этом случае нежелательный захват переменной не возникает. Проблема возникнет только тогда, когда использование  \textbf{obscure-name}  \emph{пересечёт своё\index{пересечение}} использование в расширении. Вот пример нежелательного захвата переменной:

\begin{verbatim}
(let ((obscure-name 'pos))
  (nif-buggy
    x
    obscure-name
    'zero
    'neg))
\end{verbatim}

В этом случае, \textbf{obscure-name} будет привязываться к результату вычисления \textbf{x}, поэтому, вопреки задумке, символ \textbf{pos} не будет возвращаться\footnote{Конечно, на самом деле это неправильное поведение было намеренным. Проблемы с захватом переменных очень редко бывают такими очевидными и запланированными. Гораздо чаще они бывают менее очевидными и неожиданными.}. Происходит это по причине того, что наше использование символа пересекается с невидимым использованием привязки. Иногда упоминая код с такими невидимыми привязками, говорят что он не \emph{ссылочно прозрачен\index{ссылочная прозрачность}}.

Но разве это не академический вопрос? Конечно, мы можем подумать о достаточно редких именах, таких, при использовании которых эта проблема никогда не появится. Да, во многих случаях пакеты и грамотное именование переменных может решить проблему захвата переменной. В коде, непосредственно написанном программистом, редко возникают баги, связанные с захватом переменной. Большинство проблем с захватом переменной проявляются тогда, когда другие макросы начинают использовать ваши макросы (комбинируются с вашими макросами) самым неожиданным образом. Пол Грэм даёт прямой ответ на вопрос о защите от нежелательного захвата переменной:

\begin{quote}
Зачем писать программы с маленькими багами, когда вы можете писать программы без багов?
\end{quote}

Я думаю мы можем развить этот вопрос дальше: вне зависимости от тонкости проблемы, зачем делать что-то неправильно, когда вы можете делать это правильно?

К счастью, оказывается, что захват переменной, в тех случаях, когда это является проблемой, --- это задача с простым решением. Последнее утверждение --- это спорный вопрос для многих людей, особенно для тех, кто не любит очевидные решения и посвящают большую часть своего времени на поиски других решений. Как профессиональному программисту макросов, вам придётся столкнуться со многими решениями проблемы захвата переменной. Текущее популярное решение --- это использование так называемых \emph{гигиенических макросов (hygienic macros)\index{макрос!гигиенический}}\footnote{Другой популярный термин --- это \emph{"макросы по примеру" ("macros by example")}.}. Эти решения пытаются ограничить или устранить воздействие нежелательных захватов переменной, но, к несчастью выполняют это за счёт желательных захватов переменной. Почти все подходы, используемые для уменьшения воздействия захвата переменной, также ограничивают вас в использовании \textbf{defmacro}. Гигиенические макросы, в лучшем случае, --- это ограждение, предназначенное для безопасности новичков; а в худшем случае гигиенические макросы принимают форму электрического забора, помещающего свои жертвы в стерильную, захвато-безопасную тюрьму. Более того, недавние исследования показали, что гигиенические макро системы, подобные тем, что реализованы в различных ревизиях Scheme, могут быть уязвимы ко многим интересным проблемам захвата [SYNTAX-RULES-INSANE] [SYNTAX-RULES-UNHYGIENIC].

Настоящее решение проблемы захвата переменных известно как \emph{генерированный символ (generated symbol)\index{gensym}\index{сгенерированные символы|see{gensym}}} или, кратко, \emph{gensym}. \textbf{Gensym} --- это способ, с помощью которого Лисп получает имя для нашей переменной. Но, вместо того, чтобы использовать такие неудачные имена как наш \textbf{obscure-name}, Лисп использует хорошие имена. Действительно хорошие имена. Эти имена настолько хороши и уникальны, что нет такого способа (кроме самого \textbf{gensym}) по которым можно было бы создать такое имя снова. Каким образом это становится возможным? В Common Lisp символы (имена) ассоциируются с \emph{пакетами (packages)\index{пакеты}}. Пакет --- это коллекция символов, из которых вы можете получить указатели к строкам их \textbf{symbol-name} \textbf{(имя-символа)}. Самым важным свойством этих указателей (обычно просто называемых символами) в том что они будут \textbf{eq}'абельны остальным указателям (символам), обнаруживаемым в этом пакете с тем же самым \textbf{symbol-name}. \textbf{Gensym} --- это символ, который не существует ни в одном пакете, поэтому не существует такого \textbf{symbol-name}, который бы вернул символ \textbf{eq}'абельный \textbf{gensym}'у. \textbf{Gensym}'ы нужны тогда, когда вам нужно дать знать Лиспу что некоторый символ должен быть \textbf{eq}'абелен некоторым другим символам в выражении без необходимости их именования. Поскольку вы ничему не даёте имён, то, соответственно, не происходит никаких столкновений имён.

Таким образом, следуя этим трём несложным, но очень важным правилам, решение проблемы нежелательного захвата переменной в {\selectlanguage{english}Common Lisp} становится простой задачей:

\begin{quote}
Всякий раз, когда вы оборачиваете ваш код в макросе лексической или динамической привязкой, то для именования этой привязки используйте \textbf{gensym}, исключая те случаи, когда вам нужен захват переменной.
\end{quote}

\begin{quote}
Каждый раз, когда вы оборачиваете привязку функции или \textbf{macrolet} или макрос \textbf{symbol-macrolet} вокруг кода вашего макроса, и вы хотите чтобы эти элементы не захватывались в оборачиваемом коде, то именование этого макроса или функции нужно выполнять с помощью \textbf{gensym}. Убедитесь, что эта привязка не конфликтует с остальными специальными формами, макросами или функциями, определёнными по стандарту.
\end{quote}

\begin{quote}
Никогда не определяйте или пере-привязывайте специальную форму, макрос или функцию, определённую в Common Lisp.
\end{quote}

Существуют некоторые, отличающиеся от Common Lisp, Лиспы, такие как {\selectlanguage{english}Scheme}, обладащие неудачным свойством комбинирования пространства имён переменных с пространством имён функций/макросов. Иногда эти Лиспы называются \emph{lisp-1\index{lisp-1}}, в отличие от Common Lisp с его разделённым пространством имён, который называется \emph{lisp-2\index{lisp-2}}. При работе с макросами в гипотетическом \emph{lisp-1\index{lisp-1}} нам придётся следовать дополнительным двум правилам:

\begin{quote}
Убедитесь, что добавленные лексические или динамические привязки не конфликтуют с добавленными функциями или макро привязками, или любыми другими специальными формами, макросами или функциями, определёнными по стандарту.
\end{quote}

\begin{quote}
Убедитесь, что добавленная функция или макро привязка не конфликтует с добавленными лексическими или динамическими привязками.
\end{quote}

Мудрое архитектурное решение отделения пространства имён переменных от пространства имён функций в Common Lisp устраняет большую часть проблем связанных с нежелательным захватом переменной. Конечно, \emph{lisp-1} Лиспы не содержат никаких теоретических барьеров в создании макросов: если мы будем следовать предыдущим двум правилам, то мы можем избежать захвата переменной тем же способом что и в Common Lisp. Однако, отслеживание символов в единственном и изолированном пространстве имён может значительно усложниться при программировании сложных макросов. Присутствие взаимного обмена именами позволяет сделать вывод о том, что процесс создания макросов станет сложнее.

Scheme --- замечательный язык, но проблема незавершённого стандарта\footnote{Это касается и макросов и исключений.}, это также касается единственного пространства имён, перевешивает все достоинства этого языка и делает его непригодным к созданию серьёзных макро конструкций\footnote{На протяжении всей книги мы увидим что есть множество причин предпочесть Common Lisp, а не Scheme.}. Ричард Гэбриэл\index{Гэбриэл, Ричард} и Кент Питман\index{Питман, Кент} обобщили эту проблему в следующей запоминающейся цитате [LISP2-4LIFE]:

\begin{quote}
Есть две точки зрения на проблему макросов и пространств имён. Первая в том, что единственное пространство имён носит фундаментальный характер, следовательно, макросы являются проблемой. Вторая заключается в том, что макросы --- фундаментальны, следовательно, единое пространство имён является проблемой.
\end{quote}

Поскольку число пространств имён менее важно возможности конструирования макросов, то можно сделать вывод, что Scheme --- это \emph{неправильный\index{неправильно}} выбор, а Common Lisp --- это \emph{правильный\index{правильный}} выбор.

Тем не менее, постоянный вызов \textbf{gensym} каждый раз, когда нам нужен безымянный символ --- это неудобно и неуклюже. Нет ничего удивительного, в том, что разработчики Scheme экспериментировали с так называемой \emph{гигиенической\index{макрос!гигиенический}} макро системой для того, чтобы не печатать \textbf{gensym} постоянно. В Scheme конструирование макросов построено через предметно-ориентированный язык. Это был неправильный выбор. Scheme --- это чрезвычайно мощный мини-язык, но в этом был потерян смысл макросов: макросы мощны тем, что написаны на Лиспе, а не на упрощённом пре-процессорном языке.

Эта книга представляет новый синтаксис для \textbf{gensym}'ов, преимущество этого синтаксиса в том, что он до разумных размеров короче чем традиционные Лисп выражения. Наш новый синтаксис для \textbf{gensym}'ов, который будет использоваться как основа для большинства макросов в этой книге, можно более точно охарактеризовать как снятие слоёв с простого макроса, использующего наш синтаксис. Продолжим рассматривать пример \textbf{nif}, с предыдущего раздела. Вот как Грэм определяет захвато-безопасный \textbf{nif}:

\begin{verbatim}
(defmacro nif (expr pos zero neg)
  (let ((g (gensym)))
    `(let ((,g ,expr))
       (cond ((plusp ,g) ,pos)
             ((zerop ,g) ,zero)
             (t ,neg)))))
\end{verbatim}

Это пример корректного использования \textbf{gensym}. Как мы увидели в предыдущем разделе, макрос, который может расширить ввод пользователя в нечто, могущее наложиться на одну из его переменных, должен заботиться о захвате переменной. Грэм представляет макрос аббревиатуру \textbf{with-gensyms}, сокращающий текст в случаях, когда нужно создать несколько \textbf{gensym}'ов:

\begin{verbatim}
(with-gensyms (a b c)
  ...)
\end{verbatim}

Расширяется в

\begin{verbatim}
(let ((a (gensym))
      (b (gensym))
      (c (gensym)))
  ...)
\end{verbatim}

Поскольку \textbf{gensym} очень широко используется в форме \textbf{defmacro}, мы решили продолжить дальнейшее сокращение. В частности, заметьте, что для каждого \textbf{gensym}'а мы печатаем временное имя (такое, как \textbf{a}, \textbf{b} и \textbf{c}) по крайней мере дважды: первый раз когда мы объявляем его \textbf{gensym}'ом и другой раз, когда используем его. Можем ли мы устранить эту избыточность?

Для начала рассмотрим как макрос \textbf{nif} использует \textbf{gensym}'ы. При расширении макроса \textbf{nif} происходит вызов \textbf{gensym}, который возвращает сгенерированный символ. Поскольку гарантируется уникальность этого символа, мы можем безопасно использовать его в расширении макроса, будучи уверенными в том, что этот символ никогда не будет захвачен через какую-либо непреднамеренную ссылку. Но, нам по прежнему необходимо как то называть этот \textbf{gensym} в определении макроса для того, чтобы мы могли использовать его в нужных местах в расширении. Грэм, в пределах макроса \textbf{nif} называет этот \textbf{gensym} как \textbf{g}. Учтите, что это имя никогда не появится в макро расширении \textbf{nif}:

\begin{verbatim}
CL-USER> (macroexpand '(nif x 'pos 'zero 'neg))
(LET ((#:G1194 X))
  (COND ((PLUSP #:G1194) 'POS) 
        ((ZEROP #:G1194) 'ZERO) 
        (T 'NEG)))
T
\end{verbatim}

Название \textbf{g} исчезает в расширении макроса. Поскольку \textbf{g} был привязан только к нашей среде расширителя, имя, данное такой переменной не имеет никакого отношения к захваченному имени в расширениях. Все \textbf{g} в расширении будут замещены символом с именем \textbf{G1605}. Перед именем стоит префикс \verb"#:" и обозначает, что символ не \emph{входит\index{входит}} ни в один пакет --- это \textbf{gensym}. При печати форм, обязательно следует использовать такие префиксы, поскольку Лисп должен прекратить работу если мы захотим использовать (вычислить) эту форму после его прочтения. Мы должны прервать работу Лиспа по той причине, что невозможно просто глядя на два имена \textbf{gensym}'ов сказать, являются ли они \textbf{eq}'абельными или нет --- это остаётся на усмотрении системы. Лисп прерывает работу интересным способом: поскольку каждый раз символ \verb"#:" считывает новый созданный символ, а поскольку \verb"(eq '#:a '#:a)" никогда не будет истинным значением, по той причине, что внутренние символы \verb"#:G1605" в предыдущем расширении не соответствуют привязкам, созданным формой \textbf{let}, Лисп считает что выражение обладает свободной переменной, давая нам знать что эта форма обладает \textbf{gensym}'ами.

Несмотря на \textbf{gensym}'овское поведение по-умолчанию, всё же возможно сохранение и перезагрузка макро расширений. Для более точного отображения напечатанных отображений формы с \textbf{gensym}'ами, мы можем включить режим \textbf{*print-circle*} при печати результатов\footnote{Мы возвращаем \textbf{t}, поэтому мы не видим формы, возвращённой \textbf{print}'ом. Возвращение \textbf{(values)} --- это обычное явление.}:

\begin{verbatim}
CL-USER> (let ((*print-circle* t))
           (print
            (macroexpand '(nif x 'pos 'zero 'neg)))
           t)

(LET ((#1=#:G1195 X))
  (COND ((PLUSP #1#) 'POS) ((ZEROP #1#) 'ZERO) (T 'NEG))) 
T
\end{verbatim}

В вышеприведённой форме Лисп принтер использует считывающие макросы \verb"#=" и \verb"##". Эти \emph{считывающие макросы\index{макрос!считывающий}} позволяют нам создать формы, \emph{ссылающиеся на самих себя (self-referential)\index{ссылающиеся сами на себя}}, более подробно об этих формах мы поговорим в \emph{разделе Циклические Выражения}. Если мы прочитаем предыдущую форму, символы, используемые внутри будут теми же самыми, что и символы, используемые в привязке \textbf{let} и поэтому выражение будет работать. Кажется, что в вышеприведённом выражении удалось избежать избыточности с двойным именованием. Есть ли способ добавления этого способа в шаблон макроса, пишущего макросы?

Помните, что в определении макроса мы можем именовать наши \textbf{gensym}'ы во что угодно, даже, как это сделал Грэм, в простые имена, такие как \textbf{g}, и они исчезнут при расширении макроса. Так как у нас есть свобода в именовании, то следует как-то стандартизировать соглашение об именовании \textbf{gensym}'ов. В виде компромисса между краткостью и уникальностью, считается что любой символ, начинающийся с двух символов \textbf{G!} и последующим после них одним или более символами рассматривается как специальный ссылающийся \textbf{gensym}'овский символ называемый \emph{G-банг символ (G-bang symbol)\index{G-банг символ}}. Мы определили предикат, \textbf{g!-symbol-p}, определяющий является ли переданный атом G-банг символом.

\begin{figure}Листинг 3.5: G-BANG-SYMBOL-PREDICATE\label{listing_3.5}
\listbegin
\begin{verbatim}
(defun g!-symbol-p (s)
  (and (symbolp s)
       (> (length (symbol-name s)) 2)
       (string= (symbol-name s)
                "G!"
                :start1 0
                :end1 2)))
\end{verbatim}
\listend
\end{figure}

Теперь, после того как мы стандартизировали G-bang символы, мы можем создать макрос, пишущий для нас макро определения и использующий сокращение написания макроса известное как \emph{автоматические gensym'ы ({\selectlanguage{english}automatic gensyms})}\index{автоматическая!gensym}. Макрос \textbf{defmacro/g!} определяет предметно --- ориентированный язык, предназначенный для решения задачи по написанию макросов, но в этом языке удаётся сохранить всю мощь Лиспов. \textbf{Defmacro/g!} прост, но его использование и то, как он работает может быть не очевидным. По этой причине, а также по причине того, что это первый настоящий макрос впервые представленный вам в этой книге, мы не спеша проанализируем \textbf{defmacro/g!}.

\begin{figure}Листинг 3.6: DEFMACRO-WITH-G-BANG\label{listing_3.6}
\listbegin
\begin{verbatim}
(defmacro defmacro/g! (name args &rest body)
  (let ((syms (remove-duplicates
               (remove-if-not #'g!-symbol-p
                              (flatten body)))))
    `(defmacro ,name ,args
       (let ,(mapcar
              (lambda (s)
                `(,s (gensym ,(subseq
                               (symbol-name s)
                               2))))
              syms)
         ,@body))))
\end{verbatim}
\listend
\end{figure}

При исследовании любого макроса, первый шаг, который вам следует сделать --- это \emph{остановиться\index{остановиться}}. Не думайте о макросе как о трансформации синтаксиса или любой другой абстракции. Думайте о макросе как о функции. В основе макроса лежит функция и макрос работает таким же способом. Функция --- это заданные не вычисленные выражения, переданные как аргументы и ожидается возвращённый код для Лиспа с последующей вставкой в другие выражения.

Итак, размышляя о \textbf{defmacro/g!} как о функции, рассмотрим его исполнение. Поскольку мы программируем обычную Лисп функцию, то это значит что мы имеем доступ ко всем особенностям Лиспа и даже утилитам, добавленными позже к языку. В \textbf{defmacro/g!} мы используем утилиту Грэма \textbf{flatten}, Лисповские функции \textbf{remove-if-not} и \textbf{remove-duplicates} и наш предикат G-bang символа \textbf{g!-symbol-p}, для создания нового списка состоящего из всех G-bang символов, найденных внутри тела формы, переданной в наш макрос. Дальше мы используем шаблон обратную кавычку для того, чтобы вернуть список представляющий код, в который нам нужно расширить макрос. Поскольку в нашем случае мы пишем улучшение для \textbf{defmacro}, то нам нужно чтобы наш код самостоятельно расширился в форму \textbf{defmacro}. Но, мы добавили новые удобные особенности в язык \textbf{defmacro} и нужно создать чуть более сложное расширение. Для того, чтобы применить gensym к каждому G-bang символу, найденному в теле макроса, мы используем \textbf{mapcar} для применения функции ко всему списку из собранных G-bang символов, создавая новый список, который может быть объединён в форму \textbf{let}, устанавливая привязки для каждого gensym'а\footnote{Функции \textbf{gensym} может быть передан аргумент в виде единственной строки. Это меняет печатаемое имя gensym'а, что может помочь при чтении расширений. Для этих целей \textbf{defmacro/g!} использует печать имён символов в G-bang символе.}.

Заметьте как лямбда, используемая в отображении, содержит выражение, созданное с помощью оператора обратной кавычки, эта ситуация должна была бы являться, но не является, \emph{вложенной обратной кавычкой (nested backquote)}\index{обратная кавычка!вложенная}. Поскольку \textbf{mapcar}, применяющий эту функцию, \emph{не закавычен (unquoted)\index{не закавыченность}}, то не закавыченные выражения во вложенной обратной кавычке по прежнему вычисляются в нашем исходном контексте. Вложенные обратные кавычки известны своей чрезвычайной сложностью в освоении и мы вернёмся к рассмотрению этой концепции в \emph{главе~\ref{chapter_reading_macros} Считывающие Макросы}.

Итак, что конкретно позволяет нам выполнять \textbf{defmacro/g!}? Он позволяет нам использовать технику автоматических gensym'ов --- способ проверки существования определённых символов в лексической области видимости кода, переданного макросу\footnote{На данный момент это просто упрощение. Читайте раздел о суб-лексической области видимости.}. Если мы не будем использовать никаких G-bang символов, то \textbf{defmacro/g!} будет работать также, как и \textbf{defmacro}. Но, появление любого G-bang символа в теле расширения макроса будет интерпретироваться следующим образом:

\begin{quote}
Я хочу, чтобы была создана привязка вокруг этого выражения и я уже дал символ. Сделай это.
\end{quote}

Мы можем использовать \textbf{defmacro/g!} для явного создания gensym'а в таком определении \textbf{nif}:

\begin{verbatim}
(defmacro/g! nif (expr pos zero neg)
  `(let ((,g!result ,expr))
     (cond ((plusp ,g!result) ,pos)
           ((zerop ,g!result) ,zero)
           (t ,neg))))
\end{verbatim}

Когда нам нужно использовать gensym мы просто его используем. Конечно, нам нужно соблюдать осторожность, потому что все ссылки на G-bang символы вычисляются только макро расширением, поскольку это единственное место, где привязан gensym\footnote{G-bang символы не должны появляться в расширении самих себя --- именно этого мы пытаемся избежать с помощью gensym'ов.}. Разкавычивание G-bang символов, как это показано выше, происходящее внутри обратной кавычки --- наиболее очевидный способ выполнения этой операции и мы можем увидеть в этом параллель с разкавычиванием символа \textbf{g} в исходном определении \textbf{nif} Грэма.

Мы определили макрос \textbf{nif}, который вроде как должен работать также как и Грэмовский \textbf{nif}, но это улучшение выглядит слишком хорошим чтобы быть правдой. Это действительно работает? Взглянем на макро расширение\footnote{Мы использовали \textbf{macroexpand-1}, благодаря чему произвели единственное расширение макроса \textbf{defmacro/g!} не вызвав последующее расширение \textbf{defmacro}.} прежде чем выносить какое-либо суждение:

\begin{verbatim}
CL-USER> (macroexpand-1
          '(defmacro/g! nif (expr pos zero neg)
             `(let ((,g!result ,expr))
                (cond ((plusp ,g!result) ,pos)
                      ((zerop ,g!result) ,zero)
                      (t ,neg)))))
(DEFMACRO NIF (EXPR POS ZERO NEG)
  (LET ((G!RESULT (GENSYM "RESULT")))
       `(LET ((,G!RESULT ,EXPR))
             (COND ((PLUSP ,G!RESULT) ,POS) 
                   ((ZEROP ,G!RESULT) ,ZERO) 
                   (T ,NEG)))))
T
\end{verbatim}

Кажется, что \textbf{defmacro/g!} написал почти тот же код что написал Грэм в исходной версии \textbf{nif}. Рассматривая этот пример использования \textbf{defmacro/g!} мы видим что в этом расширении создаются только gensym привязки. \textbf{Nif}, определённый с помощью \textbf{defmacro/g!} свободен от проблем захвата переменных.

Так как \textbf{defmacro/g!} сам является макросом, могут ли возникнуть проблемы в среде расширения макроса с нежелательным захватом или заменой? Как и в любой достаточно сложной абстракции такое поведение возможно. В том же смысле в каком захват переменной --- это недостаток, некоторые особенности \textbf{defmacro/g!} могут оказаться недостатками, существующими в самой архитектуре конструкции\footnote{Хотя не безопасно исключать ошибку самого программиста.}. Как всегда, самое лучшее решение --- это полное понимание абстракции.

Ещё одним \emph{интересным случаем} является применение \textbf{defmacro/g!} в G-bang макросе, определяющим G-bang макрос. \textbf{Defmacro/g!} вводит набор привязок в среду расширения, каждая привязка связана с gensym'ом, который при необходимости может использовать макрос. Если возникает такой случай, когда есть несколько возможных привязок gensym'а, то их всегда можно различить по контексту. Другими словами, вы всегда можете указать какую среду следует использовать gensym'у, основываясь на среде в которой он вычисляется. Вот один синтетический пример:

\begin{verbatim}
(defmacro/g! junk-outer ()
  `(defmacro/g! junk-inner ()
     `(let ((,g!abc))
        ,g!abc)))
\end{verbatim}

Здесь создаётся два gensym'а. Использованию \textbf{g!abc} предшествует только одно разкавычивание (запятая) поэтому мы знаем, что расширение относится к внутреннему gensym'у, созданному с помощью расширения \textbf{junk-inner}. Если же вместо одного разкавычивания было бы два разкавычивания, то они стали бы относиться к gensym'у созданному в расширении \textbf{junk-outer}.

\textbf{Defmacro/g!} использует функцию Грэма \textbf{flatten}. \textbf{Flatten}, как было описано в \emph{разделе~\ref{section_the_lisp_utility} Утилиты Лисп}, получает дерево cons структуры --- наш Лисп код --- и возвращает новый список из всех листьев/атомов. Использование \textbf{flatten} в \textbf{defmacro/g!} --- это простой пример \emph{прохода по коду (code-walking)\index{проход по коду}}, тема, к которой мы будем возвращаться на протяжении этой книги.

Упражнение: Что произойдёт в предыдущем G-bang макросе, определяющим G-bang макрос, если первый gensym будет разкавычен один раз, а другой два раза?

\section{Once Only}\label{section_once_only}

Питер Норвиг\index{Норвиг, Питер} --- блестящий программист и автор. Его книги по ИИ, особенно \emph{Искусственный Интеллект: Современный Подход (Artificial Intelligence: A Modern Approach [AIMA])}, обязательны к прочтению всем людям, работающим с наиболее трудными проблемами в области информатики. Скорее всего, Норвиг известен Лисп программистам по книге \emph{Парадигмы Программирования Искусственного Интеллекта: Обучающие Примеры на Common Lisp {\selectlanguage{english}(Paradigms Of Artificial Intelligence Programming: Case Studies in COMMON LISP [PAIP])}\index{PAIP}}. И хотя эта книга довольно старая, она обязательна к прочтению всеми серьёзными Лисп студентами, поскольку содержит описание многих важных идей Лиспа\footnote{Один из, вечно актуальных, советов PAIP по Common Lisp следующий: никогда не смешивайте аргументы \emph{\&optional} и \emph{\&key} в деструктурирующих формах lambda или defmacro. Иначе будет больно!}. Этот раздел посвящён Питеру Норвигу, а название раздела взято из названия макроса, описанного в PAIP. Тему последних нескольких страниц, описывающих реализацию функции последовательности, можно выразить так

\begin{quote}
Once-only: Урок Макрологии
\end{quote}

Далее следует чрезвычайно интригующее выражение:

\begin{quote}
Если вы можете понять как писать и когда использовать once-only, то это значит что вы полностью освоили макросы.
\end{quote}

Как мы уже знаем, никто не в состоянии полностью понять макросы. Понимание одного макроса, пусть даже такого важного как \textbf{once-only} приближает вас к пониманию макросов также как и понимание важной теоремы может помочь в полном освоении математики. Поскольку их возможности (математики и макросов) безграничны, то полное понимание математики или макросов абсолютно невозможно.

Здесь мы не будем давать определение \textbf{once-only} Норвига, но, поскольку это сложный макрос с некоторыми интересными свойствами, мы реализуем его несколько по-другому. Изначально \textbf{once-only} был реализован для программной среды канувшей в лету \emph{Лисп машины\index{лисп машина}} и не был внесён в Common Lisp по несущественным причинам.

Идея лежащая в основе \textbf{once-only} --- это окружение макро расширения кодом, который создаст новую привязку. После вычисления макро расширения, эта привязка будет инициализирована результатом вычисления одной формы, переданной макросу в виде аргумента. Затем код в теле \textbf{once-only} может использовать привязку, которой, конечно, не нужно пересчитывать форму, переданную макросу. Форма, переданная макросу в виде аргумента вычисляется один единственный раз. Once-only (только единожды).

В качестве примера \textbf{once-only} Норвиг приводит макрос \textbf{square}. Его расширение получает один аргумент и возвращает результат умножения этого аргумента на самого себя:

\begin{verbatim}
(defmacro square (x)
  `(* ,x ,x))
\end{verbatim}

Такой подход будет работать со многими вещами: большинство переменных, чисел и других форм, которые могут свободно вычисляться столько раз, сколько это необходимо. Но, стоит только передать этой версии \textbf{square} формы с \emph{побочными эффектами (side-effects)\index{побочные эффекты}}, как все ставки будут отменены. Конечно, поведение по прежнему будет детерминированным, но теперь трудно предсказать к чему оно приведёт. При работе с этим макросом, форма будет вычислена дважды. Но, поскольку эти сущности усложняются очень быстро, то в целом, все ставки будут отменены. Назначение \textbf{once-only} --- создание удобства и возможность избежать этих нежелательных побочных эффектов. Заметьте, что если бы мы использовали функцию, то такое поведение досталось бы нам бесплатно. Мы уйдём с области надуманных книжных примеров, опустимся на грешную землю и определим \textbf{square} в виде функции, функция будет выглядеть примерно так:

\begin{verbatim}
(defun square (x)
  (* x x))
\end{verbatim}

Мы можем использовать любую форму в качестве аргумента в этом определении функции \textbf{square}. Поскольку этот аргумент будет вычисляться только один раз, то будут удовлетворены наши представления и концептуальные модели побочных эффектов. Во многих примерах мы ожидаем, что выражение, написанное нами один раз будет вычислено только единожды. С другой стороны, одна из составляющих частей макроса --- нарушение этого предположения с помощью манипулирования частотой и порядком выполнения вычисления. Например, в таких вещах как циклы (loops), мы можем захотеть вычисления выражений более одного раза. Кроме того, мы даже можем захотеть чтобы эти выражения вообще не вычислялись, поскольку нам может понадобиться от них что-то другое, а не результат вычисления.

\textbf{Once-only} позволяет нам указать конкретные параметры в нашем макро расширении, которые должны вычисляться только один раз с порядком вычисления слева-направо, как в лямбде. Вот как будет выглядеть макрос \textbf{square} вкупе с макросом \textbf{once-only}:

\begin{verbatim}
(defmacro square (x)
  (once-only (x)
    `(* ,x ,x)))
\end{verbatim}

Конечно, если вы хотите подвергнуть \textbf{once-only} все аргументы вашего макроса, то в этом случае взамен макроса следует использовать функцию (лямбду). Мы ещё вернёмся к этому вопросу, но, поскольку эта книга не содержит прямой реализации \textbf{once-only}, то мы введём альтернативную реализацию этой функциональности в нашу нотацию макроса. Хотя существуют множество интересных реализаций \textbf{once-only} [PAIP-P853] [PRACTICAL-CL-P95], в этом разделе мы введём новую технику, созданную в комбинации с \textbf{defmacro/g!}.

Первый шаг в нашей реализации once-only --- это создание некоторых новых предикатов и функций-утилит. С целью нахождения компромисса между краткостью и уникальностью мы зарезервируем другой набор символов для нашего персонального использования. Все символы начинающиеся с сочетания символов \textbf{O!} называются \emph{O-bang символами\index{O-bang символы}}.

Предикат, используемый для того, чтобы отличать O-bang символы от других объектов будет называться так: \textbf{o!-symbol-p}. Его определение очень близко к \textbf{g!-symbol-p}. Кроме того мы создадим удобную функцию-утилиту для смены O-bang символа на G-bang символ, сохраняя остальные символы после bang'а: \textbf{o!-symbol-to-g!-symbol}. Эта функция-утилита будет использовать удобную функцию-утилиту Грэма \textbf{symb} для создания новых символов.

\begin{figure}Листинг 3.7: O-BANG-SYMBOLS\label{listing_3.7}
\listbegin
\begin{verbatim}
(defun o!-symbol-p (s)
  (and (symbolp s)
       (> (length (symbol-name s)) 2)
       (string= (symbol-name s)
                "O!"
                :start1 0
                :end1 2)))

(defun o!-symbol-to-g!-symbol (s)
  (symb "G!"
        (subseq (symbol-name s) 2)))
\end{verbatim}
\listend
\end{figure}

\begin{figure}Листинг 3.8: DEFMACRO-BANG\label{listing_3.8}
\listbegin
\begin{verbatim}
(defmacro defmacro! (name args &rest body)
  (let* ((os (remove-if-not #'o!-symbol-p args))
         (gs (mapcar #'o!-symbol-to-g!-symbol os)))
    `(defmacro/g! ,name ,args
       `(let ,(mapcar #'list (list ,@gs) (list ,@os))
          ,(progn ,@body)))))
\end{verbatim}
\listend
\end{figure}

\textbf{Defmacro!} представляет последний шаг в нашем языке определения макросов --- он добавляет свойство once-only. \textbf{Defmacro!} комбинируется с \textbf{defmacro/g!} из предыдущего раздела. Поскольку \textbf{defmacro!} расширяется прямо в форму \textbf{defmacro/g!}, то происходит \emph{наследование (inherits)\index{наследование}} поведения автоматических gensym'ов. Для создания сложных сочетаний очень важно понимать работу всех скомбинированных частей. Напомним, что \textbf{defmacro/g!} ищет символы начинающиеся с G-bang и автоматически создаёт gensym'ы. Расширяясь в форму с G-bang символами, \textbf{defmacro!} может избежать дублирования gensym'а при реализации once-only.

\textbf{Defmacro!} создаёт сокращение известное как \emph{автоматический once-only}\index{автоматическая!once-only}. С помощью автоматического once-only мы можем предварить один или более символов в аргументах макроса O-bang'ом, таким образом создав O-bang символы определённые с помощью \textbf{o!-symbol-p}. Благодаря этому \textbf{defmacro!} понимает что мы хотим создать привязку в создаваемом коде. Эта привязка будет содержать результат вычисления кода, переданного в виде аргумента макроса. Эта привязка будет доступна расширению макроса через gensym. Но как нам сослаться на gensym при создании расширения? Через использование эквивалентного G-bang символа определённого с помощью \textbf{o!-symbol-to-g!-symbol}.

Реализация зависит от возможностей \textbf{defmacro/g!}. С помощью утилиты \textbf{o!-symbol-to-g!-symbol} мы создаём новые G-bang символы для добавления в форму \textbf{defmacro/g!}. Поскольку у нас уже есть автоматические gensym'ы, то once-only легко реализовать, об этом свидетельствует краткость определения \textbf{defmacro!}.

Вернёмся на короткое время на землю синтетических книжных примеров и реализуем макрос \textbf{square}, на этот раз с помощью \textbf{defmacro!}:

\begin{verbatim}
(defmacro! square (O!x)
  `(* ,g!x ,g!x))
\end{verbatim}

Применим macroexpand к этому выражению:

\begin{verbatim}
CL-USER> (macroexpand
	  `(square (incf x)))
(LET ((#:X1207 (INCF X)))
  (* #:X1207 #:X1207))
T
\end{verbatim}

В предыдущем разделе я упомянул что мы передаём строковое значение в \textbf{gensym} для всех G-bang символов. Это значительно облегчает изучение подобных форм. Также нет ничего удивительного в таком имени gensym'ов как \textbf{\#:X1633}, если бы мы отладили определение \textbf{defmacro!} в последнем \textbf{square}, то обнаружили бы связь между этим символом и символом, используемом в определении макроса: \textbf{X}. Возможность сравнивания символов определения и расширения и наоборот становится проще если информация находится в печатаемых именах используемых gensym'ов, как это было сделано в расширениях \textbf{defmacro/g!}\footnote{Это же является причиной возникновения чисел в печатаемых именах gensym'а, числа определяются с помощью \textbf{*gensym-counter*}. Этот счётчик позволяет нам различать экземпляры gensym'ов с одинаковыми печатаемыми именами.}.

Помимо менее выразительного использования и более удобного вывода расширения по сравнению с традиционным \textbf{once-only}, в \textbf{defmacro!} есть ещё одна ключевая особенность. В обычном \textbf{once-only} привязка gensym используется для получения доступа к созданной лексической переменной с тем же именем, что и аргумент макро расширения, \emph{затеняющие (shadows)\index{затенение}} аргументы макроса, в результате, к ним нельзя получить доступ из определения макроса. Поскольку \textbf{defmacro!} разделяет это на два различных типа символов, G-bang символы и O-bang символы, то мы можем писать макро расширения, использующие оба значения. В качестве примера, вот ещё одно определение макроса \textbf{square}:

\begin{verbatim}
(defmacro! square (O!x)
  `(progn
     (format t "[~a gave ~a]~%"
             ',o!x ,g!x)
     (* ,g!x ,g!x)))
\end{verbatim}

Это может использоваться так:

\begin{verbatim}
CL-USER> (defvar x 4)
4
CL-USER> (square (incf x))
[(INCF X) gave 5]
25
\end{verbatim}

Обратите внимание: мы \emph{закавычиваем\index{кавычка}} разкавыченный O-bang символ в последнем определении \textbf{square}. Мы делаем это потому, что нам не нужно вычислять эту форму снова. Расширение сгенерированное от \textbf{defmacro!} уже вычислило его. Мы просто хотим получить форму, переданную в square и использовать её по другому назначению, в данном случае мы используем её в роли сырого отладочного выражения. Однако, даже если выражение уже было вычислено один раз, ничто не мешает нам вычислить эту форму ещё раз если этого требуют наши абстракции.

\begin{figure}Листинг 3.9: NIF\label{listing_3.9}
\listbegin
\begin{verbatim}
(defmacro! nif (o!expr pos zero neg)
  `(cond ((plusp ,g!expr) ,pos)
         ((zerop ,g!expr) ,zero)
         (t ,neg)))
\end{verbatim}
\listend
\end{figure}

Язык \textbf{defmacro!} позволяет нам осуществлять удобный, гранулированный контроль над вычислением аргументов, переданных в наши макросы. Если мы добавим префиксы в виде O-bang ко всем символам, представляющим аргументы в макро определении, а в макро определении будем использовать только соответствующие G-bang символы, то наши выражения будут теми же лямбда выражениями --- каждая форма вычисляется только один раз, слева направо. Без этих символов в \textbf{args} и без использования G-bang символов в расширении, \textbf{defmacro!} будет работать также, как и обычный \textbf{defmacro} Common Lisp'а.

\textbf{Defmacro!} --- наиболее удобен при итеративной разработке макросов. Поскольку мы простым добавлением двух символов в аргумент макроса получаем вычисление в лямбда стиле, а использование gensym'ов становится таким же лёгким как написание этого слова, то мы можем легко менять наше представление о макросе. \textbf{Defmacro!} можно представить как более плотно подогнанную оболочку над лямбдой, чем Common Lisp'овский \textbf{defmacro}. По этим причинам в итеративной разработке мы будем использовать \textbf{defmacro!} в качестве главного определителя макросов на протяжении всей оставшейся части книги.

Вернёмся с макросу \textbf{nif} Грэма. При переписывании этого макроса с использованием \textbf{defmacro!} мы упомянули, что аргумент \textbf{expr}, для которого мы создавали gensym вычисляется только один раз. Здесь мы использовали \textbf{defmacro!} для того, чтобы этот аргумент вычислялся только один раз назвав аргумент как \textbf{o!expr}. Эта реализация \textbf{nif} представляет последний шаг в нашей эволюции этого макроса.

\textbf{Defmacro!} размывает границу между макросом и функцией. Именно эта особенность, возможность использования некоторых O-bang символов в аргументах макроса наряду с обычными символами делает {\selectlanguage{english}\textbf{defmacro!}} особенно полезным. Как обратная кавычка позволяет вам перевернуть поведение закавычивания, также \textbf{defmacro!} позволяет вам перевернуть семантики вычисления аргументов макроса из обычных не вычисляемых макро форм в однократно вычисляемые справа налево лямбда аргументы.

\section{Двойственность Синтаксиса}\label{section_duality_of_syntax}

Одна из наиболее важных концепций Лиспа называется \emph{двойственностью синтаксиса\index{двойственность синтаксиса}}. Понимание того, как использовать эту двойственность и почему эта двойственность так важна --- общая тема создания макросов и этой книги. Эта двойственность отчасти была спроектирована, а отчасти случайно открыта. Для программистов на не-Лисп языках реальность двойственного синтаксиса будет очень нереальной, поэтому на данный момент мы уклонимся от прямого определения этого явления. Для того, чтобы избежать шока вы, читатель, будете изучать её шаг за шагом, постепенно и неторопливо. Если вы при чтении этой книги будете испытывать какой-либо дискомфорт и/или головную боль, то я рекомендую вам немедленно выполнить цикл сборки мусора (немного поспать), и только потом вернуться к чтению с ясным и незамутнённым умом.

\emph{Ссылочная прозрачность (Referential transparency)\index{ссылочная прозрачность}} иногда определяется как следующее свойство кода: любое выражение может быть вставлено куда угодно и везде это выражение будет иметь один и тот же смысл. Вводя синтаксическую двойственность мы искусственно нарушаем ссылочную прозрачность и получаем плоды новых возможностей, от языка, в котором возможны такие нарушения. В то время когда другие языки позволяют вам создавать полупрозрачные стеклянные панели, Лисп позволяет использовать набор из дыма, зеркал и призм. Магическая пыль создаёт макросы и самые лучшие трюки макросов основаны на синтаксической двойственности.

Этот раздел описывает важность двойного синтаксиса, о котором мы только что говорили, но ещё недостаточно изучили: Common Lisp использует тот же синтаксис для получения доступа к главным типам переменных, динамическим и лексическим. Эта книга пытается проиллюстрировать реальную мощь динамической и лексической области видимости и важность решения использовать двойственный синтаксис в Common Lisp.

Цель динамической области видимости --- это предоставление способа получения значений внутри и из Лисп выражений, основанном на вычислении выражения, а не местом где это выражение было определено или скомпилировано. Это возможно благодаря синтаксису, с помощью которого Common Lisp определяет идентичность, используемую для получения доступа к лексическим переменным, являющимися прямой противоположностью динамическим переменным в том, что они всегда относятся к тем местам, в которых они были скомпилированы, будучи независимыми от места использования. На самом деле без внешнего контекста в форме определения вы не можете ничего сказать о типе переменной, на которую ссылается выражение. Двойственный синтаксис нарушает ссылочную прозрачность, но вместо того, чтобы пытаться избежать эту, казалось бы, проблему, Лисп программисты приветствуют её, поскольку также как вы не можете различать выражение без контекста, также вы не можете писать макросы без двойственности. Поразмыслите секунду над этой мыслью. Это объясняет почему создание привязок для динамических переменных не создаёт лексических замыканий. В качестве примера привяжем снова переменную \textbf{temp-special}, которую ранее мы объявили специальной:

\begin{verbatim}
CL-USER> (let ((temp-special 'whatever))
	   (lambda () temp-special))
#<FUNCTION (LAMBDA ()) {C9E452D}>
\end{verbatim}

И хотя мы видим \emph{lambda'у окружённую let'ом\index{let, окружающий lambda}}, это не лексическое замыкание. Это простое вычисление макро формы \textbf{lambda} в некотором динамическом контексте, результатом чего является, конечно же, анонимная функция. Эта функция, при её применении, будет работать в текущей динамической среде и будет получать значение \textbf{temp-special}. При вычислении макроса \textbf{lambda} существовала динамическая привязка \textbf{temp-special} к символу \textbf{whatever}, но кому это будет интересно? Помните что \textbf{lambda} формы --- это объекты-константы, всего лишь простой машинный код, возвращающий указатели, поэтому вычисление этой лямбда формы никогда не получит доступа к динамической среде. Что случится с нашим символом \textbf{whatever}? После вычисления лямбда формы Лисп посчитает символ \textbf{whatever} не нужным и удалит его из динамической среды.

Некоторые ранние Лиспы поддерживали \emph{динамические замыкания}, это обозначало что каждая функция определялась в не-null'евой динамической среде, обладавшей своим (возможно частично общим) стеком динамических привязок. Это был эффект, похожий на Common Lisp'овскую лексическую область видимости и реализовался с помощью так называемого \emph{спагетти стека\index{спагетти стек}\index{динамические замыкания|see{спагетти стек}}} [SPAGHETTI-STACKS] [INTERLISP-TOPS20]. Эта структура уже не представляла из себя стековую структуру данных, но была скорее множеством путей, этакой собирающей мусор сетью. Common Lisp не использует спагетти стеки и предоставляет только лексические замыкания [MACARONI].

Таким образом, лексические и динамические переменные --- это абсолютно различные концепции, с одним синтаксисом в коде Common Lisp. Зачем нам нужна эта, так называемая, двойственность синтаксиса? Ответ на этот вопрос может понять меньшая часть Лисп программистов, но этот ответ настолько фундаментален, что заслуживает пристального изучения. Эта двойственность синтаксиса позволяет нам писать макросы, имеющие общий, единый интерфейс для создания расширений, полезных и в динамическом и в лексическом контексте. И хотя значение расширений макроса может абсолютно различаться в зависимости от заданного контекста и каждое расширение может иметь в своём основании абсолютно разные вещи, мы по прежнему можем использовать тот же самый макрос и те же самые комбинации этого макроса с другими макросами. Другими словами макросы могут быть \emph{двойственными}\index{двойственность} не только по отношению к аргументам макросов, но также обладать различными значениями по отношению к их расширениям. Мы можем использовать макрос только ради понимания трансформации кода, игнорируя семантическое обозначение кода, всё это потому, что код имеет значение только тогда, когда мы его где то используем --- и не имеет значения при работе макроса. Чем больше двойственность синтаксиса, тем более мощным становится макрос. На протяжении этой книги вы увидите много примеров, в деталях показывающих преимущества двойственного синтаксиса. Двойственность между динамическими и лексическими переменными является не очень выразительным (но полезным) примером Лисп философии. Некоторые макросы были созданы на основе мощи двойственности и предназначены для специфических целей, иногда в расширениях таких макросов могут быть заложены более чем два различных обозначения.

Согласно традиционному соглашению в Common Lisp имена специальных переменных следует предварять и завершать символами астериска. Например, для нашей переменной \textbf{temp-special} мы должны выбрать имя \textbf{*temp-special*}. Поскольку это соглашение выглядит как обладание другим пространством имени для динамических переменных тем самым снижая двойственность с лексическими переменными, то в этой книге не выдерживается строгое следование данному соглашению. Астериски --- это всего лишь соглашение и, к счастью, Common Lisp не строго следует ему. Мы можем не только не использовать астериски в именах специальных переменных, но даже использовать астериски в именах лексических переменных. Возможно это вопрос стиля. Что будет менее преступным с точки зрения моды: лексические переменные с астерисками или специальные переменные без астерисков? Я склоняюсь к более короткому варианту. Кроме того, имена лексических и специальных переменных могут быть gensym'ами, концепцией, выводящей печать имён за пределы символов.

Как уже упоминалось эта книга нарушает традиционное соглашение об астерисках. Вместо

\begin{quote}
Имя переменной с астериском обозначает специальную переменную.
\end{quote}

эта книга использует

\begin{quote}
Имена переменных с астерисками обозначают специальные переменные, определённые по стандарту.
\end{quote}

Моя главная мотивация в отбрасывании наушников с имён переменных проста и субъективна: я считаю, что постоянная печать астерисков раздражает программиста и ухудшает внешний вид программы. Я не буду заходить далеко и предлагать вам следовать этому в своих программах, я просто упомяну, что в своих программах я уже несколько лет не использую наушники и очень доволен этим.
