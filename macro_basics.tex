\chapter{Основы макросов}\label{chapter_macro_basics}
\section{Итеративная Разработка}\label{section_iterative-development}
\begin{quote}
Лисп помог целому ряду одарённых людей размышлять таким образом, какой ранее не был им доступен.

- Эдсгер Дейкстра
\end{quote}

Конструирование макросов - это итеративный процесс: все сложные макросы начинались из более простых макросов. Отталкиваясь от этой идеи, можно сказать что макросы создаются подобно скульптуре из куска камня. Если реализация макроса оказывается недостаточно гибкой, либо результатом оказывается недостаточно эффективное или опасное расширение, то в этом случае профессиональный программист макросов слегка модифицирует макрос, добавляя функционал или исправляя ошибки до тех пор, пока макрос не будет удовлетворять всем требованиям.

Необходимость итеративного процесса в конструировании макросов возникает отчасти потому, что итеративный процесс программирования - это наиболее универсальный и эффективный способ программирования, а другая причина заключается в том, что программирование макросов - это наиболее сложный вид программирования. Поскольку при программировании макросов программисту приходится думать сразу о нескольких уровнях кода, исполняемого в различные моменты времени, то вопросы сложности увеличиваются гораздо быстрее, чем в остальных типах программирования. Итеративный процесс позволяет убедиться в том, что ваша концептуальная модель наиболее полно соответствует тому, что планируется создать. Если бы мы создавали макросы без такой обратной связи, то конструирование макросов стало бы значительно более трудным делом.

В этой главе мы напишем несколько базовых макросов и ознакомимся с двумя основными концепциями макросов: \emph{предметно - ориентированные языки (domain specific languages)} и \emph{структуры управления (control structures)}. После того, как мы изучим эти основные понятия о макросах, мы вернёмся назад и обсудим процесс создания макросов с помощью макросов. На протяжении всей книги мы будем использовать такие техники как захват переменной и введение свободной переменной, кроме этого мы ознакомимся с новым, более удобным синтаксисом определения Лисп макросов.

\section{Предметно-Ориентированные Языки}\label{section_domain_specific_languages}

Common Lisp, наряду с большинством программных сред, предоставляет функцию \textbf{sleep}, которая приостанавливает исполнение процесса на \textbf{n} секунд, где \textbf{n} - не отрицательный, не комплексный, числовой аргумент. Например, мы можем захотеть уснуть на 3 минуты (180 секунд), в этом случае мы можем вычислить эту форму:

\begin{verbatim}
(sleep 180)
\end{verbatim}

Или, если мы предпочитаем думать о засыпании в терминах минут, то взамен последнего выражения мы можем использовать

\begin{verbatim}
(sleep (* 3 60))
\end{verbatim}

Поскольку компиляторы знают как \emph{перемножать константы}, эти два вызова одинаково эффективны. Для того, чтобы более явно описать наши действия, мы можем определить функцию \textbf{sleep-minutes}:

\begin{verbatim}
(defun sleep-minutes (m)
  (sleep (* m 60)))
\end{verbatim}

Подход с определением новой функции для каждой единицы времени оказывается неуклюжим и неудобным. Что нам нужно - так это некая абстракция, которая позволяла бы использовать единицу времени вместе со значением. Нам нужен \emph{предметно-ориентированный язык (domain specific language)}.

Решение, которое мы можем использовать в Лиспе может быть таким же, как и в остальных языках программирования: создать функцию, которая будет принимать значение и единицу времени и возвращать значение умноженное на некоторую константу, относящуюся к конкретной единице времени. И тут проявляются удобства, предоставляемые Лиспом при реализации единицы времени. В языках, подобных C принято использовать нижележащие типы данных (например: int) и присваивать произвольные значения, относящиеся к различным единицам времени:

\begin{verbatim}
#define UNIT_SECONDS 1
#define UNIT_MINUTES 2
#define UNIT_HOURS 3

int sleep_units(int value, int unit) {
  switch(value) {
    case UNIT_SECONDS: return value;
    case UNIT_MINUTES: return value*60;
    case UNIT_HOURS: return value*3600;
  }
}
\end{verbatim}

Но в Лиспе самый очевидный путь обозначения желаемой единицы - это использование символа. Символ в Лиспе - это нечто, не \textbf{eq}'альное другим символам. \textbf{Eq} - это самый быстрый оператор сравнения в Лиспе и примерно соответствует сравнению указателей. Поскольку сравнение указателей производится очень быстро, то символы предоставляют нам очень быстрый и удобный способ определения равенства двух и более различных Лисп выражений. В Лиспе мы должны определить функцию \textbf{sleep-units\%}, после этого мы можем использовать единицы времени в наших формах:

\begin{verbatim}
(sleep-units% 2 'm)
(sleep-units% 500 'us)
\end{verbatim}

Листинг 3.1: SLEEP-UNITS-1\label{listing_3.1}
\hrule
\begin{verbatim}
(defun sleep-units% (value unit)
  (sleep
   (* value
      (case unit
        ((3) 1)
        ((m) 60)
        ((h) 3600)
        ((d) 86400)
        ((ms) 1/1000)
        ((us) 1/1000000)))))
\end{verbatim}
\hrule
\footnote{Примечание переводчика: При компилировании этого кода происходит вывод предупреждений. Я предлагаю использовать следующий вариант:

\texttt{(defun sleep-units\% (value unit)}

\texttt{\quad(defun unit-to-second (unit)}

\texttt{\qquad(case unit}

\texttt{\qquad\quad((s) 1)}

\texttt{\qquad\quad((m) 60)}

\texttt{\qquad\quad((h) 3600)}

\texttt{\qquad\quad((d) 86400)}

\texttt{\qquad\quad((ms) 1/1000)}

\texttt{\qquad\quad((us) 1/1000000)))}

\texttt{\quad(sleep (* value (unit-to-second unit))))}

}

Поскольку сравнение символов требует сравнения только одного указателя, \textbf{sleep-units\%} будет скомпилирован в очень быструю диспетчеризацию во времени выполнения:

\begin{verbatim}
...
524: CMP ESI, [#x586FC4D0] ; ’S
52A: JEQ L11
530: CMP ESI, [#x586FC4D4] ; ’M
536: JEQ L10
538: CMP ESI, [#x586FC4D8] ; ’H
53E: JEQ L9
540: CMP ESI, [#x586FC4DC] ; ’D
546:
...
\end{verbatim}

Заметьте, как должна закавычиваться единица времени, указанная в \textbf{sleep-units\%}. Это происходит потому, что Лисп начинает вычисление функции с вычисления всех аргументов функции и привязывает результаты к переменным, использующимся внутри функции. Числа, строки и некоторые другие примитивы вычисляются в самих себя, поэтому нам не нужно закавычивать числовые значения, переданные в \textbf{sleep-units\%}. Если же вы хотите чтобы и эти значения не вычислялись, то вы можете закавычить и их:

\begin{verbatim}
(sleep-units% '.5 's)
\end{verbatim}

Однако, как правило, символы не вычисляются в самих себя\footnote{Как правило, нет правил без исключения. Некоторые символы вычисляются в самих себя, например: \textbf{t}, \textbf{nil} и ключевые слова.}. Когда Лисп вычисляет символ, то он предполагает, что вы ссылаетесь на переменную и пытается найти значение, ассоциированное с этой переменной в заданном лексическом контексте (если же переменная объявлена как специальная, то в этом случае поиск происходит в динамическом окружении).

Если мы хотим избежать закавычивания единицы времени, то нам нужно использовать макрос. В отличие от функции макрос не вычисляет свои аргументы. Для того, чтобы воспользоваться этим фактом, мы заменим функцию \textbf{sleep-units\%} макросом \textbf{sleep-units}. Теперь нам не нужно закавычивать единицу времени:

\begin{verbatim}
(sleep-units .5 h)
\end{verbatim}

Листинг 3.2: SLEEP-UNITS\label{listing_3.2}
\hrule
\begin{verbatim}
(defmacro sleep-units (value unit)
  `(sleep
    (* ,value
     ,(case unit
            ((s) 1)
            ((m) 60)
            ((h) 3600)
            ((d) 86400)
            ((ms) 1/1000)
            ((us) 1/1000000)))))
\end{verbatim}
\hrule

И хотя основным предназначением макроса было избежание закавычивания аргумента \textbf{unit}, этот макрос оказывается даже более эффективным чем функция, поскольку не производится диспетчеризация во время выполнения: единица времени и, следовательно, множитель известны в момент компилирования. Конечно, когда мы сталкиваемся с ситуацией слишком-хорошо-чтобы-быть-правдой, то чаще всего всё действительно оказывается слишком хорошим, чтобы быть правдой. Выигрыш в эффективности не даётся бесплатно. Отказавшись от диспетчеризации во время выполнения мы теряем способность определять единицу времени во время выполнения. Используя наш макрос мы не можем выполнить следующий код:

\begin{verbatim}
(sleep-units 1 (if super-slow-mode 'd 'h))
\end{verbatim}

Это не сработает, поскольку \textbf{sleep-units} ожидает что второй аргумент будет одним из символов, в нашем случае вторым аргументом выступает список в котором первым элементом является \textbf{if}.

Напомним, что большинство макросов писались для того, чтобы создать более удобные и полезные программные абстракции, и не предназначались для улучшения эффективности нижележащего кода. Возможно ли извлечь некоторые идиомы из этого кода, с тем, чтобы сделать его более полезным для остальной части нашей программы (и, возможно, для наших будущих программ)? Уже сейчас можно предсказать, что мы можем захотеть выполнять разные операции с временными значениями, чем простой вызов \textbf{sleep}. Макрос \textbf{unit-of-time} абстрагирует функциональность из макроса \textbf{sleep-units}, возвращая значение вместо вызова \textbf{sleep}. Параметр \textbf{value} может определяться во время выполнения программы, поскольку он является вычисляемым, но \textbf{unit} не является вычисляемым, поскольку нам нужна информация во время компиляции, также, как и при \textbf{sleep-units}. Вот пример:

\begin{verbatim}
 * (unit-of-time 1 d)
 86400
\end{verbatim}

Листинг 3.3: UNIT-OF-TIME\label{listing_3.3}
\hrule
\begin{verbatim}
(defmacro unit-of-time (value unit)
  `(* ,value
      ,(case unit
             ((s) 1)
             ((m) 60)
             ((h) 3600)
             ((d) 86400)
             ((ms) 1/1000)
             ((us) 1/1000000))))
\end{verbatim}
\hrule

Такой простой макрос как \textbf{unit-of-time} даёт нам более лучший синтаксис для решения конкретных областей некоторых проблем и может значительно улучшить продуктивность работы и корректность решения задачи. В \emph{разделе Программирование Сверху-Вниз} мы продолжим разработку языка единиц. В отличие от большинства языков программирования, в Лиспе вам доступны те же инструменты, что и у людей создавших вашу программную среду. Для того, чтобы реализовать язык Common Lisp, достаточно использовать макросы, этих же макросов достаточно, чтобы реализовать ваш собственный предметно-ориентированный язык.
