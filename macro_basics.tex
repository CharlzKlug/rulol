\chapter{Основы макросов}\label{chapter_macro_basics}
\section{Итеративная Разработка}\label{section_iterative-development}
\begin{quote}
Лисп помог целому ряду одарённых людей размышлять таким образом, какой ранее не был им доступен.

- Эдсгер Дейкстра
\end{quote}

Конструирование макросов - это итеративный процесс: все сложные макросы начинались из более простых макросов. Отталкиваясь от этой идеи, можно сказать что макросы создаются подобно скульптуре из куска камня. Если реализация макроса оказывается недостаточно гибкой, либо результатом оказывается недостаточно эффективное или опасное расширение, то в этом случае профессиональный программист макросов слегка модифицирует макрос, добавляя функционал или исправляя ошибки до тех пор, пока макрос не будет удовлетворять всем требованиям.

Необходимость итеративного процесса в конструировании макросов возникает отчасти потому, что итеративный процесс программирования - это наиболее универсальный и эффективный способ программирования, а другая причина заключается в том, что программирование макросов - это наиболее сложный вид программирования. Поскольку при программировании макросов программисту приходится думать сразу о нескольких уровнях кода, исполняемого в различные моменты времени, то вопросы сложности увеличиваются гораздо быстрее, чем в остальных типах программирования. Итеративный процесс позволяет убедиться в том, что ваша концептуальная модель наиболее полно соответствует тому, что планируется создать. Если бы мы создавали макросы без такой обратной связи, то конструирование макросов стало бы значительно более трудным делом.

В этой главе мы напишем несколько базовых макросов и ознакомимся с двумя основными концепциями макросов: \emph{предметно - ориентированные языки (domain specific languages)} и \emph{структуры управления (control structures)}. После того, как мы изучим эти основные понятия о макросах, мы вернёмся назад и обсудим процесс создания макросов с помощью макросов. На протяжении всей книги мы будем использовать такие техники как захват переменной и введение свободной переменной, кроме этого мы ознакомимся с новым, более удобным синтаксисом определения Лисп макросов.

\section{Предметно-Ориентированные Языки}\label{section_domain_specific_languages}

Common Lisp, наряду с большинством программных сред, предоставляет функцию \textbf{sleep}, которая приостанавливает исполнение процесса на \textbf{n} секунд, где \textbf{n} - не отрицательный, не комплексный, числовой аргумент. Например, мы можем захотеть уснуть на 3 минуты (180 секунд), в этом случае мы можем вычислить эту форму:

\begin{verbatim}
(sleep 180)
\end{verbatim}

Или, если мы предпочитаем думать о засыпании в терминах минут, то взамен последнего выражения мы можем использовать

\begin{verbatim}
(sleep (* 3 60))
\end{verbatim}

Поскольку компиляторы знают как \emph{перемножать константы}, эти два вызова одинаково эффективны. Для того, чтобы более явно описать наши действия, мы можем определить функцию \textbf{sleep-minutes}:

\begin{verbatim}
(defun sleep-minutes (m)
  (sleep (* m 60)))
\end{verbatim}

Подход с определением новой функции для каждой единицы времени оказывается неуклюжим и неудобным. Что нам нужно - так это некая абстракция, которая позволяла бы использовать единицу времени вместе со значением. Нам нужен \emph{предметно-ориентированный язык (domain specific language)}.

Решение, которое мы можем использовать в Лиспе может быть таким же, как и в остальных языках программирования: создать функцию, которая будет принимать значение и единицу времени и возвращать значение умноженное на некоторую константу, относящуюся к конкретной единице времени. И тут проявляются удобства, предоставляемые Лиспом при реализации единицы времени. В языках, подобных C принято использовать нижележащие типы данных (например: int) и присваивать произвольные значения, относящиеся к различным единицам времени:

\begin{verbatim}
#define UNIT_SECONDS 1
#define UNIT_MINUTES 2
#define UNIT_HOURS 3

int sleep_units(int value, int unit) {
  switch(value) {
    case UNIT_SECONDS: return value;
    case UNIT_MINUTES: return value*60;
    case UNIT_HOURS: return value*3600;
  }
}
\end{verbatim}

Но в Лиспе самый очевидный путь обозначения желаемой единицы - это использование символа. Символ в Лиспе - это нечто, не \textbf{eq}'альное другим символам. \textbf{Eq} - это самый быстрый оператор сравнения в Лиспе и примерно соответствует сравнению указателей. Поскольку сравнение указателей производится очень быстро, то символы предоставляют нам очень быстрый и удобный способ определения равенства двух и более различных Лисп выражений. В Лиспе мы должны определить функцию \textbf{sleep-units\%}, после этого мы можем использовать единицы времени в наших формах:

\begin{verbatim}
(sleep-units% 2 'm)
(sleep-units% 500 'us)
\end{verbatim}

Листинг 3.1: SLEEP-UNITS-1\label{listing_3.1}
\hrule
\begin{verbatim}
(defun sleep-units% (value unit)
  (sleep
   (* value
      (case unit
        ((3) 1)
        ((m) 60)
        ((h) 3600)
        ((d) 86400)
        ((ms) 1/1000)
        ((us) 1/1000000)))))
\end{verbatim}
\hrule
\footnote{Примечание переводчика: При компилировании этого кода происходит вывод предупреждений. Я предлагаю использовать следующий вариант:

\texttt{(defun sleep-units\% (value unit)}

\texttt{\quad(defun unit-to-second (unit)}

\texttt{\qquad(case unit}

\texttt{\qquad\quad((s) 1)}

\texttt{\qquad\quad((m) 60)}

\texttt{\qquad\quad((h) 3600)}

\texttt{\qquad\quad((d) 86400)}

\texttt{\qquad\quad((ms) 1/1000)}

\texttt{\qquad\quad((us) 1/1000000)))}

\texttt{\quad(sleep (* value (unit-to-second unit))))}

}

Поскольку сравнение символов требует сравнения только одного указателя, \textbf{sleep-units\%} будет скомпилирован в очень быструю диспетчеризацию во времени выполнения:

\begin{verbatim}
...
524: CMP ESI, [#x586FC4D0] ; ’S
52A: JEQ L11
530: CMP ESI, [#x586FC4D4] ; ’M
536: JEQ L10
538: CMP ESI, [#x586FC4D8] ; ’H
53E: JEQ L9
540: CMP ESI, [#x586FC4DC] ; ’D
546:
...
\end{verbatim}

Заметьте, как должна закавычиваться единица времени, указанная в \textbf{sleep-units\%}. Это происходит потому, что Лисп начинает вычисление функции с вычисления всех аргументов функции и привязывает результаты к переменным, использующимся внутри функции. Числа, строки и некоторые другие примитивы вычисляются в самих себя, поэтому нам не нужно закавычивать числовые значения, переданные в \textbf{sleep-units\%}. Если же вы хотите чтобы и эти значения не вычислялись, то вы можете закавычить и их:

\begin{verbatim}
(sleep-units% '.5 's)
\end{verbatim}

Однако, как правило, символы не вычисляются в самих себя\footnote{Как правило, нет правил без исключения. Некоторые символы вычисляются в самих себя, например: \textbf{t}, \textbf{nil} и ключевые слова.}. Когда Лисп вычисляет символ, то он предполагает, что вы ссылаетесь на переменную и пытается найти значение, ассоциированное с этой переменной в заданном лексическом контексте (если же переменная объявлена как специальная, то в этом случае поиск происходит в динамическом окружении).

Если мы хотим избежать закавычивания единицы времени, то нам нужно использовать макрос. В отличие от функции макрос не вычисляет свои аргументы. Для того, чтобы воспользоваться этим фактом, мы заменим функцию \textbf{sleep-units\%} макросом \textbf{sleep-units}. Теперь нам не нужно закавычивать единицу времени:

\begin{verbatim}
(sleep-units .5 h)
\end{verbatim}

Листинг 3.2: SLEEP-UNITS\label{listing_3.2}
\hrule
\begin{verbatim}
(defmacro sleep-units (value unit)
  `(sleep
    (* ,value
     ,(case unit
            ((s) 1)
            ((m) 60)
            ((h) 3600)
            ((d) 86400)
            ((ms) 1/1000)
            ((us) 1/1000000)))))
\end{verbatim}
\hrule

И хотя основным предназначением макроса было избежание закавычивания аргумента \textbf{unit}, этот макрос оказывается даже более эффективным чем функция, поскольку не производится диспетчеризация во время выполнения: единица времени и, следовательно, множитель известны в момент компилирования. Конечно, когда мы сталкиваемся с ситуацией слишком-хорошо-чтобы-быть-правдой, то чаще всего всё действительно оказывается слишком хорошим, чтобы быть правдой. Выигрыш в эффективности не даётся бесплатно. Отказавшись от диспетчеризации во время выполнения мы теряем способность определять единицу времени во время выполнения. Используя наш макрос мы не можем выполнить следующий код:

\begin{verbatim}
(sleep-units 1 (if super-slow-mode 'd 'h))
\end{verbatim}

Это не сработает, поскольку \textbf{sleep-units} ожидает что второй аргумент будет одним из символов, в нашем случае вторым аргументом выступает список в котором первым элементом является \textbf{if}.

Напомним, что большинство макросов писались для того, чтобы создать более удобные и полезные программные абстракции, и не предназначались для улучшения эффективности нижележащего кода. Возможно ли извлечь некоторые идиомы из этого кода, с тем, чтобы сделать его более полезным для остальной части нашей программы (и, возможно, для наших будущих программ)? Уже сейчас можно предсказать, что мы можем захотеть выполнять разные операции с временными значениями, чем простой вызов \textbf{sleep}. Макрос \textbf{unit-of-time} абстрагирует функциональность из макроса \textbf{sleep-units}, возвращая значение вместо вызова \textbf{sleep}. Параметр \textbf{value} может определяться во время выполнения программы, поскольку он является вычисляемым, но \textbf{unit} не является вычисляемым, поскольку нам нужна информация во время компиляции, также, как и при \textbf{sleep-units}. Вот пример:

\begin{verbatim}
 * (unit-of-time 1 d)
 86400
\end{verbatim}

Листинг 3.3: UNIT-OF-TIME\label{listing_3.3}
\hrule
\begin{verbatim}
(defmacro unit-of-time (value unit)
  `(* ,value
      ,(case unit
             ((s) 1)
             ((m) 60)
             ((h) 3600)
             ((d) 86400)
             ((ms) 1/1000)
             ((us) 1/1000000))))
\end{verbatim}
\hrule

Такой простой макрос как \textbf{unit-of-time} даёт нам более лучший синтаксис для решения конкретных областей некоторых проблем и может значительно улучшить продуктивность работы и корректность решения задачи. В \emph{разделе Программирование Сверху-Вниз} мы продолжим разработку языка единиц. В отличие от большинства языков программирования, в Лиспе вам доступны те же инструменты, что и у людей создавших вашу программную среду. Для того, чтобы реализовать язык Common Lisp, достаточно использовать макросы, этих же макросов достаточно, чтобы реализовать ваш собственный предметно-ориентированный язык.

\section{Управляющие Структуры}\label{section_control_structures}

Хотя эта книга ориентирована на Common Lisp, идеи, описанные здесь можно применить и для языка программирования Scheme. Scheme - это замечательный язык, и хотя в Scheme отсутствуют многие особенности воспринимаемые Лисп программистами как должное, в нём есть достаточно гибкое ядро, которое при необходимости могут расширить профессиональные Лисп программисты\footnote{В основном, Scheme и Common Lisp различаются в своих сообществах. Scheme программисты любят говорить о том, как здорово иметь короткую спецификацию языка; Common Lisp программисты любят писать программы.}. Аналогичным образом, Scheme программисты приводят, в качестве преимущества, особенности на которых не делается ставка в Common Lisp. Но, сравнение особенностей всех языков, кроме некоторых особенностей, бессмысленно. Часто мы в состоянии перебросить мост между двумя языками. Само собой разумеется, что в роли моста, с помощью которых мы объединяем два языка выступают макросы.

Scheme'овская форма \textbf{let} является более мощной чем её коллега в Common Lisp. Scheme'овская форма \textbf{let} поддерживает нечто, под названием \emph{именованный let (named let)}. В Scheme вы можете вставить символ перед списком привязок \textbf{let} формы и Scheme привяжет функцию под указанным символом вокруг тела \textbf{let}\footnote{В Scheme есть только одно пространство имён, поэтому функция привязывается именно здесь.}. Эта функция принимает новые аргументы для значений, указанных в привязках \textbf{let}, предоставляя очень удобный способ выражения циклов.

Листинг 3.4: NLET\label{listing_3.4}
\hrule
\begin{verbatim}
(defmacro nlet (n letargs &rest body)
  `(labels ((,n ,(mapcar #'car letargs)
              ,@body))
     (,n ,@(mapcar #'cadr letargs))))
\end{verbatim}
\hrule

К счастью, мы можем построить мост между Scheme и Common Lisp с помощью макроса \textbf{nlet}. \textbf{Nlet} даёт нам возможность писать код в Scheme стиле эмулируя Scheme'овские именованные \textbf{let}'ы. В \textbf{nlet-fact}, \textbf{nlet} используется для определения функции факториала с помощью именованного \textbf{let}:

\begin{verbatim}
(defun nlet-fact (n)
  (nlet fact ((n n))
        (if (zerop n)
            1
            (* n (fact (- n 1))))))
\end{verbatim}

Поскольку \textbf{nlet} - это наш первый макрос, сделаем паузу и изучим этот макрос глубже. Иногда для того чтобы понять макрос полезно применить \emph{macroexpand} к примеру, показывающему использование этого макроса\footnote{Терминология расширения на самом деле довольно неудачна. Никто не говорит что при макрорасширении чего-либо результатом будет больший, расширенный код. Иногда формы расширяются даже в ничто (т.е. \textbf{nil}).}. Для этого функции \textbf{macroexpand} мы передадим список, представляющий вызов макроса. Учтите, что \textbf{macroexpand} будет расширять макросы, в которых первый символ списка является макрос символом и не расширяет вложенные макро вызовы\footnote{Но, \textbf{macroexpand} будет продолжать расширение макроса до тех пор, пока первый элемент не будет представлять макрос. \textbf{Macroexpand-1} полезен для наблюдения первого шага в этом процессе.}. Теперь мы скопируем вызов \textbf{nlet} прямо из \textbf{nlet-fact}, закавычим его и передадим в \textbf{macroexpand}:

\begin{verbatim}
CL-USER> (macroexpand
          '(nlet fact ((n n))
            (if (zerop n)
                1
                (* n (fact (- n 1))))))
(LABELS ((FACT (N)
           (IF (ZEROP N)
               1
               (* N (FACT (- N 1))))))
  (FACT N))
T
\end{verbatim}

Расширение использует специальную форму \textbf{labels}, предназначенную для привязки функции вокруг указанного тела. Именованная функция соответствует символу, используемому в форме именованного \textbf{let}. Он получает аргументы значений, привязанных с помощью \textbf{nlet}, в данном случае только \textbf{n}. Поскольку эта функция может быть рекурсивной, \textbf{nlet} реализует полезную итерационную конструкцию.

В простых макросах обычно достаточно использовать обратные кавычки, но более сложные макросы должны использовать хотя бы Лисповские функции обработки списков. \textbf{Mapcar}, применяет функцию к каждому элементу списка и возвращает список из получившихся значений, особенно часто появляется в макросах. Что характерно, \textbf{mapcar} довольно часто появляется и в обычных Лисп программах. Лисп можно настроить так, чтобы его можно было по максимуму использовать для обработки списков. Во всех разновидностях Лисп программирования мы занимаемся тем, что объединяем, разделяем, уменьшаем, отображаем и фильтруем списки. Единственная разница в том, что при программировании макросов вывод непосредственно переходит к компилятору или интерпретатору. Программирование макросов в Лиспе - это, по сути, то же самое что и обычное Лисп программирование.

Но что даёт нам право сказать что \textbf{nlet} - это новая управляющая структура? Управляющая структура - это всего лишь забавный способ определения некоторой конструкции, которая не следует поведению функции. Функция вычисляет каждый аргумент слева направо, привязывает результаты в среде и выполняет машинный код, определённый в некоторой \textbf{lambda} форме. Поскольку \textbf{nlet} не вычисляет напрямую свои аргументы, а вместо этого объединяет их в некоторый кусок Лисп кода, мы изменили выполнение вычисления для \textbf{nlet} форм и тем самым создали новую управляющую структуру.

Руководствуясь этим грубым определением, можно сказать что все макросы - по крайней мере все интересные макросы - определяют новые управляющие структуры. Когда люди говорят ``используйте макросы только тогда, когда недостаточно функций'', они имеют ввиду определения, где вы не хотите допустить вычисление некоторых аргументов или вы хотите вычислить аргументы в другом порядке или хотите чтобы аргументы вычислялись несколько раз, то в этом случае вам нужно использовать макросы. Функции, вне зависимости от того насколько хорошо они написаны, просто не будут выполнять эти задачи.

Common Lisp очень удобен для создания макросов, макрос \textbf{nlet} показывает одно из этих преимуществ. В таких формах привязки как \textbf{let}, существует общее соглашение, которое гласит: если переменной не привязано какое-либо значение, то эта переменная будет привязана к \textbf{nil}. Другими словами результатом вычисления \verb"(let ((a)) a)" будет \textbf{nil}\footnote{Common Lisp позволяет нам писать даже так: \verb"(let (a) a)" что в итоге даст все тот-же эффект.}. В Scheme, а этот язык менее дружественный к созданию макросов, этот случай должен проверяться как частный случай при итерации с подобными привязками, по причине того, что \verb"(car nil)" и \verb"(cdr nil)" вернут ошибки типа. В Common Lisp \verb"(car nil)", \verb"(cdr nil)" и, следовательно, \verb"(car (cdr nil))" и \verb"(cadr nil)" вернут \textbf{nil}, позволяя второму \textbf{mapcar} в \textbf{nlet} продолжать работу даже если используется соглашение о пустом \textbf{let} значении. Эта особенность Common Lisp взята из Interlisp [INTERLISP].

Наш макрос \textbf{nlet} отличается от именованного \textbf{let} в Scheme очень маленькой деталью. В этом случае интерфейс макроса является приемлемым, но расширения может и не быть. В общем случае, при программировании через несколько уровней, наша ментальная модель кода может немного отличаться от реальности. В Scheme, при выполнении хвостовой рекурсии именованного \textbf{let} гарантируется неупотребление дополнительного стекового пространства, поскольку Scheme гарантирует, согласно стандарту, выполнение специальной оптимизации. Это не тот случай в Common Lisp, поэтому не исключается переполнение стека в Common Lisp'овской версии \textbf{nlet}, чего не произойдёт с именованным \textbf{let} в Scheme. В \emph{разделе Проход по Коду с Macrolet} мы рассмотрим как написать версию \textbf{nlet} с идентичным интерфейсом но, с потенциально более эффективным расширением\footnote{На практике, обычно бывает достаточно и этой версии \textbf{nlet}, поскольку компилятор Common Lisp почти наверняка оптимизирует хвостовые вызовы в скомпилированном коде.}.

\section{Свободные Переменные}\label{section_free_variables}

\emph{Свободная переменная (free variable)} - это любая переменная или функция, ссылающаяся на выражение, не имеющее специальной глобальной привязки или ограничивающей лексической привязки. В следующем выражении \textbf{x} является свободной переменной:

\begin{verbatim}
(+ 1 x)
\end{verbatim}

В следующем примере мы создаём привязку вокруг формы, эта привязка \emph{захватывает (captures)} переменную \textbf{x}, лишая её свободы:

\begin{verbatim}
(let ((x 1))
  (+ 1 x))
\end{verbatim}

На первый взгляд терминология свободы и захвата может показаться странной. В конце концов, свобода подразумевает сознательность и возможность принятия решений - очевидно, что выразить всё простым выражением не получится. Но свобода не относится к тому, что может выполнять выражение, скорее, это относится к тому, что мы, как программист, можем выполнять с этим выражением. Например, мы можем взять выражение \verb'(+ 1 x)' и встроить его куда-либо ещё, позволяя нашему выражению получить доступ к \textbf{x}, привязанному к окружающему коду. Затем мы можем сказать что код \emph{захватил (captured)} нашу свободную переменную. После того, как свободные переменные в выражении были захвачены, как в предыдущей форме \textbf{let}, другой окружающий код не может захватить нашу переменную \textbf{x}. Наша в прошлом свободная переменная уже была захвачена. Теперь вполне однозначно ясно куда ссылается \textbf{x}. По этой причине понятно почему Лиспу не надо хранить значение, на которое ссылается символ \textbf{x} на протяжении всего кода. Как мы описали в деталях в \emph{разделе Лексическая и Динамическая Области Видимости}, Лисп компиляторы забывают символы, которые были использованы для представления лексических переменных.

Возможности макросов означают что свободные переменные в Лиспе гораздо более полезны чем в других языках, хотя в любом, поддерживающим выражения, языке может быть код со свободными переменными. В большинстве языках мы вынуждены подчиняться \emph{ссылочной прозрачности (referential transparency)}. Если в Блаб языке не объявлена глобальная или объектная переменная \textbf{x}, то следующий код безусловно неверен:

\begin{verbatim}
some_function_or_method() {
  anything(1 + x);
\end{verbatim}

Нет никакого способа, с помощью которого {\selectlanguage{english}\textbf{so\-me\_func\-tion\_or\_me\-thod}} мог бы создать \emph{неявную привязку} к \textbf{x}. В Блабе любое использование переменной должно быть текстово очевидным определением\footnote{Или, иногда, в объектно-ориентированном Блабе, определения класса или объекта.}. Языки с примитивной макро системой (такие как C) могут реализовывать некоторые приёмы, но, реализация этих приёмов весьма ограничена. Создание макросов в C непрактично или невозможно, также, как и частные случаи использования свободных переменных.

В Лиспе мы можем оперировать выражениями со свободными переменными так, как нам заблагорассудится и либо объединить их в новое выражение, захватываемое окружающим кодом, или определить специальные глобальные переменные для последующего захвата. Также мы можем написать макрос, который модифицирует и освобождает переменные в выражении или переписывает выражение с целью уменьшения количества свободных переменных (например, как представлено выше, оборачивая выражение в \textbf{let} форму) или модифицируя выражение с целью добавления новых свободных переменных. Такое добавление свободных переменных является противоположностью захвата переменных и называется \emph{инъекцией свободной переменной (free variable injection)}.

Простейшей инъекцией свободной переменной является макрос, расширяющийся в ссылку на символ:

\begin{verbatim}
(defmacro x-injector ()
  'x)
\end{verbatim}

Поскольку макрос - это та же функция, то он исполняет своё тело как обычную Лисп форму. Вышеприведённый макрос - инжектор вычисляет закавыченный символ и, конечно, возвращает символ - свободную переменную - которая будет объединена с любым, использующим макрос \textbf{x-injector}, выражением. Обсуждая такие инъекции свободных переменных в \emph{On Lisp}, Пол Грэм написал

\begin{quote}
\emph{Подобная разновидность лексических взаимодействий обычно рассматривается как источник проблем, нежели как источник удовольствия. Обычно написание макросов в таком ключе является плохим стилем. Из всех макросов в этой книге, только [два изолированных случая] используют вызов среды подобным способом.}
\end{quote}

В противоположность \emph{On Lisp} в этой книге получают большое удовольствие от таких разновидностей лексических взаимодействий. Инъекция свободной переменной - это создание макроса с полным знанием лексической среды, в которую он будет расширен - это всего лишь другой подход к программированию Лисп макросов, который особенно полезен при наличии нескольких немного отличающихся лексических контекстов, в которых вы можете захотеть написать почти идентичный код. Хотя главным преимуществом вызова функций является вынос за пределы функции вашей лексической среды, иногда, для Лисп программистов, это всего лишь руководство к действию, которое может быть проигнорировано через использование макросов. Фактически, только привыкнув к этому, некоторые Лисп программисты по возможности всегда стараются писать макросы, расширяя лексический контекст настолько, насколько это возможно, и используют функции только когда им нужно вычислить аргументы или просто для того, чтобы поджать хвост при желании нового лексического контекста. В \emph{разделе Once Only} мы рассмотрим способ не допустить вывода наружу вашей лексической среды при вычислении аргументов. Сохранение окружающей лексической среды до тех пор, пока это возможно, позволяет нам выполнять очень интересные \emph{комбинации (combinations)} макросов, где макрос добавляет окружающий лексический контекст для использования несколькими другим макросами. Расширения в коде, которые очень сильно используют макросы будут определены как частный случай комбинации макросов и будут рассмотрены в \emph{разделе Рекурсивные Расширения}.

Кратчайший путь между двумя точками - это прямая линия. Свободные переменные и, более глобально, расширенные лексические контексты - это наиболее простейший способ программного построения программ. Здесь применение макросов может показаться хаком и нежелательным со стилистической точки зрения, но даже здесь использование макросов удобно и надёжно. Особенно после того, как мы рассмотрим \textbf{macrolet} в \emph{разделе Проход по Коду с помощью Macrolet}, этот стиль программирования - комбинирование макросов - покажется вам более комфортабельным. Только помните, что программирование макросов - это не вопрос стиля; это вопрос мощи. Макросы дают нам возможность выполнять такие вещи, реализация которых невозможна в других языках. Одна из них - это инъекция свободной переменной.

