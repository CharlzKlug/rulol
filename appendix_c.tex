\chapter*{Приложение C}
\markboth{\MakeUppercase{Приложение C}}{}
\addcontentsline{toc}{chapter}{Приложение C}

\section*{C.1 CMUCL/SBCL}
\markboth{\MakeUppercase{C.1 CMUCL/SBCL}}{}
\addcontentsline{toc}{section}{C.1 CMUCL/SBCL}

История системы CMUCL/SBCL предшествует COMMON LISP-у\footnote[1]{Раньше CMUCL назывался SPICE Lisp.}. SBCL --- это родственный форк CMUCL. По-моему мнению, CMUCL --- это лучшая лисп среда из ныне существующих, на втором месте располагается SBCL. CMUCL и SBCL оба предоставляют исключительно продуктивные среды разработки. Обе реализации включают в себя удивительный оптимизирующий компилятор в машинный код Python\footnote[2]{Имя предшествует Python-у, скриптовому языку.}. После довольно простого процесса декларирования COMMON LISP кода выполняется компилирование Python-ом, производительность которого может соперничать или превосходить компиляторы для других языков, особенно при использовании на больших или сложных приложениях. Самая большая разница между CMUCL и SBCL заключается в том, что SBCL использует Python всюду, а CMUCL предоставляет несколько компиляторов и интерпретаторов, каждый со своими сильными и слабыми сторонами.

Большинство примеров в этой книге исполнялось в CMUCL, хотя иногда использовался дизассемблер SBCL (по причине генерации читабельного вывода). CMUCL менее раздражает излишними предупреждениями и обладает более удобным REPL-ом, но SBCL даёт более ясные замечания и лучше подходит для задач связанных с Юникодом. В архитектуре SBCL выполнены некоторые решения, с которыми я не согласен, в частности нарушено CMUCL-овское высокоуровневое свойство \textbf{setq}, используются менее очевидные имена для системных символов и бессмысленное копирование юниксовского getopt(3)\index{getopt}.

CMUCL и SBCL позволяют насладиться большим количеством библиотек и ярким он-лайн сообществом. Для меня очень странно слышать людей, утверждающих что доступность библиотек является проблемой для лиспа. Я нахожу ситуацию с библиотеками прямо противоположной. Библиотеки в COMMON LISP-е обычно лучше поддерживаются и лучшего качества чем в остальных языках. Интерфейс сторонних функций (foreign function interface --- FFI) CMUCL/SBCL также замечателен --- более гибкий, стабильный и эффективный чем то, что я встречал в любом другом языке. Библиотеки никогда не были для меня серьёзной проблемой при разработке чего-либо на COMMON LISP.

\section*{C.2 CLISP}
\markboth{\MakeUppercase{C.2 CLISP}}{}
\addcontentsline{toc}{section}{C.2 CLISP}

CLISP --- другая замечательная COMMON LISP среда. Она гораздо переносимей чем CMUCL/SBCL и может запускаться почти везде, где можно применить компилятор C. Поскольку CLISP компилируется не в машинный-код, а в формат байт-кода, то он часто медленней чем CMUCL/SBCL, иногда из-за этого CLISP не используют в разворачивании. Но иногда разворачивание в CLISP --- наиболее разумный выбор если вам требуется переносимость. Также CLISP примечателен быстрой работой с большими целыми числами.

\section*{C.3 Другие}
\markboth{\MakeUppercase{C.3 Другие}}{}
\addcontentsline{toc}{section}{C.3 Другие}

ECL --- реализация COMMON LISP написанная на C и предназначенная для встраивания. Эта реализация следует за CLISP-ом и является достаточно полной для использования. ECL может быть хорошей средой для разворачивания в машинах с чрезвычайно ограниченной памятью. Благодаря библиотеке GMP она также обладает хорошей производительностью при работе с большими целыми числами.

GCL --- это реализация COMMON LISP использующая компилятор GNU C для компилирования лиспа в машинный код, где C играет роль промежуточного звена. GCL испытала влияние Kyoto CL [KYOTO-CL-REPORT]. В целом не так хороша как CMUCL/SBCL или CLISP, но, ещё можно обратить внимание.

Armed Bear --- реализация COMMON LISP, запускающаяся поверх Виртуальной Машины Java. Может быть полезной для интеграции с существующими Java приложениями.

Виртуальная машина Parrot Perl имеет COMMON LISP фронтенд за которым я наблюдаю.

Clozure CL (в прошлом OpenMCL) --- хорошая реализация COMMON LISP с открытым исходным кодом, до тех пор, пока она не запускается на проприетарной операционной системе.

Кроме того, есть много проприетарных реализаций COMMON LISP-а. Некоторые из них высокого качества, но все они страдают от критического дефекта --- не-технические барьеры, не дающие вам познавать и создавать новое. Принимая в учёт качество и количество лиспов с открытым исходным кодом, сегодня нет никакой надобности запирать себя в дорогих реализациях без исходных кодов или даже в ещё более ограниченных пробных версиях.

Сегодня, с замечательными реализациями COMMON LISP-а с открытыми исходными кодами, в сочетании с такими превосходными операционными системами как OpenBSD и GNU/Linux мы входим в золотой век вычислений. Сегодня ничто не останавливает программиста кроме барьеров его собственного интеллекта и креативности.
