\chapter{Считывающие Макросы}\label{chapter_reading_macros}
\section{Время-Работы как Время-Чтения}\label{section_run-time_at_read-time}

\begin{quote}
Синтаксический сахар вызывает рак точек с запятой

- Алан Перлис
\end{quote}

Не один только Лисп даёт прямой доступ к коду, который может разбираться на структуры из cons ячеек, но, кроме этого Лисп предоставляет доступ к символам, составляющим ваши программы, ещё до того, как программы будут представлять из себя структуру. Обычный макрос работает с программой в форме дерева. Кроме обычного макроса существует специальный тип макросов, называемых \emph{считывающими макросами (read macro)}, оперирующими сырыми символами, из которых состоит ваша программа.

Если нам понадобиться определить не-Лисповский синтаксис в Лиспе, то в этом случае не имеет смысла использовать Лисповский считыватель - он предназначен только для чтения Лиспа. Считывающий макрос - это устройство, используемое для обработки не-Лисп синтаксиса, после считывающего макроса в дело вступает Лисп считыватель. Причина, по которой Лисп считыватель является более мощным чем считыватели в других языках заключается в том, что Лисп даёт нам возможность \emph{перехватывать (hooks)} каждый аспект поведения считывателя. В частности, Лисп позволяет вам \emph{расширять} считыватель, таким образом, что не-Лисп объекты будут прочитываться и преобразовываться в Лисп объекты. Также, как вы строите ваши приложения поверх Лиспа, расширяя его с помощью макросов и функций, также и Лисп приложения могут, а чаще всего и просачиваются в это измерение расширяемости. Когда это происходит, то становится возможным чтение любого символа на основе синтаксиса с помощью Лисп считывателя, а это означает что вы добавили этот синтаксис в Лисп.

В то время, когда трансформация кода, выполняемая обычными макросами используется для вставки Лисп кода в новый Лисп код, считывающие макросы могут быть написаны для вставки не-Лисп кода в Лисп код. Подобно обычным макросам, считывающие макросы реализуются с помощью функций, благодаря этому мы имеем доступ ко всей мощи Лисп окружения. Подобно макросам, увеличивающим продуктивность через создание более удобного предметно ориентированного языка, считывающие макросы увеличивают продуктивность позволяя сокращать выражения в точку где они больше не являются выражениями.

Если всё что нам нужно для того, чтобы разобрать эти не-Лисповские предметно-ориентированные языки - это написать короткий считывающий макрос, то может быть эти не-Лисп языки на самом деле являются умно замаскированным Лиспом. Если XML может прямо считываться Лисп считывателем [XML-AS-READ-MACRO], то может быть XML - это просто видоизменённый Лисп. Подобным образом считывающие макросы могут использоваться для чтения регулярных выражений и SQL запросов прямо в Лисп, то может быть эти языки на самом деле являются Лиспом. Это нечёткое различие между кодом и данными, Лиспом и не-Лиспом, являются источником многих интересных философских проблем, возникающих перед Лисп программистами с самого начала зарождения Лиспа.

Базовый считывающий макрос, встроенный в Common Lisp - это \emph{\#.} - вычисляющий макрос в момент чтения. Этот считывающий макрос позволяет вам встраивать объекты в читаемые, не сериализируемые формы, но создаваемые с помощью Лисп кода. Один забавный пример - это создание формы, содержащей изменяющиеся значения при каждом вызове.

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 177030) (COIN-FLIP TAILS))
\end{verbatim}

Несмотря на то, что это то-же самое выражение, эта форма считывается по разному раз за разом:

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 385713) (COIN-FLIP HEADS))
\end{verbatim}

Заметьте, что две формы окружённые \emph{\#.} вычисляются в момент чтения, а не тогда, когда вычисляется форма. Полный список был сформирован после того, как они были вычислены, а предыдущая и последующая эквивалентность (определённая \textbf{equal}'ом) может быть обнаружена через повторное вычисление последней прочитанной формы и сравнения её с предыдущими результатами, с помощью вспомогательных переменных \emph{*}, \emph{+} в REPL\footnote{Переменная \emph{*} содержит значение, являющееся результатом предыдущей формы, а переменная \emph{+} содержит значение последней формы.}:

\begin{verbatim}
CL-USER> (equal * (eval +))
T
\end{verbatim}

Следует обратить внимание на то, что эти формы вычисляются в момент чтения, этим они отличаются от использования обратной кавычки, более подробно мы рассмотрим обратную кавычку в следующем разделе. Мы можем вычислить подобную форму с помощью использования обратных кавычек:

\begin{verbatim}
CL-USER> `(football-game
           (game-started-at
            ,(get-internal-real-time))
           (coin-flip
            ,(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 722283) (COIN-FLIP TAILS))
\end{verbatim}

но в этом случае будет происходить вычисление в различные результаты, поскольку обратная кавычка производит считывание в виде кода для вычисления:

\begin{verbatim}
CL-USER> (equal * (eval +))
NIL ;если вы не очень быстрый и удачливый
\end{verbatim}


