\chapter{Считывающие Макросы}\label{chapter_reading_macros}
\section{Время-Работы как Время-Чтения}\label{section_run-time_at_read-time}

\begin{quote}
Синтаксический сахар вызывает рак точек с запятой

- Алан Перлис
\end{quote}

Не один только Лисп даёт прямой доступ к коду, который может разбираться на структуры из cons ячеек, но, кроме этого Лисп предоставляет доступ к символам, составляющим ваши программы, ещё до того, как программы будут представлять из себя структуру. Обычный макрос работает с программой в форме дерева. Кроме обычного макроса существует специальный тип макросов, называемых \emph{считывающими макросами (read macro)}, оперирующими сырыми символами, из которых состоит ваша программа.

Если нам понадобиться определить не-Лисповский синтаксис в Лиспе, то в этом случае не имеет смысла использовать Лисповский считыватель - он предназначен только для чтения Лиспа. Считывающий макрос - это устройство, используемое для обработки не-Лисп синтаксиса, после считывающего макроса в дело вступает Лисп считыватель. Причина, по которой Лисп считыватель является более мощным чем считыватели в других языках заключается в том, что Лисп даёт нам возможность \emph{перехватывать (hooks)} каждый аспект поведения считывателя. В частности, Лисп позволяет вам \emph{расширять} считыватель, таким образом, что не-Лисп объекты будут прочитываться и преобразовываться в Лисп объекты. Также, как вы строите ваши приложения поверх Лиспа, расширяя его с помощью макросов и функций, также и Лисп приложения могут, а чаще всего и просачиваются в это измерение расширяемости. Когда это происходит, то становится возможным чтение любого символа на основе синтаксиса с помощью Лисп считывателя, а это означает что вы добавили этот синтаксис в Лисп.

В то время, когда трансформация кода, выполняемая обычными макросами используется для вставки Лисп кода в новый Лисп код, считывающие макросы могут быть написаны для вставки не-Лисп кода в Лисп код. Подобно обычным макросам, считывающие макросы реализуются с помощью функций, благодаря этому мы имеем доступ ко всей мощи Лисп окружения. Подобно макросам, увеличивающим продуктивность через создание более удобного предметно ориентированного языка, считывающие макросы увеличивают продуктивность позволяя сокращать выражения в точку где они больше не являются выражениями.

Если всё что нам нужно для того, чтобы разобрать эти не-Лисповские предметно-ориентированные языки - это написать короткий считывающий макрос, то может быть эти не-Лисп языки на самом деле являются умно замаскированным Лиспом. Если XML может прямо считываться Лисп считывателем [XML-AS-READ-MACRO], то может быть XML - это просто видоизменённый Лисп. Подобным образом считывающие макросы могут использоваться для чтения регулярных выражений и SQL запросов прямо в Лисп, то может быть эти языки на самом деле являются Лиспом. Это нечёткое различие между кодом и данными, Лиспом и не-Лиспом, являются источником многих интересных философских проблем, возникающих перед Лисп программистами с самого начала зарождения Лиспа.

Базовый считывающий макрос, встроенный в Common Lisp - это \emph{\#.} - вычисляющий макрос в момент чтения. Этот считывающий макрос позволяет вам встраивать объекты в читаемые, не сериализируемые формы, но создаваемые с помощью Лисп кода. Один забавный пример - это создание формы, содержащей изменяющиеся значения при каждом вызове.

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 177030) (COIN-FLIP TAILS))
\end{verbatim}

Несмотря на то, что это то-же самое выражение, эта форма считывается по разному раз за разом:

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 385713) (COIN-FLIP HEADS))
\end{verbatim}

Заметьте, что две формы окружённые \emph{\#.} вычисляются в момент чтения, а не тогда, когда вычисляется форма. Полный список был сформирован после того, как они были вычислены, а предыдущая и последующая эквивалентность (определённая \textbf{equal}'ом) может быть обнаружена через повторное вычисление последней прочитанной формы и сравнения её с предыдущими результатами, с помощью вспомогательных переменных \emph{*}, \emph{+} в REPL\footnote{Переменная \emph{*} содержит значение, являющееся результатом предыдущей формы, а переменная \emph{+} содержит значение последней формы.}:

\begin{verbatim}
CL-USER> (equal * (eval +))
T
\end{verbatim}

Следует обратить внимание на то, что эти формы вычисляются в момент чтения, этим они отличаются от использования обратной кавычки, более подробно мы рассмотрим обратную кавычку в следующем разделе. Мы можем вычислить подобную форму с помощью использования обратных кавычек:

\begin{verbatim}
CL-USER> `(football-game
           (game-started-at
            ,(get-internal-real-time))
           (coin-flip
            ,(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 722283) (COIN-FLIP TAILS))
\end{verbatim}

но в этом случае будет происходить вычисление в различные результаты, поскольку обратная кавычка производит считывание в виде кода для вычисления:

\begin{verbatim}
CL-USER> (equal * (eval +))
NIL ;если вы не очень быстрый и удачливый
\end{verbatim}

\section{Обратная Кавычка}\label{section_backquote}

\emph{Обратная кавычка}, иногда называемая как \emph{квазикавычка (quasiquote)}\footnote{Scheme программисты называют её квазикавычкой а Common Lisp программисты - обратной кавычкой.} и отображаемая как \verb"`" - это относительно новый элемент в промышленных диалектах Лиспа. Эта концепция по-прежнему абсолютно чужда для не-Лисп языков программирования.

У обратной кавычки странная история развития. Обратная кавычка развивалась параллельно с Лиспом. Есть сведения [QUASIQUOTATION] о том, что раньше никто не верил в то, что вложенные обратные кавычки будут работать правильно, пока умные программисты не выяснили что обратные кавычки правильно выполняют свою работу - идеи людей о том, что было верным оказались неверными. Известно, что трудно понять работу вложенной обратной кавычки. Даже Стил (Steele), отец Common Lisp'а, жалуется на это [CLTL2—P530].

В принципе Лисп не нуждается в обратной кавычке. Всё, что можно выполнить с помощью обратной кавычки - можно выполнять с помощью других функций, предназначенных для постройки списков. Однако, обратная кавычка настолько полезна при программировании макросов, а в Лиспе под программированием понимается программирование макросов, что Лисп профессионалы очень активно ею пользуются.

Вначале мы должны разобраться с обычным закавычиванием. В Лиспе, мы используем префикс формы в виде символа кавычки (') для того, чтобы информировать Лисп о том, что следующая форма должна рассматриваться как сырые данные, а не как код, который нужно вычислить. Или, если выразиться иначе, результатом вычисления кавычки в коде будет возвращение формы. Иногда мы говорим что кавычка \emph{останавливает} или \emph{отключает} вычисление формы.

В Лиспе обратная кавычка может использоваться как замена кавычки. Исключая некоторые специальные символы, называемые символами \emph{раскавычивания (unquote)} и могущие появиться в форме, обратная кавычка останавливает вычисление тем-же способом, что и кавычка. Как следует из названия символы раскавычивания изменяют семантику вычисления. Иногда мы говорим что раскавычивание \emph{перезапускает} или \emph{включает} вычисление формы.

Есть три главных типа раскавычивания: обычное раскавычивание, объединяющее раскавычивание и деструктивное, объединяющее раскавычивание.

Для выполнения обычного раскавычивания, мы используем оператор запятую:

\begin{verbatim}
CL-USER> (let ((s 'hello))
           `(,s world))
(HELLO WORLD)
\end{verbatim}

Хотя выражение, которое мы раскавычили является простым вычислением символа, \textbf{s}, на месте этого символа может быть любое Лисп выражение, вычисляемое в нечто значимое для любого контекста, в котором оно появляется в шаблоне обратной кавычки. Каким бы ни был результат, он будет вставлен в результирующий список в car позиции того места в котором он появился в шаблоне обратной кавычки.

В нотации Лисповской формы мы можем использовать \textbf{.} если мы хотим явно вставить что-либо cdr'ное в создаваемую списковую структуру. Если здесь мы вставим список, то результирующей формой обратной кавычки будет корректный список. Но, если здесь мы вставим что-нибудь другое, то мы получим новую не-списковую структуру.

Такое-же поведение доступно нам везде, в том числе внутри обратной кавычки\footnote{Поскольку обратная кавычка использует (почти ту же) стандартную функцию \textbf{read} что и везде.}. Благодаря архитектуре обратной кавычки мы можем раскавычивать элементы даже в такой позиции:

\begin{verbatim}
CL-USER> (let ((s '(b c d)))
           `(a .,s))
(A B C D)
\end{verbatim}

Вставка списков в \emph{cdr} позиции создаваемого списка из шаблона обратной кавычки оказалось весьма универсальной операцией, поэтому был сделан следующий шаг названный как объединяющее раскавычивание. Вышеприведённая комбинация \textbf{.,} полезна, но не способна вставлять элементы в середину списка. Для этого у нас есть оператор объединяющее раскавычивание:

\begin{verbatim}
CL-USER> (let ((s '(b c d)))
           `(a ,@s e))
(A B C D E)
\end{verbatim}

Ни \textbf{.,} ни \textbf{,@} не модифицируют сращиваемый список. Для примера, после вычисления обратной кавычки в обеих предыдущих формах, \textbf{s} по прежнему будет привязан к трёх элементному списку \textbf{(B C D)}. Хотя это не является строго определяемым стандартом, в форме \textbf{(A B C D)}, \textbf{(B C D)} может являться общей структурой с объединённым списком \textbf{s}. Однако, структура списка \textbf{(A B C D E)} гарантирует, что она будет свежесозданной при вычислении обратной кавычки, поскольку \textbf{,@} запрещено модифицировать сращенные списки. Объединяющее раскавычивание - не деструктивная операция, поскольку в целом нам нужно думать об обратной кавычке как о компонуемом шаблоне для создания списков. Деструктивная модификация списковой структуры не свежесозданных данных при каждом вычислении обратно закавыченного кода может иметь нежелательные эффекты в плане будущих расширений.

Однако, в Common Lisp есть деструктивная версия сращиваемого раскавычивания, которое вы можете использовать везде, где можно использовать сращивающее раскавычивание. Для деструктивного раскавычивания используйте \textbf{,.} . Деструктивное сращивание работает также, как и обычное сращивание, за исключением того, что сращиваемый список может быть модифицирован в процессе вычисления шаблона обратной кавычки. И хотя отличие от обычного раскавычивания выражается всего лишь в одном символе, эта нотация более умно использует символ \textbf{.} из \emph{cdr} позиционного раскавычивания \textbf{.,} рассмотренного выше.

Для того, чтобы увидеть это в действии, в этом примере мы деструктивно модифицируем список указанный в \emph{to-splice}:

\begin{verbatim}
CL-USER> (defvar to-splice '(B C D))
TO-SPLICE
CL-USER> `(A ,.to-splice E)
(A B C D E)
CL-USER> to-splice
(B C D E)
\end{verbatim}

Выполнение де\-струк\-тив\-ной модификации сращиваемых списков может быть опасной операцией. Рассмотрим следующее применение деструктивного сращивания:

\begin{verbatim}
(defun dangerous-use-of-bq ()
  `(a ,. '(b c d) e))
\end{verbatim}

При первом вызове \textbf{dangerous-use-of-bq} возвращается ожидаемый ответ: \textbf{(A B C D E)}. Но, поскольку эта функция использует деструктивное сращивание и модификацию не свежесгенерированных списков - закавыченный список - то мы можем ожидать возникновения различных нежелательных последствий. В этом случае при втором вычислении \textbf{dangerous-use-of-bq} форма \textbf{(B C D)} будет представлять из себя форму \textbf{(B C D E)} и в момент, когда обратная кавычка попытается деструктивно срастить этот список с остатком шаблона обратной кавычки \textbf{(E)} - его собственный хвост - будет создан список, содержащий \emph{цикл (cycle)}. Более детально мы обсудим циклы в \emph{разделе Циклические Выражения}.

Однако, есть много случаев в которых деструктивное сращивание является чрезвычайно безопасным. Не позволяйте \textbf{dangerous-use-of-bq} напугать вас если вам нужна повышенная эффективность в ваших формах обратной кавычки. Есть множество операций, создающих свежие списковые структуры, которые вам так или иначе могут не понадобиться. Например, сращивание результатов \emph{mapcar} настолько распространено и безопасно, что вполне может претендовать на программную идиому:

\begin{verbatim}
(defun safer-use-of-bq ()
  `(a
    ,.(mapcar #'identity '(b c d))
    e))
\end{verbatim}

Но, есть деталь, которая мешает этому. Чаще всего обратная кавычка используется для создания макросов, часть программирования на Лиспе, где менее важна скорость и более важна ясность. Если думать о \emph{побочных эффектах} в ваших операциях сращивания, то при создании и интерпретации макросов вам придётся часто отвлекаться на них, а это не стоит свеч. Эта книга придерживается обычных сращиваний. Чаще всего обратная кавычка используется для конструирования макросов, но, это не единственное их использование. Обратная кавычка - это удобный предметно ориентированный язык для смешивания списков, и ещё более удобным он становится с возможностью деструктивного сращивания.

Как работает обратная кавычка? Обратная кавычка - это считывающий макрос. Формы обратной кавычки читаются как код, который при вычислении, становится желаемым списком. Возвращаясь к примеру из предыдущего раздела о вычислении во время выполнения, мы можем отключить \emph{красивую печать (pretty printing)}, закавычить значение формы обратной кавычки и вывести его на печать для того, чтобы увидеть как читаются формы с обратной кавычкой\footnote{Мы возвращаем \textbf{t} и поэтому мы не видим значения, возвращаемого от \textbf{print}. \textbf{(values)} также универсальны.}:

\begin{verbatim}
CL-USER> (let (*print-pretty*);привязка к nil
           (print
            '`(football-game
            (game-started-at
             ,(get-internal-real-time))
            (coin-flip
             ,(if (zerop (random 2))
                  'heads
                  'tails))))
           t)

(SB-IMPL::BACKQ-LIST 
 (QUOTE FOOTBALL-GAME) 
 (SB-IMPL::BACKQ-LIST 
  (QUOTE GAME-STARTED-AT) 
  (GET-INTERNAL-REAL-TIME)) 
 (SB-IMPL::BACKQ-LIST 
  (QUOTE COIN-FLIP) 
  (IF (ZEROP (RANDOM 2)) 
      (QUOTE HEADS) 
      (QUOTE TAILS)))) 
T
\end{verbatim}

В этой, \emph{некрасиво напечатанной} форме, функция {\selectlanguage{english}\textbf{LISP::BACKQ-LIST}} идентична \textbf{list}, за исключением поведения, связанного с красивой печатью. Заметьте, что операторы запятая исчезли. Common Lisp очень либерален и поэтому позволяет читать обратные кавычки, также, как и допускает операции с использованием общих структур.

Кроме того обратная кавычка предоставляет много интересных решений забавной \emph{не совсем проблемы} написания Лисп выражений, вычисляющихся в самих себя. Эти выражения часто называются \emph{куайнами} в честь Уилларда Куайна, который занимался их широким изучением и кто, по сути, ввёл термин квазицитирования - альтернативное название обратной кавычки [FOUNDATIONS-P31-FOOTNOTE3]. Вот забавный пример куайна, от Майка МакМахонома (Mike McMahon) {\selectlanguage{english} [QUASIQUOTATION]}:

\begin{verbatim}
CL-USER> (let ((let '`(let ((let ',let))
                        ,let)))
           `(let ((let ',let)) ,let))
(LET ((LET
       '`(LET ((LET ',LET))
           ,LET)))
  `(LET ((LET ',LET))
     ,LET))
\end{verbatim}

Для сохранения вашего \emph{ментального прохода по коду}:

\begin{verbatim}
CL-USER> (equal * +)
T
\end{verbatim}

Упражнение: Почему в выражении ниже обратная кавычка расширяется в обычную кавычку? Разве оно не закавычено?

\begin{verbatim}
CL-USER> `'q
'Q
\end{verbatim}
