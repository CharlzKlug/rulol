\chapter{Считывающие Макросы}\label{chapter_reading_macros}
\section{Время-Работы как Время-Чтения}\label{section_run-time_at_read-time}

\begin{quote}
Синтаксический сахар вызывает рак точек с запятой

- Алан Перлис
\end{quote}

Не один только Лисп даёт прямой доступ к коду, который может разбираться на структуры из cons ячеек, но, кроме этого Лисп предоставляет доступ к символам, составляющим ваши программы, ещё до того, как программы будут представлять из себя структуру. Обычный макрос работает с программой в форме дерева. Кроме обычного макроса существует специальный тип макросов, называемых \emph{считывающими макросами (read macro)}, оперирующими сырыми символами, из которых состоит ваша программа.

Если нам понадобиться определить не-Лисповский синтаксис в Лиспе, то в этом случае не имеет смысла использовать Лисповский считыватель - он предназначен только для чтения Лиспа. Считывающий макрос - это устройство, используемое для обработки не-Лисп синтаксиса, после считывающего макроса в дело вступает Лисп считыватель. Причина, по которой Лисп считыватель является более мощным чем считыватели в других языках заключается в том, что Лисп даёт нам возможность \emph{перехватывать (hooks)} каждый аспект поведения считывателя. В частности, Лисп позволяет вам \emph{расширять} считыватель, таким образом, что не-Лисп объекты будут прочитываться и преобразовываться в Лисп объекты. Также, как вы строите ваши приложения поверх Лиспа, расширяя его с помощью макросов и функций, также и Лисп приложения могут, а чаще всего и просачиваются в это измерение расширяемости. Когда это происходит, то становится возможным чтение любого символа на основе синтаксиса с помощью Лисп считывателя, а это означает что вы добавили этот синтаксис в Лисп.

В то время, когда трансформация кода, выполняемая обычными макросами используется для вставки Лисп кода в новый Лисп код, считывающие макросы могут быть написаны для вставки не-Лисп кода в Лисп код. Подобно обычным макросам, считывающие макросы реализуются с помощью функций, благодаря этому мы имеем доступ ко всей мощи Лисп окружения. Подобно макросам, увеличивающим продуктивность через создание более удобного предметно ориентированного языка, считывающие макросы увеличивают продуктивность позволяя сокращать выражения в точку где они больше не являются выражениями.

Если всё что нам нужно для того, чтобы разобрать эти не-Лисповские предметно-ориентированные языки - это написать короткий считывающий макрос, то может быть эти не-Лисп языки на самом деле являются умно замаскированным Лиспом. Если XML может прямо считываться Лисп считывателем [XML-AS-READ-MACRO], то может быть XML - это просто видоизменённый Лисп. Подобным образом считывающие макросы могут использоваться для чтения регулярных выражений и SQL запросов прямо в Лисп, то может быть эти языки на самом деле являются Лиспом. Это нечёткое различие между кодом и данными, Лиспом и не-Лиспом, являются источником многих интересных философских проблем, возникающих перед Лисп программистами с самого начала зарождения Лиспа.

Базовый считывающий макрос, встроенный в Common Lisp - это \emph{\#.} - вычисляющий макрос в момент чтения. Этот считывающий макрос позволяет вам встраивать объекты в читаемые, не сериализируемые формы, но создаваемые с помощью Лисп кода. Один забавный пример - это создание формы, содержащей изменяющиеся значения при каждом вызове.

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 177030) (COIN-FLIP TAILS))
\end{verbatim}

Несмотря на то, что это то-же самое выражение, эта форма считывается по разному раз за разом:

\begin{verbatim}
CL-USER> '(football-game
           (game-started-at
            #.(get-internal-real-time))
           (coin-flip
            #.(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 385713) (COIN-FLIP HEADS))
\end{verbatim}

Заметьте, что две формы окружённые \emph{\#.} вычисляются в момент чтения, а не тогда, когда вычисляется форма. Полный список был сформирован после того, как они были вычислены, а предыдущая и последующая эквивалентность (определённая \textbf{equal}'ом) может быть обнаружена через повторное вычисление последней прочитанной формы и сравнения её с предыдущими результатами, с помощью вспомогательных переменных \emph{*}, \emph{+} в REPL\footnote{Переменная \emph{*} содержит значение, являющееся результатом предыдущей формы, а переменная \emph{+} содержит значение последней формы.}:

\begin{verbatim}
CL-USER> (equal * (eval +))
T
\end{verbatim}

Следует обратить внимание на то, что эти формы вычисляются в момент чтения, этим они отличаются от использования обратной кавычки, более подробно мы рассмотрим обратную кавычку в следующем разделе. Мы можем вычислить подобную форму с помощью использования обратных кавычек:

\begin{verbatim}
CL-USER> `(football-game
           (game-started-at
            ,(get-internal-real-time))
           (coin-flip
            ,(if (zerop (random 2)) 'heads 'tails)))
(FOOTBALL-GAME (GAME-STARTED-AT 722283) (COIN-FLIP TAILS))
\end{verbatim}

но в этом случае будет происходить вычисление в различные результаты, поскольку обратная кавычка производит считывание в виде кода для вычисления:

\begin{verbatim}
CL-USER> (equal * (eval +))
NIL ;если вы не очень быстрый и удачливый
\end{verbatim}

\section{Обратная Кавычка}\label{section_backquote}

\emph{Обратная кавычка}, иногда называемая как \emph{квазикавычка (quasiquote)}\footnote{Scheme программисты называют её квазикавычкой а Common Lisp программисты - обратной кавычкой.} и отображаемая как \verb"`" - это относительно новый элемент в промышленных диалектах Лиспа. Эта концепция по-прежнему абсолютно чужда для не-Лисп языков программирования.

У обратной кавычки странная история развития. Обратная кавычка развивалась параллельно с Лиспом. Есть сведения [QUASIQUOTATION] о том, что раньше никто не верил в то, что вложенные обратные кавычки будут работать правильно, пока умные программисты не выяснили что обратные кавычки правильно выполняют свою работу - идеи людей о том, что было верным оказались неверными. Известно, что трудно понять работу вложенной обратной кавычки. Даже Стил (Steele), отец Common Lisp'а, жалуется на это [CLTL2—P530].

В принципе Лисп не нуждается в обратной кавычке. Всё, что можно выполнить с помощью обратной кавычки - можно выполнять с помощью других функций, предназначенных для постройки списков. Однако, обратная кавычка настолько полезна при программировании макросов, а в Лиспе под программированием понимается программирование макросов, что Лисп профессионалы очень активно ею пользуются.

Вначале мы должны разобраться с обычным закавычиванием. В Лиспе, мы используем префикс формы в виде символа кавычки (') для того, чтобы информировать Лисп о том, что следующая форма должна рассматриваться как сырые данные, а не как код, который нужно вычислить. Или, если выразиться иначе, результатом вычисления кавычки в коде будет возвращение формы. Иногда мы говорим что кавычка \emph{останавливает} или \emph{отключает} вычисление формы.

В Лиспе обратная кавычка может использоваться как замена кавычки. Исключая некоторые специальные символы, называемые символами \emph{раскавычивания (unquote)} и могущие появиться в форме, обратная кавычка останавливает вычисление тем-же способом, что и кавычка. Как следует из названия символы раскавычивания изменяют семантику вычисления. Иногда мы говорим что раскавычивание \emph{перезапускает} или \emph{включает} вычисление формы.

Есть три главных типа раскавычивания: обычное раскавычивание, объединяющее раскавычивание и деструктивное, объединяющее раскавычивание.

Для выполнения обычного раскавычивания, мы используем оператор запятую:

\begin{verbatim}
CL-USER> (let ((s 'hello))
           `(,s world))
(HELLO WORLD)
\end{verbatim}

Хотя выражение, которое мы раскавычили является простым вычислением символа, \textbf{s}, на месте этого символа может быть любое Лисп выражение, вычисляемое в нечто значимое для любого контекста, в котором оно появляется в шаблоне обратной кавычки. Каким бы ни был результат, он будет вставлен в результирующий список в car позиции того места в котором он появился в шаблоне обратной кавычки.

В нотации Лисповской формы мы можем использовать \textbf{.} если мы хотим явно вставить что-либо cdr'ное в создаваемую списковую структуру. Если здесь мы вставим список, то результирующей формой обратной кавычки будет корректный список. Но, если здесь мы вставим что-нибудь другое, то мы получим новую не-списковую структуру.

Такое-же поведение доступно нам везде, в том числе внутри обратной кавычки\footnote{Поскольку обратная кавычка использует (почти ту же) стандартную функцию \textbf{read} что и везде.}. Благодаря архитектуре обратной кавычки мы можем раскавычивать элементы даже в такой позиции:

\begin{verbatim}
CL-USER> (let ((s '(b c d)))
           `(a .,s))
(A B C D)
\end{verbatim}

Вставка списков в \emph{cdr} позиции создаваемого списка из шаблона обратной кавычки оказалось весьма универсальной операцией, поэтому был сделан следующий шаг названный как объединяющее раскавычивание. Вышеприведённая комбинация \textbf{.,} полезна, но не способна вставлять элементы в середину списка. Для этого у нас есть оператор объединяющее раскавычивание:

\begin{verbatim}
CL-USER> (let ((s '(b c d)))
           `(a ,@s e))
(A B C D E)
\end{verbatim}

Ни \textbf{.,} ни \textbf{,@} не модифицируют сращиваемый список. Для примера, после вычисления обратной кавычки в обеих предыдущих формах, \textbf{s} по прежнему будет привязан к трёх элементному списку \textbf{(B C D)}. Хотя это не является строго определяемым стандартом, в форме \textbf{(A B C D)}, \textbf{(B C D)} может являться общей структурой с объединённым списком \textbf{s}. Однако, структура списка \textbf{(A B C D E)} гарантирует, что она будет свежесозданной при вычислении обратной кавычки, поскольку \textbf{,@} запрещено модифицировать сращенные списки. Объединяющее раскавычивание - не деструктивная операция, поскольку в целом нам нужно думать об обратной кавычке как о компонуемом шаблоне для создания списков. Деструктивная модификация списковой структуры не свежесозданных данных при каждом вычислении обратно закавыченного кода может иметь нежелательные эффекты в плане будущих расширений.

Однако, в Common Lisp есть деструктивная версия сращиваемого раскавычивания, которое вы можете использовать везде, где можно использовать сращивающее раскавычивание. Для деструктивного раскавычивания используйте \textbf{,.} . Деструктивное сращивание работает также, как и обычное сращивание, за исключением того, что сращиваемый список может быть модифицирован в процессе вычисления шаблона обратной кавычки. И хотя отличие от обычного раскавычивания выражается всего лишь в одном символе, эта нотация более умно использует символ \textbf{.} из \emph{cdr} позиционного раскавычивания \textbf{.,} рассмотренного выше.

Для того, чтобы увидеть это в действии, в этом примере мы деструктивно модифицируем список указанный в \emph{to-splice}:

\begin{verbatim}
CL-USER> (defvar to-splice '(B C D))
TO-SPLICE
CL-USER> `(A ,.to-splice E)
(A B C D E)
CL-USER> to-splice
(B C D E)
\end{verbatim}

Выполнение де\-струк\-тив\-ной модификации сращиваемых списков может быть опасной операцией. Рассмотрим следующее применение деструктивного сращивания:

\begin{verbatim}
(defun dangerous-use-of-bq ()
  `(a ,. '(b c d) e))
\end{verbatim}

При первом вызове \textbf{dangerous-use-of-bq} возвращается ожидаемый ответ: \textbf{(A B C D E)}. Но, поскольку эта функция использует деструктивное сращивание и модификацию не свежесгенерированных списков - закавыченный список - то мы можем ожидать возникновения различных нежелательных последствий. В этом случае при втором вычислении \textbf{dangerous-use-of-bq} форма \textbf{(B C D)} будет представлять из себя форму \textbf{(B C D E)} и в момент, когда обратная кавычка попытается деструктивно срастить этот список с остатком шаблона обратной кавычки \textbf{(E)} - его собственный хвост - будет создан список, содержащий \emph{цикл (cycle)}. Более детально мы обсудим циклы в \emph{разделе Циклические Выражения}.

Однако, есть много случаев в которых деструктивное сращивание является чрезвычайно безопасным. Не позволяйте \textbf{dangerous-use-of-bq} напугать вас если вам нужна повышенная эффективность в ваших формах обратной кавычки. Есть множество операций, создающих свежие списковые структуры, которые вам так или иначе могут не понадобиться. Например, сращивание результатов \emph{mapcar} настолько распространено и безопасно, что вполне может претендовать на программную идиому:

\begin{verbatim}
(defun safer-use-of-bq ()
  `(a
    ,.(mapcar #'identity '(b c d))
    e))
\end{verbatim}

Но, есть деталь, которая мешает этому. Чаще всего обратная кавычка используется для создания макросов, часть программирования на Лиспе, где менее важна скорость и более важна ясность. Если думать о \emph{побочных эффектах} в ваших операциях сращивания, то при создании и интерпретации макросов вам придётся часто отвлекаться на них, а это не стоит свеч. Эта книга придерживается обычных сращиваний. Чаще всего обратная кавычка используется для конструирования макросов, но, это не единственное их использование. Обратная кавычка - это удобный предметно ориентированный язык для смешивания списков, и ещё более удобным он становится с возможностью деструктивного сращивания.

Как работает обратная кавычка? Обратная кавычка - это считывающий макрос. Формы обратной кавычки читаются как код, который при вычислении, становится желаемым списком. Возвращаясь к примеру из предыдущего раздела о вычислении во время выполнения, мы можем отключить \emph{красивую печать (pretty printing)}, закавычить значение формы обратной кавычки и вывести его на печать для того, чтобы увидеть как читаются формы с обратной кавычкой\footnote{Мы возвращаем \textbf{t} и поэтому мы не видим значения, возвращаемого от \textbf{print}. \textbf{(values)} также универсальны.}:

\begin{verbatim}
CL-USER> (let (*print-pretty*);привязка к nil
           (print
            '`(football-game
            (game-started-at
             ,(get-internal-real-time))
            (coin-flip
             ,(if (zerop (random 2))
                  'heads
                  'tails))))
           t)

(SB-IMPL::BACKQ-LIST 
 (QUOTE FOOTBALL-GAME) 
 (SB-IMPL::BACKQ-LIST 
  (QUOTE GAME-STARTED-AT) 
  (GET-INTERNAL-REAL-TIME)) 
 (SB-IMPL::BACKQ-LIST 
  (QUOTE COIN-FLIP) 
  (IF (ZEROP (RANDOM 2)) 
      (QUOTE HEADS) 
      (QUOTE TAILS)))) 
T
\end{verbatim}

В этой, \emph{некрасиво напечатанной} форме, функция {\selectlanguage{english}\textbf{LISP::BACKQ-LIST}} идентична \textbf{list}, за исключением поведения, связанного с красивой печатью. Заметьте, что операторы запятая исчезли. Common Lisp очень либерален и поэтому позволяет читать обратные кавычки, также, как и допускает операции с использованием общих структур.

Кроме того обратная кавычка предоставляет много интересных решений забавной \emph{не совсем проблемы} написания Лисп выражений, вычисляющихся в самих себя. Эти выражения часто называются \emph{куайнами} в честь Уилларда Куайна, который занимался их широким изучением и кто, по сути, ввёл термин квазицитирования - альтернативное название обратной кавычки [FOUNDATIONS-P31-FOOTNOTE3]. Вот забавный пример куайна, от Майка МакМахонома (Mike McMahon) {\selectlanguage{english} [QUASIQUOTATION]}:

\begin{verbatim}
CL-USER> (let ((let '`(let ((let ',let))
                        ,let)))
           `(let ((let ',let)) ,let))
(LET ((LET
       '`(LET ((LET ',LET))
           ,LET)))
  `(LET ((LET ',LET))
     ,LET))
\end{verbatim}

Для сохранения вашего \emph{ментального прохода по коду}:

\begin{verbatim}
CL-USER> (equal * +)
T
\end{verbatim}

Упражнение: Почему в выражении ниже обратная кавычка расширяется в обычную кавычку? Разве оно не закавычено?

\begin{verbatim}
CL-USER> `'q
'Q
\end{verbatim}

\section{Чтение Строк}\label{section_reading_strings}

В Лиспе строки разграничиваются символами двойной кавычки (\verb|"|). Хотя строки могут содержать любые символы из символьного набора в вашей Лисп реализации, но вы не можете непосредственно вставлять определённые символы в строку. Если вы хотите вставить символ \verb|"| или символ \verb"\", то вам придётся использовать префикс в виде символа \verb"\". Это называется \emph{экранированием} символов. Ниже показан пример с введением строки, содержащей символы \verb|"| и \verb"\":

\begin{verbatim}
 * "Contains \" and \\."
"Contains \" and \\."
\end{verbatim}

Принцип работы очевиден, но иногда печать символов \verb"\" становится утомительным и порождает ошибки. Это Лисп, и если нам что-то не нравится, то мы в силах внести наши изменения, это не просто легко сделать, но, ещё и приветствуется. Придерживаясь этой мысли, эта книга представляет считывающий макрос под названием \emph{\#"} или \emph{sharp-double-quote}. Этот считывающий макрос предназначен для создания строк, содержащих символы \verb|"| и \verb"\" без необходимости экранирования.

Листинг 4.1: SHARP-DOUBLE-QUOTE\label{listing_4.1}
\hrule
\begin{verbatim}
(defun |#"-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let (chars)
    (do ((prev (read-char stream) curr)
         (curr (read-char stream) (read-char stream)))
        ((and (char= prev #\") (char= curr #\#)))
      (push prev chars))
    (coerce (nreverse chars) 'string)))

(set-dispatch-macro-character
 #\# #\" #'|#"-reader|)
\end{verbatim}
\hrule

\emph{Sharp-double-quote}\footnote{Наше соглашение об именовании нижележащих функций считывающих макросов с символами основывается на символах считывающего макроса, похожих на Стиловский считыватель \textbf{\#"-reader} в CLtL2.} начинает чтение строки непосредственно после вызова следующих символов: \emph{\#} и \emph{"}. Чтение будет продолжаться символ за символом до тех пор, пока в последовательности не встретятся два символа \emph{"} и \emph{\#}. Когда будет обнаружена завершающая последовательность, то будет возвращена строка, содержащая все символы между \emph{\#"} и \emph{"\#}. Считывающий макрос \emph{sharp-double-quote} создан для работы с битовыми строками, но Common Lisp позволяет нам использовать этот макрос передавая битовую строку в считывающий макрос \emph{\#*} [EARLY-CL-VOTES]. 

Вот пример использования нашего нового \emph{sharp-double-quote}:

\begin{verbatim}
 * #"Contains " and \."#

"Contains \" and \\."
\end{verbatim}

Учтите, что при печати строки REPL по прежнему будет использовать символ \verb|"| в качестве разграничителя, поэтому символы \verb|"| и \verb"\" по прежнему будут экранироваться в печатаемой строке. Эти строки по прежнему будут прочитываться так, как будто символы в них были экранированы вручную.

Но, иногда \emph{\#"} оказывается недостаточно хорошим. Например: в этом, только что прочитанном вами, параграфе U-Языка я вставил следующую последовательность символов: \emph{"\#}. По этой причине этот параграф не будет ограничиваться \emph{\#"} и \emph{"\#}. А поскольку я ненавижу экранируемые элементы, то поверьте мне на слово, здесь не будет разграничения обычными двойными кавычками.

Нам нужен макрос, который бы мог дать нам возможность модифицировать разграничитель для каждого используемого контекста. Как это часто бывает нам не нужно идти далеко за примером, достаточно взглянуть на язык Ларри Уолла - Perl чтобы почерпнуть вдохновения для архитектуры программных сокращений. Perl - это прекрасный, чудесно спроектированный язык, содержащий большое количество идей, которые могут быть \emph{украдены} Лиспом. В некотором роде, Лисп - это снежный ком, который катится по идеям из других языков программирования и вбирает их в себя, делая эти идеи своей частью\footnote{Наиболее цитируемым примером являются объекты, но кроме них существуют ещё бесчисленное множество других примеров, таких как функция \textbf{format} из FORTRAN'а.}.

Считывающий макрос \textbf{\#>} непосредственно вдохновлён оператором Perl'а \textbf{<<}. 

Листинг 4.2: SHARP-GREATER-THAN\label{listing_4.2}
\hrule
\begin{verbatim}
(defun |#>-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let (chars)
    (do ((curr (read-char stream)
               (read-char stream)))
        ((char= #\newline curr))
      (push curr chars))
    (let* ((pattern (nreverse chars))
           (pointer pattern)
           (output))
      (do ((curr (read-char stream)
                 (read-char stream)))
          ((null pointer))
        (push curr output)
        (setf pointer
              (if (char= (car pointer) curr)
		  (cdr pointer)
                pattern))
        (if (null pointer)
	    (return)))
      (coerce
       (nreverse
	(nthcdr (length pattern) output))
       'string))))

(set-dispatch-macro-character
 #\# #\> #'|#>-reader|)
\end{verbatim}
\hrule

Этот оператор позволяет Perl программистам определять строку текста, которая будет служить разграничителем для цитируемой строки. \textbf{\#>} читает символы до тех пор, пока не найдёт символ перехода на новую строку, затем читает символы один-за-другим, до тех пор, пока не встретиться последовательность символов идентичная символам обнаруженным сразу после \textbf{\#>} и до новой строки.

Например:

\begin{verbatim}
 * #>END
I can put anything here: ", \, "#, and ># are
no problem. The only thing that will terminate
the reading of this string is...END

"I can put anything here: \", \\, \"#, and ># are
no problem. The only thing that will terminate
the reading of this string is..."
\end{verbatim}

\section{CL-PPCRE}\label{section_cl-ppcre}

CL-PPCRE [CL-PPCRE] - это высокопроизводительная библиотека регулярных выражений, написанная на Common Lisp. Она была создана широко известным и уважаемым Лисп хакером Эди Вейтзом (Edi Weitz). Этот раздел посвящается Эди Вейтзу. В то время, когда другие люди болтают Эди пишет программы; код говорит громче чем все аргументы.

PPCRE, для тех, кто ещё не знаком с этой библиотекой, - это Portable Perl Compatible Regular Expressions (Переносимые Perl Совместимые Регулярные Выражения). CL-PPCRE, также как и код в этой книге, является \emph{переносимым}, поскольку может запускаться в любой ANSI - совместимой Common Lisp среде. CL-PPCRE, также как код в этой книге является открытым и доступным бесплатно. Хотя CL-PPCRE в основном прекрасно совместим с Perl'ом, всё же существуют некоторые важные различия от Perl. CL-PPCRE содержит несколько лисповых улучшений в регулярных выражениях. Есть три различия, которыми CL-PPCRE отличается от реализации регулярных выражений в Perl.

Первое, CL-PPCRE быстр. Действительно быстр. Замеры производительности CL-PPCRE, скомпилированного с помощью хорошего, родного компилятора кода, показали что для большинства регулярных выражений CL-PPCRE оказывается в два раза быстрее Perl'а, а довольно часто ещё быстрее. И это при том, что Perl обладает одним из наиболее быстрейших не-лисповых движков регулярных выражений: высоко оптимизированный движок, написанный на C. Почему это возможно? Конечно, Perl'овская низко-уровневая реализация должна обладать производительностью, превосходящую всё, что написано на таком высоко-уровневом языке, как Лисп.

Есть заблуждение, известное как \emph{миф производительности}, основная версия следующая: использование низкоуровневых языков приводит к возникновению быстрого кода, поскольку вы можете программировать наиболее близко к железу. С помощью этой книги я хочу показать вам что для сложных систем этот миф является ложным. Примеры, подобные CL-PPCRE демонстрируют это. Чем более низкоуровневым является язык, тем больше он мешает вам и вашему компилятору эффективно оптимизировать код.

Техническая причина быстрой производительности CL-PPCRE следующая: Common Lisp, язык на котором реализовали CL-PPCRE, более мощный чем C, язык, использованный для реализации Perl. Когда Perl считывает регулярное выражение, он может выполнять анализ и оптимизацию, но в конечном счёте регулярное выражение будет сохранено в некоторую структуру данных C, после чего движок статичных регулярных выражений будет производить сравнивание. Но в Common Lisp - наиболее мощном языке - нет ничего сложного в том, чтобы получить это регулярное выражение, конвертировать его в Лисп программу и передать эту Лисп программу на оптимизацию в родной компилятор Лисп кода, используемый в том числе для построения всей остальной Лисп системы\footnote{На деле CL-PPCRE более запутан чем описано здесь. Эта библиотека содержит свою собственную функцию компилирования и, как правило, (если вы не строите регулярные выражения во время выполнения) гарантирует что она будет вызвана когда ваша программа будет скомпилирована.}. Поскольку программы, скомпилированные с помощью C компилятора не имеют доступ к C компилятору, Perl не может компилировать регулярные выражения в машинный код. Модель компиляции Лиспа отличается от модели C. В Common Lisp компиляция кода во время выполнения (как и в любое другое время) является переносимой, бесшовной, выполняющейся в том же процессе, что и ваша Лисп машина, отпадает необходимость в сборке мусора и, по причине инкрементальной природы, высокоэффективна.

Второе главное отличие между CL-PPCRE и Perl заключается в том, что CL-PPCRE не привязан к нотации регулярных выражений, основанной на строке. CL-PPCRE свободен от символьного представления и позволяет нам кодировать регулярные выражения в Лисп формах (иногда называемых \emph{S-выражениями}). Поскольку такие же формы мы используем для написания Лисп программ и макросов, то мы можем использовать больше возможностей для \emph{сплочения} в наших абстракций. За деталями использования такой нотации обращайтесь к документации и коду CL-PPCRE [CL-PPCRE], кроме того, код и документация CL-PPCRE может служить примером хорошо спроектированного, Лиспобразного предметно-ориентированного языка.

Конечно, CL-PPCRE - это замечательная библиотека, но почему мы обсуждаем эту библиотеку в главе, посвящённой считывающим макросам? Ответ заключается в третьей и последней разнице между CL-PPCRE и Perl. В Perl регулярные выражения тесно связаны с языком. Также, как синтаксис Лиспа - это способ работы с мета - программированием, синтаксис Perl'а - это способ работы с регулярными выражениями и другими видами синтаксических сокращений. Одна из причин по которой мы так часто используем регулярные выражения в Perl коде обусловлена тем, что использование регулярных выражений позволяет кратко и быстро писать программы.

Считывающие макросы очень удобны для реализации программного интерфейса в Perl стиле. Поскольку программирование считывающих макросов - это программирование Лиспа, то мы начнём с функции-утилиты: \textbf{segment-reader}. Получая поток, разделительный символ и счётчик, \textbf{segment-reader} будет читать символы из потока до тех пор, пока не встретится символ-разделитель. Если счётчик больше 1, \textbf{segment-reader} будет возвращать \emph{cons}. \emph{Car} этого \emph{cons}-а будет представлять строку и \emph{cdr} будет результатом рекурсивного вызова \textbf{segment-reader} с декрементированным параметром \emph{count} для получения следующего сегмента\footnote{В Common Lisp принято следующее правило: если вариант \emph{else} отсутствует в форме \emph{if} , а проверяемое выражение вернуло \emph{false}, то возвращаемое значение будет \emph{nil}. Опытные Common Lisp программисты часто полагаются именно на такое поведение, поэтому этот поведенческий шаблон, как базовый вариант рекурсивного построения списка, был применён при написании \textbf{segment-reader}.}.

Листинг 4.3: SEGMENT-READER\label{listing_4.3}
\hrule
\begin{verbatim}
(defun segment-reader (stream ch n)
  (if (> n 0)
      (let ((chars))
        (do ((curr (read-char stream)
                   (read-char stream)))
            ((char= ch curr))
          (push curr chars))
        (cons (coerce (nreverse chars) 'string)
              (segment-reader stream ch (- n 1))))))
\end{verbatim}
\hrule

Например, чтение 3 сегментов из потока t\footnote{Поток \textbf{t} соответствует стандартному вводу при работе в REPL'е.} с ограничительным символом \emph{/} будет осуществляться так:

\begin{verbatim}
CL-USER> (segment-reader t #\/ 3)
abc/def/ghi/
("abc" "def" "ghi")
\end{verbatim}

Скорее всего, Perl программисты уже поняли что здесь происходит. Идея заключается в том, чтобы \emph{своровать}, приношу искренние извинения Ларру Уоллу, синтаксис двух удобных операторов регулярных выражений Perl. В Perl, если нам нужно применить регулярное выражение к переменной, мы можем написать

\begin{verbatim}
$my_boolean = ($var =~ m/^\w+/);
\end{verbatim}

для того, чтобы увидеть начинается ли содержимое \textbf{\$var} с одной или более цифр или букв. Подобным образом, если нам нужно применить \emph{подстановку} регулярного выражения мы можем использовать Perl оператор \verb"=~" изменяющий первое вхождение \emph{dog} на \emph{cat} в нашей строчной переменной \textbf{\$var}:

\begin{verbatim}
$var =~ s/dog/cat/;
\end{verbatim}

Замечательной деталью Perl синтаксиса является возможность использования любого символа в качестве разделителя для удобства программирования. Если мы хотим использовать регулярные выражение или подстановку, содержащую символ \emph{/} , то мы должны использовать какой-либо отличающийся символ для избежания конфликтов\footnote{Это может быть не связано с Perl'ом; \TeX'овские дословные закавычивания предоставляют нечто подобное.}:

\begin{verbatim}
$var =~ s|/usr/bin/rsh|/usr/bin/ssh|;
\end{verbatim}

Определение считывающего макроса для копирования этих двух Perl синтаксисов даёт нам шанс для демонстрации интересных техник макросов - двойная обратная кавычка. Идея та же, что и в макросах \textbf{match-mode-ppcre-lambda-form} и \textbf{subst-mode-ppcre-lambda-form} - желание писать код, генерирующий списки. Учтите, что когда вы определяете макрос без прикрас и используете единственную обратную кавычку, то в этом случае вы генерируете список, представляющий код и возвращаете его из макроса для последующего объединения в выражения и вычисления. С двойными обратными кавычками вы по прежнему генерируете список, представляющий код, но, этот код при вычислении будет использовать код, созданный обратной кавычкой для возвращения списка. В нашем случае, эти два макроса расширяются в код, который вы можете вычислить для создания лямбда форм, пригодных для использования регулярных выражений CL-PPCRE.

Листинг 4.4: MATCH-MODES\label{listing_4.4}
\hrule
\begin{verbatim}
#+cl-ppcre
(defmacro! match-mode-ppcre-lambda-form (o!args)
  ``(lambda (,',g!str)
      (cl-ppcre:scan
       ,(car ,g!args)
       ,',g!str)))

#+cl-ppcre
(defmacro! subst-mode-ppcre-lambda-form (o!args)
  ``(lambda (,',g!str)
      (cl-ppcre:regex-replace-all
       ,(car ,g!args)
       ,',g!str
       ,(cadr ,g!args))))
\end{verbatim}
\hrule

Перед этими макросами, как и с некоторыми другими выражениями ниже, мы используем считывающий макрос \verb"#+". Этот считывающий макрос выясняет где нам требуется CL-PPCRE\footnote{Этот макрос определяет необходимость CL-PPCRE с помощью поиска ключевого символа \textbf{:CL-PPCRE} в списке, сохранённом в переменной \textbf{*features*}.} перед вычислением следующей формы. Если CL-PPCRE не будет доступен при загрузке исходного кода из этой книги, то этот код не будет работать.

И наконец мы можем определить считывающую функцию для объединения этих утилит, а затем добавить эту функцию в нашу таблицу диспетчеризации макроса. Мы решили использовать считывающий макрос \verb"#~" поскольку это хороший аналог Perl'овского \verb"#~" - источника, вдохновившего нас на такой синтаксис.

Листинг 4.5: CL-PPCRE-READER\label{listing_4.5}
\hrule
\begin{verbatim}
#+cl-ppcre
(defun |#~-reader| (stream sub-char numarg)
  (declare (ignore sub-char numarg))
  (let ((mode-char (read-char stream)))
    (cond
      ((char= mode-char #\m)
       (match-mode-ppcre-lambda-form
        (segment-reader stream
                        (read-char stream)
                        1)))
      ((char= mode-char #\s)
       (subst-mode-ppcre-lambda-form
        (segment-reader stream
                        (read-char stream)
                        2)))
      (t (error "Unknown #~~ mode character")))))

#+cl-ppcre
(set-dispatch-macro-character #\# #\~ #'|#~-reader|)
\end{verbatim}
\hrule

Считывающий макрос \verb"#~" спроектирован с упором на удобство. Вот как мы можем создать функцию, производящую сравнение с регулярным выражением:

\begin{verbatim}
CL-USER> #~m/abc/
#<FUNCTION (LAMBDA (#:STR178)) {CAB9B35}>
\end{verbatim}

Теперь применение этой функции к строке не будет отличаться от обычного вызова функции\footnote{Переменная \textbf{*} привязана к значению, возвращённому последним вычислением в REPL. В данный момент эта переменная привязана к нашей функции регулярного выражения.}:

\begin{verbatim}
CL-USER> (funcall * "123abc")
3
6
#()
#()
\end{verbatim}

Значения, возвращаемые от функции \textbf{cl-ppcre:scan}, задокументированы в [CL-PPCRE]. Если же вы интересуетесь только тем, совпала-ли строка с регулярным выражением, то вам понадобится только первое значение, истинное значение обозначает что обнаружено совпадение. Обобщённые логические значения и их важность в Common Lisp обсуждается позже в \emph{главе Анафорические Макросы}.

Также мы можем создавать функции, производящие замену на базе регулярных выражений. Маленькая разница между Perl и нашим считывающим макросом в том, что функции замены на базе регулярных выражений не модифицируют свои аргументы. Они будут возвращать новые строки, являющиеся копиями исходных строк с выполненной заменой. Другим отличием является то, что, по умолчанию, этот считывающий макрос производит замену всех соответствий вместо замены первого соответствия в строке. Для того, чтобы получить такое поведение в Perl, вам понадобится добавить глобальный модификатор в ваше регулярное выражение, но в нашем случае глобального модификатора не нужно:

\begin{verbatim}
CL-USER> (funcall #~s/abc/def/ "Testing abc testing abc")
"Testing def testing def"
T
\end{verbatim}

Итак, как всё это работает? Что делают выражения \verb"#~", которые не являются Лисп выражениями? При поверхностном взгляде кажется что они считываются как функции, но оказывается что это не так. Давайте закавычим одну из этих форм и посмотрим как эта форма выглядит для Лисп считывателя:

\begin{verbatim}
CL-USER> '#~m|\w+tp://|
(LAMBDA (#:STR178) (CL-PPCRE:SCAN "\\w+tp://" #:STR178))
\end{verbatim}

Подстановки выглядят также:

\begin{verbatim}
CL-USER> '#~s/abc/def/
(LAMBDA (#:STR179) (CL-PPCRE:REGEX-REPLACE-ALL "abc" 
                                               #:STR179 "def"))
\end{verbatim}

Они считываются как лямбда формы. Поскольку мы работаем с Лисп считывателем, то мы не можем написать их в каком-либо не-Лисп языке. Это обозначение функции. По той причине, что наши выражения являются простыми списками, в котором первым элементом выступает символ \textbf{lambda}, а в \emph{разделе Let - это Lambda} обсуждается как мы можем использовать лямбда формы в первом аргументе вызова функции для порождения анонимных функций:

\begin{verbatim}
CL-USER> (if (#~m/^[\w-.]+$/ "hcsw.org")
	     'kinda-looks-like-a-domain
	     'no-chance!)
KINDA-LOOKS-LIKE-A-DOMAIN
\end{verbatim}

Когда мы применяем \textbf{funcall} или \textbf{apply} для использования объектов считанных с помощью \verb"#~", то в этом случае мы используем ANSI макрос \textbf{lambda}, но только не в том случае, когда форма является первой в списке: польза \emph{двойственности синтаксиса}. Если наши \verb"#~" выражения считываются как шарп-закавыченные лямбда формы, то мы не сможем использовать их в качестве функций в выражениях - здесь могут использоваться только имена функций и лямбда формы. Для этих обеих задач нам понадобится только один считывающий макрос, по счастливой случайности этот макрос большой и сложный. Преимущества двойственного синтаксиса позволит нам сфокусироваться на получении корректного расширения вместо отслеживания требований различного синтаксиса. Вместо одного интересного макроса мы получаем два интересных макроса. Для экономии усилий, сделаем ваш синтаксис наиболее близким к оригиналу.

Общей проблемой использования CL-PPCRE является \emph{экранирование} обратной косой черты в регулярных выражениях - программисты постоянно забывают о необходимости экранирования. Посмотрите, что получится при выполнении такого кода:

\begin{verbatim}
CL-USER> "\w+"
"w+"
\end{verbatim}

Длина этой строки равна 2. Куда пропала обратная косая черта? Использование двойных кавычек обозначает что мы хотели экранировать символ \emph{w} вместо печати символа \verb"\". Для нашего считывающего макроса \verb"#~", который просто считывает символы, это не проблема и мы можем писать регулярные выражения также, как это мы делаем в Perl - без экранирования. Смотрите закавычивание регулярных выражений URL выше.

И хотя считывающий макрос \verb"#~" определённый в этом разделе уже очень удобен, всё ещё есть место для его улучшения и расширения. Упражнение: Улучшите этот макрос. Наиболее очевидным первым шагом будет поддержка таких модификаторов регулярных выражений, как нечувствительность к регистру при сравнивании. Если продолжать реализовывать всё в том же синтаксисе что и в Perl, то работа будет связана с функцией \textbf{unread-char}, широко применяемой в считывающих макросах для избежания непреднамеренного \emph{съедания} символа, которое может ожидать какой-либо другой считывающий макрос.
